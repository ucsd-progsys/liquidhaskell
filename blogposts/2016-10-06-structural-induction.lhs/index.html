

<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="Niki Vazou">
      
      
        <link rel="canonical" href="https://ucsd-progsys.github.io/liquidhaskell/blogposts/2016-10-06-structural-induction.lhs/">
      
      
        <link rel="prev" href="../2017-03-20-arithmetic-overflows.lhs/">
      
      
        <link rel="next" href="../2016-09-18-refinement-reflection.lhs/">
      
      
      <link rel="icon" href="../../static/img/favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.42">
    
    
      
        <title>Refinement Reflection on ADTs - LiquidHaskell Docs</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.0253249f.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@5.9.55/css/materialdesignicons.min.css">
    
      <link rel="stylesheet" href="../../static/liquid-light.css">
    
      <link rel="stylesheet" href="../../static/misc.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="cyan" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#lists-are-monoids" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="LiquidHaskell Docs" class="md-header__button md-logo" aria-label="LiquidHaskell Docs" data-md-component="logo">
      
  <img src="../../static/img/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            LiquidHaskell Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Refinement Reflection on ADTs
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/ucsd-progsys/liquidhaskell" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="https://liquidhaskell.goto.ucsd.edu/index.html" class="md-tabs__link">
        
  
    
  
  <div id='demo'><i aria-hidden=true class='mdi mdi-cloud-braces'></i> Try Online</div>

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-human-greeting'></i> Tutorial

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
    
  
  

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../install/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-download'></i> Installation

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../specifications/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-script'></i> Spec Reference

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../options/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-flag'></i> Flag Reference

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
    
  
  

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../papers/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-school'></i> Papers

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../2020-08-20-lh-as-a-ghc-plugin.lhs/" class="md-tabs__link">
          
  
  <i aria-hidden=true class='mdi mdi-bullhorn'></i> Blog

        </a>
      </li>
    
  

    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="LiquidHaskell Docs" class="md-nav__button md-logo" aria-label="LiquidHaskell Docs" data-md-component="logo">
      
  <img src="../../static/img/logo.png" alt="logo">

    </a>
    LiquidHaskell Docs
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/ucsd-progsys/liquidhaskell" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="https://liquidhaskell.goto.ucsd.edu/index.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <div id='demo'><i aria-hidden=true class='mdi mdi-cloud-braces'></i> Try Online</div>
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-human-greeting'></i> Tutorial
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../install/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-download'></i> Installation
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../specifications/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-script'></i> Spec Reference
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../options/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-flag'></i> Flag Reference
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../papers/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-school'></i> Papers
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="">
            
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-bullhorn'></i> Blog
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            <i aria-hidden=true class='mdi mdi-bullhorn'></i> Blog
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_1" checked>
        
          
          <label class="md-nav__link" for="__nav_9_1" id="__nav_9_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Blogposts
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_1_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9_1">
            <span class="md-nav__icon md-icon"></span>
            Blogposts
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2020-08-20-lh-as-a-ghc-plugin.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LiquidHaskell is a GHC Plugin
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2020-04-12-polymorphic-perplexion.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Polymorphic Perplexion
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2019-10-20-why-types.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Liquid Types vs. Floyd-Hoare Logic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2018-05-17-hillel-verifier-rodeo-I-leftpad.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    The Hillelogram Verifier Rodeo I (LeftPad)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2018-02-23-measures-and-case-splitting.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Measures and Case Splitting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2017-12-24-splitting-and-splicing-intervals-II.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Splitting and Splicing Intervals (Part 2)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2017-12-15-splitting-and-splicing-intervals-I.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Splitting and Splicing Intervals (Part 1)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2017-03-20-arithmetic-overflows.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Arithmetic Overflows
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Refinement Reflection on ADTs
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Refinement Reflection on ADTs
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#lists-are-monoids" class="md-nav__link">
    <span class="md-ellipsis">
      Lists are Monoids
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lists" class="md-nav__link">
    <span class="md-ellipsis">
      Lists
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#induction-on-lists" class="md-nav__link">
    <span class="md-ellipsis">
      Induction on Lists
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reflecting-lists-into-the-logic" class="md-nav__link">
    <span class="md-ellipsis">
      Reflecting Lists into the Logic
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#defining-the-monoid-operators" class="md-nav__link">
    <span class="md-ellipsis">
      Defining the Monoid Operators
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#proving-the-monoid-laws" class="md-nav__link">
    <span class="md-ellipsis">
      Proving the Monoid Laws
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    <span class="md-ellipsis">
      Conclusion
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2016-09-18-refinement-reflection.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Haskell as a Theorem Prover
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2016-09-01-normal-forms.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Normal Forms
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2015-01-30-okasakis-lazy-queue.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Okasaki's Lazy Queues
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2014-08-15-a-finer-filter.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A Finer Filter
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2014-05-28-pointers-gone-wild.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Pointers Gone Wild
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2014-02-11-the-advantage-of-measures.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    The Advantage of Measures
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-12-14-gcd.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Termination Requires Refinements
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-12-09-checking-termination.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Checking Termination
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-12-02-getting-to-the-bottom.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Getting To the Bottom
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-11-23-telling_lies.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LiquidHaskell Caught Telling Lies!
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-10-10-csv-tables.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CSV Tables
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-07-29-putting-things-in-order.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Putting Things In Order
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-06-03-abstracting-over-refinements.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Abstracting Over Refinements
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-05-24-unique-zipper.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Unique Zippers
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-03-26-talking-about-sets.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Talking About Sets
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-03-04-bounding-vectors.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Bounding Vectors
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-02-17-kmeans-clustering-II.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    KMeans Clustering II
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-02-16-kmeans-clustering-I.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    KMeans Clustering I
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-01-31-safely-catching-a-list-by-its-tail.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Safely Catching A List By Its Tail
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-01-28-bounding-vectors.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Bounding Vectors
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-01-27-refinements101-reax.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Refinements 101 (contd.)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-01-01-refinement-types-101.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Refinement Types 101
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tags.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tags
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#lists-are-monoids" class="md-nav__link">
    <span class="md-ellipsis">
      Lists are Monoids
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lists" class="md-nav__link">
    <span class="md-ellipsis">
      Lists
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#induction-on-lists" class="md-nav__link">
    <span class="md-ellipsis">
      Induction on Lists
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reflecting-lists-into-the-logic" class="md-nav__link">
    <span class="md-ellipsis">
      Reflecting Lists into the Logic
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#defining-the-monoid-operators" class="md-nav__link">
    <span class="md-ellipsis">
      Defining the Monoid Operators
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#proving-the-monoid-laws" class="md-nav__link">
    <span class="md-ellipsis">
      Proving the Monoid Laws
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    <span class="md-ellipsis">
      Conclusion
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                


                  
  
<nav class="md-tags" >
  
    
    
    
      <span class="md-tag">reflection</span>
    
  
    
    
    
      <span class="md-tag">induction</span>
    
  
    
    
    
      <span class="md-tag">measures</span>
    
  
</nav>


  
  


  <h1>Refinement Reflection on ADTs</h1>

<h2 id="lists-are-monoids">Lists are Monoids<a class="headerlink" href="#lists-are-monoids" title="Permanent link">&para;</a></h2>
<p><a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2016/09/18/refinement-reflection.lhs/">Previously</a> we saw how Refinement Reflection
can be used to write Haskell functions that prove theorems about
other Haskell functions. Today, we will see how Refinement Reflection
works on <strong>recursive data types</strong>.
As an example, we will prove that <strong>lists are monoids</strong> (under nil and append).</p>
<p>Lets see how to express <strong>the monoid laws</strong> as liquid types, and then prove
the laws by writing plain Haskell functions that are checked by LiquidHaskell.</p>
<!-- more -->

<p><br></p>
<div class="row-fluid">
  <div class="span12 pagination-centered">
  <p style="text-align:center">
  <img class="center-block" src="http://www.aaronartprints.org/images/Paintings/4597.jpg" alt="Recursion" width="300">
       <br>
       Recursive Paper and Pencil Proofs.
       "Drawing Hands" by Escher.
       <br>
  </p>
  </div>
</div>

<div class="hidden">

<pre><span class=hs-linenum>46: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--higherorder"</span>     <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>47: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--totality"</span>        <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>48: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>StructuralInduction</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>49: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Language</span><span class='hs-varop'>.</span><span class='hs-conid'>Haskell</span><span class='hs-varop'>.</span><span class='hs-conid'>Liquid</span><span class='hs-varop'>.</span><span class='hs-conid'>ProofCombinators</span>
<span class=hs-linenum>50: </span>
<span class=hs-linenum>51: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span><span class='hs-layout'>)</span>
<span class=hs-linenum>52: </span>
<span class=hs-linenum>53: </span><span class='hs-definition'>length</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>54: </span><span class='hs-definition'>leftId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
<span class=hs-linenum>55: </span><span class='hs-definition'>rightId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
<span class=hs-linenum>56: </span><span class='hs-definition'>associativity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
</pre>
</div>

<h2 id="lists">Lists<a class="headerlink" href="#lists" title="Permanent link">&para;</a></h2>
<p>First, lets define the <code>List a</code> data type</p>
<pre><span class=hs-linenum>66: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>C</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
</pre>

<h2 id="induction-on-lists">Induction on Lists<a class="headerlink" href="#induction-on-lists" title="Permanent link">&para;</a></h2>
<p>As we will see, <em>proofs</em> by structural induction will correspond to
<em>programs</em> that perform recursion on lists. To keep things legit,
we must verify that those programs are total and terminating.</p>
<p>To that end, lets define a <code>length</code> function that
computes the natural number that is the size of a
list.</p>
<pre><span class=hs-linenum>81: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>length</span>               <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>82: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>length</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nat</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>83: </span><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                        &amp;&amp; v == length x1}</span><span class='hs-definition'>length</span></a> <span class='hs-conid'>N</span>        <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<span class=hs-linenum>84: </span><span class='hs-definition'>length</span> <span class='hs-layout'>(</span><span class='hs-conid'>C</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (1 : int)}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v == length xs
                     &amp;&amp; v == length xs}</span><span class='hs-varid'>length</span></a> <span class='hs-varid'>xs</span>
</pre>

<p>We lift <code>length</code> in the logic, as a <a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2014/02/11/the-advantage-of-measures.lhs/">measure</a>.</p>
<p>We can now tell Liquid Haskell that when proving termination
on recursive functions with a list argument <code>xs</code>, it should
check whether the <code>length xs</code> is decreasing.</p>
<pre><span class=hs-linenum>94: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>List</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>length</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>C</span> <span class='hs-layout'>{</span><span class='hs-varid'>hd</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>tl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>

<h2 id="reflecting-lists-into-the-logic">Reflecting Lists into the Logic<a class="headerlink" href="#reflecting-lists-into-the-logic" title="Permanent link">&para;</a></h2>
<p>To talk about lists in the logic, we use the annotation</p>
<pre><span class=hs-linenum>104: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--exact-data-cons"</span> <span class='hs-keyword'>@-}</span>
</pre>

<p>which <strong>automatically</strong> derives measures for</p>
<ul>
<li><em>testing</em> if a value has a given data constructor, and</li>
<li><em>extracting</em> the corresponding field's value.</li>
</ul>
<p>For our example, LH will automatically derive the following
functions in the refinement logic.</p>
<pre><span class=hs-linenum>116: </span><span class='hs-definition'>isN</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>         <span class='hs-comment'>-- Haskell's null</span>
<span class=hs-linenum>117: </span><span class='hs-definition'>isC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>         <span class='hs-comment'>-- Haskell's not . null</span>
<span class=hs-linenum>118: </span>
<span class=hs-linenum>119: </span><span class='hs-definition'>select_C_1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>     <span class='hs-comment'>-- Haskell's head</span>
<span class=hs-linenum>120: </span><span class='hs-definition'>select_C_2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span>   <span class='hs-comment'>-- Haskell's tail</span>
</pre>

<p>A programmer <em>never</em> sees the above operators; they are internally
used by LH to <strong>reflect</strong> Haskell functions into the refinement logic,
as we shall see shortly.</p>
<h2 id="defining-the-monoid-operators">Defining the Monoid Operators<a class="headerlink" href="#defining-the-monoid-operators" title="Permanent link">&para;</a></h2>
<p>A structure is a monoid, when it has two operators:</p>
<ul>
<li>the identity element <code>empty</code> and</li>
<li>an associative operator <code>&lt;&gt;</code>.</li>
</ul>
<p>Lets define these two operators for our <code>List</code>.</p>
<ul>
<li>the identity element is the empty list, and</li>
<li>the associative operator <code>&lt;&gt;</code> is list append.</li>
</ul>
<pre><span class=hs-linenum>141: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>empty</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>142: </span><span class='hs-definition'>empty</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>143: </span><a class=annot href="#"><span class=annottext>{VV : (StructuralInduction.List a) | VV == empty
                                     &amp;&amp; VV == StructuralInduction.N}</span><span class='hs-definition'>empty</span></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>N</span>
<span class=hs-linenum>144: </span>
<span class=hs-linenum>145: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>infix</span>   <span class='hs-varop'>&lt;&gt;</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>146: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>147: </span><span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>148: </span><span class='hs-conid'>N</span>        <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; {VV : (StructuralInduction.List a) | VV == &lt;&gt; x1 x2
                                                                                                           &amp;&amp; VV == (if is_N x1 then x2 else StructuralInduction.C (select_C_1 x1) (&lt;&gt; (select_C_2 x1) x2))}</span><span class='hs-varop'>&lt;&gt;</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>ys</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ys</span>
<span class=hs-linenum>149: </span><span class='hs-layout'>(</span><span class='hs-conid'>C</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : (StructuralInduction.List a) | VV == &lt;&gt; xs ys
                                     &amp;&amp; VV == (if is_N xs then ys else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) ys))
                                     &amp;&amp; VV == &lt;&gt; xs ys}</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
</pre>

<p>LiquidHaskell automatically checked that the recursive <code>(&lt;&gt;)</code>
is terminating, by checking that the <code>length</code> of its first
argument is decreasing. Since both the above operators are
provably terminating, LH lets us reflect them into logic.</p>
<p>As with our <a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2016/09/18/refinement-reflection.lhs/">previous</a>
<code>fibonacci</code> example, reflection of a function
into logic, means strengthening the result type
of the function with its implementation.</p>
<p>Thus, the <strong>automatically</strong> derived, strengthened
types for <code>empty</code> and <code>(&lt;&gt;)</code> will be</p>
<pre><span class=hs-linenum>166: </span><span class='hs-definition'>empty</span>   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-varid'>empty</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-conid'>N</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>167: </span>
<span class=hs-linenum>168: </span><span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ys</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>169: </span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-varid'>xs</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ys</span> <span class='hs-varop'>&amp;&amp;</span>
<span class=hs-linenum>170: </span>                    <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isN</span> <span class='hs-varid'>xs</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>ys</span> <span class='hs-keyword'>else</span>
<span class=hs-linenum>171: </span>                         <span class='hs-conid'>C</span> <span class='hs-layout'>(</span><span class='hs-varid'>select_C_1</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>select_C_2</span> <span class='hs-varid'>xs</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
<span class=hs-linenum>172: </span>        <span class='hs-layout'>}</span>
</pre>

<p>In effect, the derived checker and selector functions are used
to translate Haskell to logic. The above is just to <em>explain</em>
how LH reasons about the operators; the programmer never (directly)
reads or writes the operators <code>isN</code> or <code>select_C_1</code> etc.</p>
<h2 id="proving-the-monoid-laws">Proving the Monoid Laws<a class="headerlink" href="#proving-the-monoid-laws" title="Permanent link">&para;</a></h2>
<p>Finally, we have set everything up, (actually LiquidHaskell
did most of the work for us) and we are ready to prove the
monoid laws for the <code>List</code>.</p>
<p>First we prove left identity of <code>empty</code>.</p>
<pre><span class=hs-linenum>190: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>leftId</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ empty &lt;&gt; x == x }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>191: </span><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; empty x1 == x1}</span><span class='hs-definition'>leftId</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>192: </span>   <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>empty</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>x</span>
<span class=hs-linenum>193: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-conid'>N</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>x</span>
<span class=hs-linenum>194: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <span class='hs-varid'>x</span>
<span class=hs-linenum>195: </span>   <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>

<p>This proof was trivial, because left identity is satisfied
by the way we defined <code>(&lt;&gt;)</code>.</p>
<p>Next, we prove right identity of <code>empty</code>.</p>
<pre><span class=hs-linenum>204: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>rightId</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ x &lt;&gt; empty  == x }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>205: </span><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 empty == x1}</span><span class='hs-definition'>rightId</span></a> <span class='hs-conid'>N</span>
<span class=hs-linenum>206: </span>   <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List (GHC.Prim.Any *))</span><span class='hs-conid'>N</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>empty</span>
<span class=hs-linenum>207: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List (GHC.Prim.Any *)) -&gt; (StructuralInduction.List (GHC.Prim.Any *)) -&gt; (StructuralInduction.List (GHC.Prim.Any *))</span><span class='hs-varop'>==.</span></a> <span class='hs-conid'>N</span>
<span class=hs-linenum>208: </span>   <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>209: </span>
<span class=hs-linenum>210: </span><span class='hs-definition'>rightId</span> <span class='hs-layout'>(</span><span class='hs-conid'>C</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
<span class=hs-linenum>211: </span>   <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>empty</span>
<span class=hs-linenum>212: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>empty</span><span class='hs-layout'>)</span>
<span class=hs-linenum>213: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; () -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span>        <span class='hs-varid'></span> <a class=annot href="#"><span class=annottext>{VV : () | &lt;&gt; xs empty == xs}</span><span class='hs-varid'>rightId</span></a> <span class='hs-varid'>xs</span>
<span class=hs-linenum>214: </span>   <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>

<p>This proof is more tricky, as it requires <strong>structural induction</strong> which is
encoded in LH proofs simply as <strong>recursion</strong>.  LH ensures that the inductive
hypothesis is appropriately applied by checking that the recursive proof is
total and terminating.  In the <code>rightId</code> case, for termination, Liquid Haskell
checked that <code>length xs &lt; length (C x xs)</code>.</p>
<p>It turns out that we can prove lots of properties about lists using structural
induction, encoded in Haskell as</p>
<ul>
<li>case splitting,</li>
<li>recursive calls, and</li>
<li>rewriting,</li>
</ul>
<p>To see a last example, lets prove the associativity of <code>(&lt;&gt;)</code>.</p>
<pre><span class=hs-linenum>233: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>associativity</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>z</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>234: </span>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ x &lt;&gt; (y &lt;&gt; z) == (x &lt;&gt; y) &lt;&gt; z }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>235: </span><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; x3:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 (&lt;&gt; x2 x3) == &lt;&gt; (&lt;&gt; x1 x2) x3}</span><span class='hs-definition'>associativity</span></a> <span class='hs-conid'>N</span> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>y</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>z</span></a>
<span class=hs-linenum>236: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-conid'>N</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span><span class='hs-layout'>)</span>
<span class=hs-linenum>237: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>238: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-conid'>N</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>239: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>240: </span>
<span class=hs-linenum>241: </span><span class='hs-definition'>associativity</span> <span class='hs-layout'>(</span><span class='hs-conid'>C</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>y</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>242: </span>  <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span><span class='hs-layout'>)</span>
<span class=hs-linenum>243: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>244: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; () -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; xs y
                                    &amp;&amp; v == (if is_N xs then y else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) y))
                                    &amp;&amp; v == &lt;&gt; xs y}</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span><span class='hs-layout'>)</span> <span class='hs-varid'></span> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; x3:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 (&lt;&gt; x2 x3) == &lt;&gt; (&lt;&gt; x1 x2) x3}</span><span class='hs-varid'>associativity</span></a> <span class='hs-varid'>xs</span> <span class='hs-varid'>y</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>245: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; xs y
                                    &amp;&amp; v == (if is_N xs then y else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) y))
                                    &amp;&amp; v == &lt;&gt; xs y}</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>246: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>247: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>

<p>The above proof of associativity reifies the paper and pencil
proof by structural induction.</p>
<p>With that, we can safely conclude that our user defined list
is a monoid!</p>
<h2 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">&para;</a></h2>
<p>We saw how Refinement Reflection can be used to</p>
<ul>
<li>specify properties of <code>ADTs</code>,</li>
<li>naturally encode structural inductive proofs of these properties, and</li>
<li>have these proofs machine checked by Liquid Haskell.</li>
</ul>
<p>Why is this useful? Because the theorems we prove refer to your Haskell
functions!  Thus you (or in the future, the compiler) can use properties like
monoid or monad laws to optimize your Haskell code.  In the future, we will
present examples of code optimizations using monoid laws. Stay tuned!</p>







  
  






                


<div class="blogpost-meta">
  
  <div class="blogpost-meta-whowhen">
    
        <div class="blogpost-meta-author">
            Niki Vazou
        </div>
    
    
        <div class="blogpost-meta-date">
            2016-10-06
        </div>
    
  </div>
  
  
  <div class="blogpost-meta-tags">
              
      <a href="../../tags.html#reflection" class="tag-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5.5 7A1.5 1.5 0 0 1 4 5.5 1.5 1.5 0 0 1 5.5 4 1.5 1.5 0 0 1 7 5.5 1.5 1.5 0 0 1 5.5 7m15.91 4.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.11 0-2 .89-2 2v7c0 .55.22 1.05.59 1.41l8.99 9c.37.36.87.59 1.42.59s1.05-.23 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.56-.23-1.06-.59-1.42"/></svg>reflection</a>
              
      <a href="../../tags.html#induction" class="tag-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5.5 7A1.5 1.5 0 0 1 4 5.5 1.5 1.5 0 0 1 5.5 4 1.5 1.5 0 0 1 7 5.5 1.5 1.5 0 0 1 5.5 7m15.91 4.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.11 0-2 .89-2 2v7c0 .55.22 1.05.59 1.41l8.99 9c.37.36.87.59 1.42.59s1.05-.23 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.56-.23-1.06-.59-1.42"/></svg>induction</a>
              
      <a href="../../tags.html#measures" class="tag-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5.5 7A1.5 1.5 0 0 1 4 5.5 1.5 1.5 0 0 1 5.5 4 1.5 1.5 0 0 1 7 5.5 1.5 1.5 0 0 1 5.5 7m15.91 4.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.11 0-2 .89-2 2v7c0 .55.22 1.05.59 1.41l8.99 9c.37.36.87.59 1.42.59s1.05-.23 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.56-.23-1.06-.59-1.42"/></svg>measures</a>
    
  </div>
  
</div>



              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
    <a href="https://join.slack.com/t/liquidhaskell/shared_invite/enQtMjY4MTk3NDkwODE3LTFmZGFkNGEzYWRkNDJmZDQ0ZGU1MzBiZWZiZDhhNmY3YTJiMjUzYTRlNjMyZDk1NDU3ZGIxYzhlOTIzN2UxNWE" target="_blank" rel="noopener" title="Join the LiquidHaskell slack channel" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 15a2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2h2zm1 0a2 2 0 0 1 2-2 2 2 0 0 1 2 2v5a2 2 0 0 1-2 2 2 2 0 0 1-2-2zm2-8a2 2 0 0 1-2-2 2 2 0 0 1 2-2 2 2 0 0 1 2 2v2zm0 1a2 2 0 0 1 2 2 2 2 0 0 1-2 2H4a2 2 0 0 1-2-2 2 2 0 0 1 2-2zm8 2a2 2 0 0 1 2-2 2 2 0 0 1 2 2 2 2 0 0 1-2 2h-2zm-1 0a2 2 0 0 1-2 2 2 2 0 0 1-2-2V5a2 2 0 0 1 2-2 2 2 0 0 1 2 2zm-2 8a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2v-2zm0-1a2 2 0 0 1-2-2 2 2 0 0 1 2-2h5a2 2 0 0 1 2 2 2 2 0 0 1-2 2z"/></svg>
    </a>
  
    
    
    
    
    <a href="https://groups.google.com/forum/#!forum/liquidhaskell" target="_blank" rel="noopener" title="Mail the LiquidHaskell users mailing list" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21.35 11.1h-9.17v2.73h6.51c-.33 3.81-3.5 5.44-6.5 5.44C8.36 19.27 5 16.25 5 12c0-4.1 3.2-7.27 7.2-7.27 3.09 0 4.9 1.97 4.9 1.97L19 4.72S16.56 2 12.1 2C6.42 2 2.03 6.8 2.03 12c0 5.05 4.13 10 10.22 10 5.35 0 9.25-3.67 9.25-9.09 0-1.15-.15-1.81-.15-1.81"/></svg>
    </a>
  
    
    
    
    
    <a href="https://github.com/ranjitjhala" target="_blank" rel="noopener" title="Drop Ranjit Jhala an email" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M498.1 5.6c10.1 7 15.4 19.1 13.5 31.2l-64 416c-1.5 9.7-7.4 18.2-16 23s-18.9 5.4-28 1.6L284 427.7l-68.5 74.1c-8.9 9.7-22.9 12.9-35.2 8.1S160 493.2 160 480v-83.6c0-4 1.5-7.8 4.2-10.8l167.6-182.8c5.8-6.3 5.6-16-.4-22s-15.7-6.4-22-.7L106 360.8l-88.3-44.2C7.1 311.3.3 300.7 0 288.9s5.9-22.8 16.1-28.7l448-256c10.7-6.1 23.9-5.5 34 1.4"/></svg>
    </a>
  
    
    
    
    
    <a href="https://github.com/nikivazou" target="_blank" rel="noopener" title="Drop Niki Vazou an email" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M16.1 260.2c-22.6 12.9-20.5 47.3 3.6 57.3L160 376v103.3c0 18.1 14.6 32.7 32.7 32.7 9.7 0 18.9-4.3 25.1-11.8l62-74.3 123.9 51.6c18.9 7.9 40.8-4.5 43.9-24.7l64-416c1.9-12.1-3.4-24.3-13.5-31.2s-23.3-7.5-34-1.4zm52.1 25.5L409.7 90.6 190.1 336l1.2 1zm335.1 139.7-166.6-69.5 214.1-239.3z"/></svg>
    </a>
  
    
    
    
    
    <a href="https://github.com/ucsd-progsys/liquidhaskell/issues" target="_blank" rel="noopener" title="Open a GitHub issue" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34-.46-1.16-1.11-1.47-1.11-1.47-.91-.62.07-.6.07-.6 1 .07 1.53 1.03 1.53 1.03.87 1.52 2.34 1.07 2.91.83.09-.65.35-1.09.63-1.34-2.22-.25-4.55-1.11-4.55-4.92 0-1.11.38-2 1.03-2.71-.1-.25-.45-1.29.1-2.64 0 0 .84-.27 2.75 1.02.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02.55 1.35.2 2.39.1 2.64.65.71 1.03 1.6 1.03 2.71 0 3.82-2.34 4.66-4.57 4.91.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.top"], "search": "../../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.83f73b43.min.js"></script>
      
    
  </body>
</html>