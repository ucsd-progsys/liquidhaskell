

<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="Niki Vazou">
      
      
        <link rel="canonical" href="https://ucsd-progsys.github.io/liquidhaskell/blogposts/2016-09-18-refinement-reflection.lhs/">
      
      
        <link rel="prev" href="../2016-10-06-structural-induction.lhs/">
      
      
        <link rel="next" href="../2016-09-01-normal-forms.lhs/">
      
      
      <link rel="icon" href="../../static/img/favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.42">
    
    
      
        <title>Haskell as a Theorem Prover - LiquidHaskell Docs</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.0253249f.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@5.9.55/css/materialdesignicons.min.css">
    
      <link rel="stylesheet" href="../../static/liquid-light.css">
    
      <link rel="stylesheet" href="../../static/misc.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="cyan" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#shallow-vs-deep-specifications" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="LiquidHaskell Docs" class="md-header__button md-logo" aria-label="LiquidHaskell Docs" data-md-component="logo">
      
  <img src="../../static/img/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            LiquidHaskell Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Haskell as a Theorem Prover
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/ucsd-progsys/liquidhaskell" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="https://liquidhaskell.goto.ucsd.edu/index.html" class="md-tabs__link">
        
  
    
  
  <div id='demo'><i aria-hidden=true class='mdi mdi-cloud-braces'></i> Try Online</div>

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-human-greeting'></i> Tutorial

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
    
  
  

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../install/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-download'></i> Installation

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../specifications/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-script'></i> Spec Reference

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../options/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-flag'></i> Flag Reference

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
    
  
  

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../papers/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-school'></i> Papers

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../2020-08-20-lh-as-a-ghc-plugin.lhs/" class="md-tabs__link">
          
  
  <i aria-hidden=true class='mdi mdi-bullhorn'></i> Blog

        </a>
      </li>
    
  

    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="LiquidHaskell Docs" class="md-nav__button md-logo" aria-label="LiquidHaskell Docs" data-md-component="logo">
      
  <img src="../../static/img/logo.png" alt="logo">

    </a>
    LiquidHaskell Docs
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/ucsd-progsys/liquidhaskell" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="https://liquidhaskell.goto.ucsd.edu/index.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <div id='demo'><i aria-hidden=true class='mdi mdi-cloud-braces'></i> Try Online</div>
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-human-greeting'></i> Tutorial
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../install/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-download'></i> Installation
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../specifications/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-script'></i> Spec Reference
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../options/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-flag'></i> Flag Reference
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../papers/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-school'></i> Papers
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="">
            
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-bullhorn'></i> Blog
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            <i aria-hidden=true class='mdi mdi-bullhorn'></i> Blog
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_1" checked>
        
          
          <label class="md-nav__link" for="__nav_9_1" id="__nav_9_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Blogposts
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_1_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9_1">
            <span class="md-nav__icon md-icon"></span>
            Blogposts
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2020-08-20-lh-as-a-ghc-plugin.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LiquidHaskell is a GHC Plugin
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2020-04-12-polymorphic-perplexion.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Polymorphic Perplexion
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2019-10-20-why-types.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Liquid Types vs. Floyd-Hoare Logic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2018-05-17-hillel-verifier-rodeo-I-leftpad.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    The Hillelogram Verifier Rodeo I (LeftPad)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2018-02-23-measures-and-case-splitting.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Measures and Case Splitting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2017-12-24-splitting-and-splicing-intervals-II.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Splitting and Splicing Intervals (Part 2)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2017-12-15-splitting-and-splicing-intervals-I.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Splitting and Splicing Intervals (Part 1)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2017-03-20-arithmetic-overflows.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Arithmetic Overflows
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2016-10-06-structural-induction.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Refinement Reflection on ADTs
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Haskell as a Theorem Prover
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Haskell as a Theorem Prover
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#shallow-vs-deep-specifications" class="md-nav__link">
    <span class="md-ellipsis">
      Shallow vs. Deep Specifications
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#propositions" class="md-nav__link">
    <span class="md-ellipsis">
      Propositions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trivial-proofs" class="md-nav__link">
    <span class="md-ellipsis">
      Trivial Proofs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#refinement-reflection" class="md-nav__link">
    <span class="md-ellipsis">
      Refinement Reflection
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#step-1-definition" class="md-nav__link">
    <span class="md-ellipsis">
      Step 1: Definition
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#step-2-reflection" class="md-nav__link">
    <span class="md-ellipsis">
      Step 2: Reflection
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#step-3-application" class="md-nav__link">
    <span class="md-ellipsis">
      Step 3: Application
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#structuring-proofs" class="md-nav__link">
    <span class="md-ellipsis">
      Structuring Proofs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#because-operator" class="md-nav__link">
    <span class="md-ellipsis">
      Because operator
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#proofs-by-induction-ie-recursion" class="md-nav__link">
    <span class="md-ellipsis">
      Proofs by Induction (i.e. Recursion)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#higher-order-theorems" class="md-nav__link">
    <span class="md-ellipsis">
      Higher Order Theorems
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    <span class="md-ellipsis">
      Conclusion
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2016-09-01-normal-forms.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Normal Forms
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2015-01-30-okasakis-lazy-queue.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Okasaki's Lazy Queues
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2014-08-15-a-finer-filter.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A Finer Filter
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2014-05-28-pointers-gone-wild.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Pointers Gone Wild
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2014-02-11-the-advantage-of-measures.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    The Advantage of Measures
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-12-14-gcd.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Termination Requires Refinements
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-12-09-checking-termination.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Checking Termination
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-12-02-getting-to-the-bottom.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Getting To the Bottom
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-11-23-telling_lies.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LiquidHaskell Caught Telling Lies!
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-10-10-csv-tables.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CSV Tables
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-07-29-putting-things-in-order.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Putting Things In Order
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-06-03-abstracting-over-refinements.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Abstracting Over Refinements
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-05-24-unique-zipper.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Unique Zippers
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-03-26-talking-about-sets.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Talking About Sets
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-03-04-bounding-vectors.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Bounding Vectors
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-02-17-kmeans-clustering-II.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    KMeans Clustering II
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-02-16-kmeans-clustering-I.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    KMeans Clustering I
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-01-31-safely-catching-a-list-by-its-tail.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Safely Catching A List By Its Tail
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-01-28-bounding-vectors.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Bounding Vectors
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-01-27-refinements101-reax.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Refinements 101 (contd.)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-01-01-refinement-types-101.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Refinement Types 101
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tags.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tags
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#shallow-vs-deep-specifications" class="md-nav__link">
    <span class="md-ellipsis">
      Shallow vs. Deep Specifications
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#propositions" class="md-nav__link">
    <span class="md-ellipsis">
      Propositions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trivial-proofs" class="md-nav__link">
    <span class="md-ellipsis">
      Trivial Proofs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#refinement-reflection" class="md-nav__link">
    <span class="md-ellipsis">
      Refinement Reflection
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#step-1-definition" class="md-nav__link">
    <span class="md-ellipsis">
      Step 1: Definition
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#step-2-reflection" class="md-nav__link">
    <span class="md-ellipsis">
      Step 2: Reflection
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#step-3-application" class="md-nav__link">
    <span class="md-ellipsis">
      Step 3: Application
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#structuring-proofs" class="md-nav__link">
    <span class="md-ellipsis">
      Structuring Proofs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#because-operator" class="md-nav__link">
    <span class="md-ellipsis">
      Because operator
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#proofs-by-induction-ie-recursion" class="md-nav__link">
    <span class="md-ellipsis">
      Proofs by Induction (i.e. Recursion)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#higher-order-theorems" class="md-nav__link">
    <span class="md-ellipsis">
      Higher Order Theorems
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    <span class="md-ellipsis">
      Conclusion
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                


                  
  
<nav class="md-tags" >
  
    
    
    
      <span class="md-tag">reflection</span>
    
  
</nav>


  
  


  <h1>Haskell as a Theorem Prover</h1>

<p>We've taught LiquidHaskell a new trick that we call ``Refinement Reflection''
which lets us turn Haskell into a theorem prover capable of proving arbitrary
properties of code. The key idea is to <strong>reflect</strong> the code of the function into
its <strong>output type</strong>, which lets us then reason about the function at the
(refinement) type level. Lets see how to use refinement types to express a
theorem, for example that fibonacci is a monotonically increasing function, 
then write plain Haskell code to reify a paper-and-pencil-style proof 
for that theorem, that can be machine checked by LiquidHaskell.</p>
<!-- more -->

<p><br>
<br>
<br></p>
<div class="row-fluid">
  <div class="span12 pagination-centered">
  <img src="https://eyesofodysseus.files.wordpress.com/2013/06/full-moon-over-ocean-reflection.jpg"
       alt="Reflection" width="300">
  </div>
</div>

<div class="hidden">

<pre><span class=hs-linenum>38: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--higherorder"</span>     <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>39: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--totality"</span>        <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>40: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>RefinementReflection</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>41: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Language</span><span class='hs-varop'>.</span><span class='hs-conid'>Haskell</span><span class='hs-varop'>.</span><span class='hs-conid'>Liquid</span><span class='hs-varop'>.</span><span class='hs-conid'>ProofCombinators</span>
<span class=hs-linenum>42: </span>
<span class=hs-linenum>43: </span><span class='hs-definition'>fib</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>44: </span><span class='hs-definition'>propPlusComm</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>45: </span><span class='hs-definition'>propOnePlueOne</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>46: </span><span class='hs-definition'>fibTwo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>47: </span><span class='hs-definition'>fibCongruence</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
<span class=hs-linenum>48: </span><span class='hs-definition'>fibUp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>49: </span><span class='hs-definition'>fibTwoPretty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>50: </span><span class='hs-definition'>fibThree</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>51: </span><span class='hs-definition'>fMono</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<span class=hs-linenum>52: </span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span><span class='hs-layout'>)</span>
<span class=hs-linenum>53: </span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>54: </span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> 
<span class=hs-linenum>55: </span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>56: </span><span class='hs-definition'>fibMono</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>57: </span>
</pre>
</div>

<h2 id="shallow-vs-deep-specifications">Shallow vs. Deep Specifications<a class="headerlink" href="#shallow-vs-deep-specifications" title="Permanent link">&para;</a></h2>
<p>Up to now, we have been using Liquid Haskell to specify and verify "shallow"
specifications that abstractly describe the behavior of functions.  For example,
below, we specify and verify that <code>fib</code>restricted to natural numbers, always
terminates returning a natural number.</p>
<pre><span class=hs-linenum>70: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fib</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nat</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>71: </span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-definition'>fib</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>i</span></a> <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>0</span>    <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> 
<span class=hs-linenum>72: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>1</span>    <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> 
<span class=hs-linenum>73: </span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>2</span><span class='hs-layout'>)</span>
</pre>

<p>In this post we present how refinement reflection is used to verify 
"deep" specifications that use the exact definition of Haskell functions. 
For example, we will prove that the Haskell <code>fib</code> function is increasing.</p>
<h2 id="propositions">Propositions<a class="headerlink" href="#propositions" title="Permanent link">&para;</a></h2>
<p>To begin with, we import <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/Language/Haskell/Liquid/ProofCombinators.hs">ProofCombinators</a>, a (Liquid) Haskell 
library that defines and manipulates logical proofs. </p>
<pre><span class=hs-linenum>89: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Language</span><span class='hs-varop'>.</span><span class='hs-conid'>Haskell</span><span class='hs-varop'>.</span><span class='hs-conid'>Liquid</span><span class='hs-varop'>.</span><span class='hs-conid'>ProofCombinators</span>
</pre>

<p>A <code>Proof</code> is a data type that carries no run time information</p>
<pre><span class=hs-linenum>95: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Proof</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
</pre>

<p>but can be refined with desired logical propositions.
For example, the following type states that <code>1 + 1 == 2</code></p>
<pre><span class=hs-linenum>102: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>OnePlusOne</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span> <span class='hs-conid'>Proof</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span> <span class='hs-varop'>==</span> <span class='hs-num'>2</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>

<p>Since the <code>v</code> and <code>Proof</code> are irrelevant, we may as well abbreviate 
the above to </p>
<pre><span class=hs-linenum>109: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>OnePlusOne'</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span> <span class='hs-varop'>==</span> <span class='hs-num'>2</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>

<p>As another example, the following function type declares 
that <em>for each</em> <code>x</code> and <code>y</code> the plus operator commutes. </p>
<pre><span class=hs-linenum>117: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>PlusComm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>x</span> <span class='hs-varop'>+</span> <span class='hs-varid'>y</span> <span class='hs-varop'>==</span> <span class='hs-varid'>y</span> <span class='hs-varop'>+</span> <span class='hs-varid'>x</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span> 
</pre>

<h2 id="trivial-proofs">Trivial Proofs<a class="headerlink" href="#trivial-proofs" title="Permanent link">&para;</a></h2>
<p>We prove the above theorems using Haskell programs. 
The <code>ProofCombinators</code> module defines the <code>trivial</code> proof</p>
<pre><span class=hs-linenum>129: </span><span class='hs-definition'>trivial</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>130: </span><span class='hs-definition'>trivial</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
</pre>

<p>and the "casting" operator <code>(***)</code> that makes proof terms look 
nice:</p>
<pre><span class=hs-linenum>137: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>QED</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>138: </span>
<span class=hs-linenum>139: </span><span class='hs-layout'>(</span><span class='hs-varop'>***</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>QED</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
<span class=hs-linenum>140: </span><span class='hs-keyword'>_</span> <span class='hs-varop'>***</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
</pre>

<p>Using the underlying SMT's knowledge on linear arithmetic, 
we can trivially prove the above propositions.</p>
<pre><span class=hs-linenum>147: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>propOnePlueOne</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OnePlusOne</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>148: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | 1 + 1 == 2}</span><span class='hs-definition'>propOnePlueOne</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}</span><span class='hs-varid'>trivial</span></a> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span> 
<span class=hs-linenum>149: </span>
<span class=hs-linenum>150: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>propPlusComm</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PlusComm</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>151: </span><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {VV : () | x1 + x2 == x2 + x1}</span><span class='hs-definition'>propPlusComm</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}</span><span class='hs-varid'>trivial</span></a> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span> 
</pre>

<p>We saw how we use SMT's knowledge on linear arithmetic 
to trivially prove arithmetic properties. But how can 
we prove ``deep'' properties on Haskell's functions?</p>
<h2 id="refinement-reflection">Refinement Reflection<a class="headerlink" href="#refinement-reflection" title="Permanent link">&para;</a></h2>
<p>Refinement Reflection allows deep specification and 
verification by reflecting the code implementing a Haskell
function into the function’s output refinement type.</p>
<p>Refinement Reflection proceeds in 3 steps: definition, reflection, and application.
Consider reflecting the definition of <code>fib</code> into the logic</p>
<pre><span class=hs-linenum>171: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>fib</span> <span class='hs-keyword'>@-}</span>
</pre>

<p>then the following three reflection steps will occur. </p>
<h2 id="step-1-definition">Step 1: Definition<a class="headerlink" href="#step-1-definition" title="Permanent link">&para;</a></h2>
<p>Reflection of the Haskell function <code>fib</code> defines in logic 
an <em>uninterpreted</em> function <code>fib</code> that satisfies the congruence axiom.</p>
<p>In the logic the function <code>fib</code> is defined.</p>
<pre><span class=hs-linenum>185: </span><span class='hs-definition'>fib</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> 
</pre>

<p>SMT only knows that <code>fib</code> satisfies the congruence axiom.</p>
<pre><span class=hs-linenum>191: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibCongruence</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{i == j =&gt; fib i == fib j}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>192: </span><a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 == x2 =&gt; fib x1 == fib x2}</span><span class='hs-definition'>fibCongruence</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}</span><span class='hs-varid'>trivial</span></a> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span> 
</pre>

<p>Other than congruence, SMT knowns nothing for the function <code>fib</code>,
until reflection happens!</p>
<h2 id="step-2-reflection">Step 2: Reflection<a class="headerlink" href="#step-2-reflection" title="Permanent link">&para;</a></h2>
<p>As a second step, Liquid Haskell connects the Haskell function <code>fib</code>
with the homonymous logical function, 
by reflecting the implementation of <code>fib</code> in its result type. </p>
<p>The result type of <code>fib</code> is automatically strengthened to the following.</p>
<pre><span class=hs-linenum>210: </span><span class='hs-definition'>fib</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-varid'>fib</span> <span class='hs-varid'>i</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fibP</span> <span class='hs-varid'>i</span> <span class='hs-layout'>}</span>
</pre>

<p>That is, the result satisfies the <code>fibP</code> predicate
exactly reflecting the implementation of <code>fib</code>.</p>
<pre><span class=hs-linenum>217: </span><span class='hs-definition'>fibP</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>i</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span> <span class='hs-keyword'>then</span> <span class='hs-num'>0</span> <span class='hs-keyword'>else</span>
<span class=hs-linenum>218: </span>         <span class='hs-keyword'>if</span> <span class='hs-varid'>i</span> <span class='hs-varop'>==</span> <span class='hs-num'>1</span> <span class='hs-keyword'>then</span> <span class='hs-num'>1</span> <span class='hs-keyword'>else</span>
<span class=hs-linenum>219: </span>         <span class='hs-varid'>fin</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varop'>+</span> <span class='hs-varid'>fib</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-comment'>-</span><span class='hs-num'>2</span><span class='hs-layout'>)</span>
</pre>

<h2 id="step-3-application">Step 3: Application<a class="headerlink" href="#step-3-application" title="Permanent link">&para;</a></h2>
<p>With the reflected refinement type,
each application of <code>fib</code> automatically unfolds the definition of <code>fib</code> 
once. 
As an example, applying <code>fib</code> to <code>0</code>, <code>1</code>, and <code>2</code> allows us to prove that <code>fib 2 == 1</code>:</p>
<pre><span class=hs-linenum>231: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibTwo</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ fib 2 == 1 }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>232: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | fib 2 == 1}</span><span class='hs-definition'>fibTwo</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | null v &lt;=&gt; false}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>0</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>2</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>

<p>Though valid, the above <code>fibTwo</code> proof is not pretty! </p>
<h2 id="structuring-proofs">Structuring Proofs<a class="headerlink" href="#structuring-proofs" title="Permanent link">&para;</a></h2>
<p>To make our proofs look nice, we use combinators from 
the <code>ProofCombinators</code> library, which exports a family 
of operators <code>(*.)</code> where <code>*</code> comes from the theory of 
linear arithmetic and the refinement type of <code>x *. y</code> </p>
<ul>
<li><strong>requires</strong> that <code>x *. y</code> holds and </li>
<li><strong>ensures</strong> that the returned value is equal to <code>x</code>.</li>
</ul>
<p>For example, <code>(==.)</code> and <code>(&lt;=.)</code> are predefined in <code>ProofCombinators</code> as</p>
<pre><span class=hs-linenum>252: </span><span class='hs-layout'>(</span><span class='hs-varop'>==.</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-layout'>{</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span><span class='hs-varop'>==</span><span class='hs-varid'>y</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span><span class='hs-varop'>==</span><span class='hs-varid'>x</span><span class='hs-layout'>}</span>
<span class=hs-linenum>253: </span><span class='hs-definition'>x</span> <span class='hs-varop'>==.</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
<span class=hs-linenum>254: </span>
<span class=hs-linenum>255: </span><span class='hs-layout'>(</span><span class='hs-varop'>&lt;=.</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-layout'>{</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span><span class='hs-varop'>&lt;=</span><span class='hs-varid'>y</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span><span class='hs-varop'>==</span><span class='hs-varid'>x</span><span class='hs-layout'>}</span>
<span class=hs-linenum>256: </span><span class='hs-definition'>x</span> <span class='hs-varop'>&lt;=.</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
</pre>

<p>Using these predefined operators, we construct paper and pencil-like proofs 
for the <code>fib</code> function.</p>
<pre><span class=hs-linenum>263: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibTwoPretty</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{ fib 2 == 1 }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>264: </span><a class=annot href="#"><span class=annottext>{VV : () | fib 2 == 1}</span><span class='hs-definition'>fibTwoPretty</span></a> 
<span class=hs-linenum>265: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>2</span> 
<span class=hs-linenum>266: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>0</span> 
<span class=hs-linenum>267: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>

<h2 id="because-operator">Because operator<a class="headerlink" href="#because-operator" title="Permanent link">&para;</a></h2>
<p>To allow the reuse of existing proofs, <code>ProofCombinators</code> defines the because 
operator <code>(∵)</code></p>
<pre><span class=hs-linenum>279: </span><span class='hs-layout'>(</span><span class='hs-varid'>∵</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Proof</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>280: </span><span class='hs-definition'>f</span> <span class='hs-varid'>∵</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>y</span>
</pre>

<p>For example, <code>fib 3 == 2</code> holds because <code>fib 2 == 1</code>:</p>
<pre><span class=hs-linenum>286: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibThree</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ fib 3 == 2 }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>287: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | fib 3 == 2}</span><span class='hs-definition'>fibThree</span></a> <span class='hs-keyword'>_</span> 
<span class=hs-linenum>288: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>3</span> 
<span class=hs-linenum>289: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>2</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span>
<span class=hs-linenum>290: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a>     <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span>      <span class='hs-varid'>∵</span> <span class='hs-varid'>fibTwoPretty</span>
<span class=hs-linenum>291: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <span class='hs-num'>2</span> 
<span class=hs-linenum>292: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>

<h2 id="proofs-by-induction-ie-recursion">Proofs by Induction (i.e. Recursion)<a class="headerlink" href="#proofs-by-induction-ie-recursion" title="Permanent link">&para;</a></h2>
<p>Next, combining the above operators we specify and prove that 
<code>fib</code> is increasing, that is for each natural number <code>i</code>, 
<code>fib i &lt;= fib (i+1)</code>. </p>
<p>We specify the theorem as a refinement type for <code>fubUp</code>
and use Haskell code to persuade Liquid Haskell that 
the theorem holds. </p>
<pre><span class=hs-linenum>309: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibUp</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{fib i &lt;= fib (i+1)}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>310: </span><a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}</span><span class='hs-definition'>fibUp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>i</span></a>
<span class=hs-linenum>311: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>0</span>
<span class=hs-linenum>312: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>0</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span>
<span class=hs-linenum>313: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>314: </span>
<span class=hs-linenum>315: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>1</span>
<span class=hs-linenum>316: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>0</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>2</span>
<span class=hs-linenum>317: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>318: </span>
<span class=hs-linenum>319: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<span class=hs-linenum>320: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-varid'>i</span>
<span class=hs-linenum>321: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>322: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-varid'>i</span>     <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>2</span><span class='hs-layout'>)</span> <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}</span><span class='hs-varid'>fibUp</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>323: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-varid'>i</span>     <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}</span><span class='hs-varid'>fibUp</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>324: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>325: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>

<p>The proof proceeds <em>by induction on</em> <code>i</code>. </p>
<ul>
<li>
<p>The base cases <code>i == 0</code> and <code>i == 1</code> are represented 
  as Haskell's case splitting. </p>
</li>
<li>
<p>The inductive hypothesis is represented by recursive calls 
  on smaller inputs. </p>
</li>
</ul>
<p>Finally, the SMT solves arithmetic reasoning to conclude the proof.  </p>
<h2 id="higher-order-theorems">Higher Order Theorems<a class="headerlink" href="#higher-order-theorems" title="Permanent link">&para;</a></h2>
<p>Refinement Reflection can be used to express and verify higher order theorems!
For example, <code>fMono</code> specifies that each locally increasing function is monotonic! </p>
<pre><span class=hs-linenum>345: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fMono</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<span class=hs-linenum>346: </span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>fUp</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-varid'>z</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{f z &lt;= f (z+1)}</span><span class='hs-layout'>)</span>
<span class=hs-linenum>347: </span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span>
<span class=hs-linenum>348: </span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Nat|x &lt; y}</span>
<span class=hs-linenum>349: </span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{f x &lt;= f y}</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span> 
<span class=hs-linenum>350: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>351: </span><a class=annot href="#"><span class=annottext>x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0
                                                                                                                                                                                          &amp;&amp; x5 &lt; v} -&gt; {VV : () | x1 x5 &lt;= x1 x6}</span><span class='hs-definition'>fMono</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | f x1 &lt;= f (x1 + 1)}</span><span class='hs-varid'>thm</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; x &lt; v}</span><span class='hs-varid'>y</span></a>  
<span class=hs-linenum>352: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-varid'>y</span>
<span class=hs-linenum>353: </span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-varid'>y</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>354: </span>         <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&gt;.</span></a> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-varid'>x</span>       <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}</span><span class='hs-varid'>thm</span></a> <span class='hs-varid'>x</span>
<span class=hs-linenum>355: </span>        <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>356: </span>
<span class=hs-linenum>357: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>y</span>
<span class=hs-linenum>358: </span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-varid'>x</span>
<span class=hs-linenum>359: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;.</span></a>  <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>         <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0
                                                                                                                                                                                          &amp;&amp; x5 &lt; v} -&gt; {VV : () | x1 x5 &lt;= x1 x6}</span><span class='hs-varid'>fMono</span></a> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}</span><span class='hs-varid'>thm</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>360: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;.</span></a>  <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-varid'>y</span>             <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}</span><span class='hs-varid'>thm</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>361: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>

<p>Again, the recursive implementation of <code>fMono</code> depicts the paper and pencil 
proof of <code>fMono</code> by induction on the decreasing argument <code>/ [y]</code>. </p>
<p>Since <code>fib</code> is proven to be locally increasing by <code>fUp</code>, we use <code>fMono</code> 
to prove that <code>fib</code> is monotonic. </p>
<pre><span class=hs-linenum>371: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibMono</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Nat | n &lt; m }</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{fib n &lt;= fib m}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>372: </span><a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:{v : GHC.Types.Int | v &gt;= 0
                                                           &amp;&amp; x1 &lt; v} -&gt; {VV : () | fib x1 &lt;= fib x2}</span><span class='hs-definition'>fibMono</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0
                                                                                                                                                                                              &amp;&amp; x5 &lt; v} -&gt; {v : () | x1 x5 &lt;= x1 x6} | v == RefinementReflection.fMono}</span><span class='hs-varid'>fMono</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | fib x1 &lt;= fib (x1 + 1)} | v == RefinementReflection.fibUp}</span><span class='hs-varid'>fibUp</span></a>
</pre>

<h2 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">&para;</a></h2>
<p>We saw how refinement reflection turns Haskell
into a theorem prover by reflecting the code 
implementing a Haskell function into the 
function’s output refinement type.</p>
<p>Refinement Types are used to express theorems, 
Haskell code is used to prove such theorems
expressing paper pencil proofs, and Liquid Haskell 
verifies the validity of the proofs!</p>
<p>Proving <code>fib</code> monotonic is great, but this is Haskell!
Wouldn’t it be nice to prove theorems about inductive data types 
and higher order functions? Like fusions and folds? 
Or program equivalence on run-time optimizations like map-reduce?</p>
<p>Stay tuned!</p>
<p>Even better, if you happen you be in Nara for ICFP'16, 
come to my <a href="http://cufp.org/2016/t6-niki-vazou-liquid-haskell-intro.html">CUFP tutorial</a> for more!</p>







  
  






                


<div class="blogpost-meta">
  
  <div class="blogpost-meta-whowhen">
    
        <div class="blogpost-meta-author">
            Niki Vazou
        </div>
    
    
        <div class="blogpost-meta-date">
            2016-09-18
        </div>
    
  </div>
  
  
  <div class="blogpost-meta-tags">
              
      <a href="../../tags.html#reflection" class="tag-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5.5 7A1.5 1.5 0 0 1 4 5.5 1.5 1.5 0 0 1 5.5 4 1.5 1.5 0 0 1 7 5.5 1.5 1.5 0 0 1 5.5 7m15.91 4.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.11 0-2 .89-2 2v7c0 .55.22 1.05.59 1.41l8.99 9c.37.36.87.59 1.42.59s1.05-.23 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.56-.23-1.06-.59-1.42"/></svg>reflection</a>
    
  </div>
  
</div>



              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
    <a href="https://join.slack.com/t/liquidhaskell/shared_invite/enQtMjY4MTk3NDkwODE3LTFmZGFkNGEzYWRkNDJmZDQ0ZGU1MzBiZWZiZDhhNmY3YTJiMjUzYTRlNjMyZDk1NDU3ZGIxYzhlOTIzN2UxNWE" target="_blank" rel="noopener" title="Join the LiquidHaskell slack channel" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 15a2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2h2zm1 0a2 2 0 0 1 2-2 2 2 0 0 1 2 2v5a2 2 0 0 1-2 2 2 2 0 0 1-2-2zm2-8a2 2 0 0 1-2-2 2 2 0 0 1 2-2 2 2 0 0 1 2 2v2zm0 1a2 2 0 0 1 2 2 2 2 0 0 1-2 2H4a2 2 0 0 1-2-2 2 2 0 0 1 2-2zm8 2a2 2 0 0 1 2-2 2 2 0 0 1 2 2 2 2 0 0 1-2 2h-2zm-1 0a2 2 0 0 1-2 2 2 2 0 0 1-2-2V5a2 2 0 0 1 2-2 2 2 0 0 1 2 2zm-2 8a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2v-2zm0-1a2 2 0 0 1-2-2 2 2 0 0 1 2-2h5a2 2 0 0 1 2 2 2 2 0 0 1-2 2z"/></svg>
    </a>
  
    
    
    
    
    <a href="https://groups.google.com/forum/#!forum/liquidhaskell" target="_blank" rel="noopener" title="Mail the LiquidHaskell users mailing list" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21.35 11.1h-9.17v2.73h6.51c-.33 3.81-3.5 5.44-6.5 5.44C8.36 19.27 5 16.25 5 12c0-4.1 3.2-7.27 7.2-7.27 3.09 0 4.9 1.97 4.9 1.97L19 4.72S16.56 2 12.1 2C6.42 2 2.03 6.8 2.03 12c0 5.05 4.13 10 10.22 10 5.35 0 9.25-3.67 9.25-9.09 0-1.15-.15-1.81-.15-1.81"/></svg>
    </a>
  
    
    
    
    
    <a href="https://github.com/ranjitjhala" target="_blank" rel="noopener" title="Drop Ranjit Jhala an email" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M498.1 5.6c10.1 7 15.4 19.1 13.5 31.2l-64 416c-1.5 9.7-7.4 18.2-16 23s-18.9 5.4-28 1.6L284 427.7l-68.5 74.1c-8.9 9.7-22.9 12.9-35.2 8.1S160 493.2 160 480v-83.6c0-4 1.5-7.8 4.2-10.8l167.6-182.8c5.8-6.3 5.6-16-.4-22s-15.7-6.4-22-.7L106 360.8l-88.3-44.2C7.1 311.3.3 300.7 0 288.9s5.9-22.8 16.1-28.7l448-256c10.7-6.1 23.9-5.5 34 1.4"/></svg>
    </a>
  
    
    
    
    
    <a href="https://github.com/nikivazou" target="_blank" rel="noopener" title="Drop Niki Vazou an email" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M16.1 260.2c-22.6 12.9-20.5 47.3 3.6 57.3L160 376v103.3c0 18.1 14.6 32.7 32.7 32.7 9.7 0 18.9-4.3 25.1-11.8l62-74.3 123.9 51.6c18.9 7.9 40.8-4.5 43.9-24.7l64-416c1.9-12.1-3.4-24.3-13.5-31.2s-23.3-7.5-34-1.4zm52.1 25.5L409.7 90.6 190.1 336l1.2 1zm335.1 139.7-166.6-69.5 214.1-239.3z"/></svg>
    </a>
  
    
    
    
    
    <a href="https://github.com/ucsd-progsys/liquidhaskell/issues" target="_blank" rel="noopener" title="Open a GitHub issue" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34-.46-1.16-1.11-1.47-1.11-1.47-.91-.62.07-.6.07-.6 1 .07 1.53 1.03 1.53 1.03.87 1.52 2.34 1.07 2.91.83.09-.65.35-1.09.63-1.34-2.22-.25-4.55-1.11-4.55-4.92 0-1.11.38-2 1.03-2.71-.1-.25-.45-1.29.1-2.64 0 0 .84-.27 2.75 1.02.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02.55 1.35.2 2.39.1 2.64.65.71 1.03 1.6 1.03 2.71 0 3.82-2.34 4.66-4.57 4.91.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.top"], "search": "../../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.83f73b43.min.js"></script>
      
    
  </body>
</html>