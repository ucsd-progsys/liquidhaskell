

<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="Niki Vazou">
      
      
        <link rel="canonical" href="https://ucsd-progsys.github.io/liquidhaskell/blogposts/2013-05-24-unique-zipper.lhs/">
      
      
        <link rel="prev" href="../2013-06-03-abstracting-over-refinements.lhs/">
      
      
        <link rel="next" href="../2013-03-26-talking-about-sets.lhs/">
      
      
      <link rel="icon" href="../../static/img/favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.42">
    
    
      
        <title>Unique Zippers - LiquidHaskell Docs</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.0253249f.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@5.9.55/css/materialdesignicons.min.css">
    
      <link rel="stylesheet" href="../../static/liquid-light.css">
    
      <link rel="stylesheet" href="../../static/misc.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="cyan" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#a-quick-recap" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="LiquidHaskell Docs" class="md-header__button md-logo" aria-label="LiquidHaskell Docs" data-md-component="logo">
      
  <img src="../../static/img/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            LiquidHaskell Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Unique Zippers
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/ucsd-progsys/liquidhaskell" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="https://liquidhaskell.goto.ucsd.edu/index.html" class="md-tabs__link">
        
  
    
  
  <div id='demo'><i aria-hidden=true class='mdi mdi-cloud-braces'></i> Try Online</div>

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-human-greeting'></i> Tutorial

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
    
  
  

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../install/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-download'></i> Installation

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../specifications/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-script'></i> Spec Reference

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../options/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-flag'></i> Flag Reference

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
    
  
  

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../papers/" class="md-tabs__link">
        
  
    
  
  <i aria-hidden=true class='mdi mdi-school'></i> Papers

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../2020-08-20-lh-as-a-ghc-plugin.lhs/" class="md-tabs__link">
          
  
  <i aria-hidden=true class='mdi mdi-bullhorn'></i> Blog

        </a>
      </li>
    
  

    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="LiquidHaskell Docs" class="md-nav__button md-logo" aria-label="LiquidHaskell Docs" data-md-component="logo">
      
  <img src="../../static/img/logo.png" alt="logo">

    </a>
    LiquidHaskell Docs
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/ucsd-progsys/liquidhaskell" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="https://liquidhaskell.goto.ucsd.edu/index.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <div id='demo'><i aria-hidden=true class='mdi mdi-cloud-braces'></i> Try Online</div>
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-human-greeting'></i> Tutorial
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../install/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-download'></i> Installation
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../specifications/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-script'></i> Spec Reference
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../options/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-flag'></i> Flag Reference
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../papers/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-school'></i> Papers
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="">
            
  
  <span class="md-ellipsis">
    <i aria-hidden=true class='mdi mdi-bullhorn'></i> Blog
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            <i aria-hidden=true class='mdi mdi-bullhorn'></i> Blog
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_1" checked>
        
          
          <label class="md-nav__link" for="__nav_9_1" id="__nav_9_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Blogposts
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_1_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9_1">
            <span class="md-nav__icon md-icon"></span>
            Blogposts
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2020-08-20-lh-as-a-ghc-plugin.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LiquidHaskell is a GHC Plugin
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2020-04-12-polymorphic-perplexion.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Polymorphic Perplexion
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2019-10-20-why-types.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Liquid Types vs. Floyd-Hoare Logic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2018-05-17-hillel-verifier-rodeo-I-leftpad.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    The Hillelogram Verifier Rodeo I (LeftPad)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2018-02-23-measures-and-case-splitting.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Measures and Case Splitting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2017-12-24-splitting-and-splicing-intervals-II.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Splitting and Splicing Intervals (Part 2)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2017-12-15-splitting-and-splicing-intervals-I.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Splitting and Splicing Intervals (Part 1)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2017-03-20-arithmetic-overflows.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Arithmetic Overflows
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2016-10-06-structural-induction.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Refinement Reflection on ADTs
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2016-09-18-refinement-reflection.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Haskell as a Theorem Prover
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2016-09-01-normal-forms.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Normal Forms
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2015-01-30-okasakis-lazy-queue.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Okasaki's Lazy Queues
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2014-08-15-a-finer-filter.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A Finer Filter
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2014-05-28-pointers-gone-wild.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Pointers Gone Wild
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2014-02-11-the-advantage-of-measures.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    The Advantage of Measures
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-12-14-gcd.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Termination Requires Refinements
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-12-09-checking-termination.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Checking Termination
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-12-02-getting-to-the-bottom.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Getting To the Bottom
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-11-23-telling_lies.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LiquidHaskell Caught Telling Lies!
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-10-10-csv-tables.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CSV Tables
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-07-29-putting-things-in-order.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Putting Things In Order
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-06-03-abstracting-over-refinements.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Abstracting Over Refinements
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Unique Zippers
  </span>
  

      </a>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-03-26-talking-about-sets.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Talking About Sets
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-03-04-bounding-vectors.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Bounding Vectors
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-02-17-kmeans-clustering-II.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    KMeans Clustering II
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-02-16-kmeans-clustering-I.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    KMeans Clustering I
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-01-31-safely-catching-a-list-by-its-tail.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Safely Catching A List By Its Tail
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-01-28-bounding-vectors.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Bounding Vectors
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-01-27-refinements101-reax.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Refinements 101 (contd.)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../2013-01-01-refinement-types-101.lhs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Refinement Types 101
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tags.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tags
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                


                  
  
<nav class="md-tags" >
  
    
    
    
      <span class="md-tag">basic</span>
    
  
    
    
    
      <span class="md-tag">measures</span>
    
  
    
    
    
      <span class="md-tag">sets</span>
    
  
    
    
    
      <span class="md-tag">uniqueness</span>
    
  
</nav>


  
  


<p><strong>The story so far:</strong> <a href="blog/2013/03/26/talking-about-sets.lhs/">Previously</a> we saw
how we can use LiquidHaskell to talk about set of values
and specifically the <em>set of values</em> in a list.</p>
<p>Often, we want to enforce the invariant that a particular data structure
contains <em>no duplicates</em>. For example, we may have a structure that holds
a collection of file handles, or other resources, where the presence of
duplicates could lead to unpleasant leaks.</p>
<p>In this post, we will see how to use LiquidHaskell to talk
about the set of duplicate values in data structures, and 
hence, let us specify and verify uniqueness, that is, the
absence of duplicates.</p>
<!-- more -->

<p>To begin, lets extend our vocabulary to talk about the <em>set of duplicate
values</em> in lists.  By constraining this set to be empty, we can specify a
list without duplicates, or an <strong>unique list</strong>.  Once we express uniqueness
on lists, it is straightforward to describe uniqueness on other data
structures that contain lists.  As an example, we will illustrate the
properties of a <strong>unique zipper</strong>.</p>
<pre><span class=hs-linenum>37: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>UniqueZipper</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>38: </span>
<span class=hs-linenum>39: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span>  <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>filter</span><span class='hs-layout'>)</span>
<span class=hs-linenum>40: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>filter</span><span class='hs-layout'>)</span>
</pre>

<h1 id="a-quick-recap">A Quick Recap<a class="headerlink" href="#a-quick-recap" title="Permanent link">&para;</a></h1>
<p>In the previous post we used a measure for the elements of a list, from <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/Data/Set.spec">Data/Set.spec</a></p>
<pre><span class=hs-linenum>48: </span><span class='hs-definition'>measure</span> <span class='hs-varid'>listElts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum>49: </span><span class='hs-definition'>listElts</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varop'>?</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set_emp</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>}</span>
<span class=hs-linenum>50: </span><span class='hs-definition'>listElts</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set_cup</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set_sng</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>listElts</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>

<p>With this measure we defined predicate aliases 
that describe relations between lists:</p>
<pre><span class=hs-linenum>57: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>EqElts</span>  <span class='hs-conid'>X</span> <span class='hs-conid'>Y</span>      <span class='hs-keyglyph'>=</span> 
<span class=hs-linenum>58: </span>      <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>listElts</span> <span class='hs-conid'>X</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>listElts</span> <span class='hs-conid'>Y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>                        <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>59: </span>
<span class=hs-linenum>60: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>DisjointElts</span> <span class='hs-conid'>X</span> <span class='hs-conid'>Y</span> <span class='hs-keyglyph'>=</span> 
<span class=hs-linenum>61: </span>      <span class='hs-layout'>(</span><span class='hs-conid'>Set_emp</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set_cap</span> <span class='hs-layout'>(</span><span class='hs-varid'>listElts</span> <span class='hs-conid'>X</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>listElts</span> <span class='hs-conid'>Y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>        <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>62: </span>
<span class=hs-linenum>63: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>SubElts</span> <span class='hs-conid'>X</span> <span class='hs-conid'>Y</span>      <span class='hs-keyglyph'>=</span> 
<span class=hs-linenum>64: </span>      <span class='hs-layout'>(</span><span class='hs-conid'>Set_sub</span> <span class='hs-layout'>(</span><span class='hs-varid'>listElts</span> <span class='hs-conid'>X</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>listElts</span> <span class='hs-conid'>Y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>                  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>65: </span>
<span class=hs-linenum>66: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>UnionElts</span> <span class='hs-conid'>X</span> <span class='hs-conid'>Y</span> <span class='hs-conid'>Z</span>  <span class='hs-keyglyph'>=</span> 
<span class=hs-linenum>67: </span>      <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>listElts</span> <span class='hs-conid'>X</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set_cup</span> <span class='hs-layout'>(</span><span class='hs-varid'>listElts</span> <span class='hs-conid'>Y</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>listElts</span> <span class='hs-conid'>Z</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>68: </span>
<span class=hs-linenum>69: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>ListElt</span> <span class='hs-conid'>N</span> <span class='hs-conid'>X</span>      <span class='hs-keyglyph'>=</span> 
<span class=hs-linenum>70: </span>      <span class='hs-layout'>(</span><span class='hs-conid'>Set_mem</span> <span class='hs-conid'>N</span> <span class='hs-layout'>(</span><span class='hs-varid'>listElts</span> <span class='hs-conid'>X</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>                             <span class='hs-keyword'>@-}</span>
</pre>

<p>These predicates were our vocabulary on specifying properties of list functions.
Remember, that <code>reverse</code> returns an output list that has the same elements, i.e., <code>EqElts</code>, with the input list.
We can extend these predicates and express list uniqueness.
So reversing a unique list should again return an output list that has the same
elements as the input list, and also it is unique.</p>
<h1 id="describing-unique-lists">Describing Unique Lists<a class="headerlink" href="#describing-unique-lists" title="Permanent link">&para;</a></h1>
<p>To describe unique lists, we follow two steps:</p>
<ol>
<li>we describe the set of duplicate values of a list; and </li>
<li>we demand this set to be empty.</li>
</ol>
<p>Towards the first step, we define a measure <code>dups</code>
that returns the duplicate values of its input list.
This measure is recursively defined:
The duplicates of an empty list is the empty set.
We compute the duplicates of a non-empty list, 
namely <code>x:xs</code>, as follows:</p>
<ul>
<li>
<p>If <code>x</code> is an element of <code>xs</code>, then <code>x</code> is a duplicate.
  Hence, <code>dups</code> is <code>x</code> plus the (recursively computed) 
  duplicates in <code>xs</code>.</p>
</li>
<li>
<p>Otherwise, we can ignore <code>x</code> and recursively compute 
  the duplicates of <code>xs</code>.</p>
</li>
</ul>
<p>The above intuition can be formalized as a measure:</p>
<pre><span class=hs-linenum>105: </span><span class='hs-keyword'>{-@</span>
<span class=hs-linenum>106: </span>  <span class='hs-varid'>measure</span> <span class='hs-varid'>dups</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum>107: </span>  <span class='hs-varid'>dups</span><span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varop'>?</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set_emp</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>}</span>
<span class=hs-linenum>108: </span>  <span class='hs-varid'>dups</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-keyword'>if</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set_mem</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>listElts</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>109: </span>                         <span class='hs-keyword'>then</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set_cup</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set_sng</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>dups</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>110: </span>                         <span class='hs-keyword'>else</span> <span class='hs-layout'>(</span><span class='hs-varid'>dups</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>111: </span>  <span class='hs-keyword'>@-}</span>
</pre>

<p>With <code>dups</code> in hand, it is direct to describe unique lists:</p>
<p>A list is unique, if the set of duplicates, as computed by <code>dups</code> is empty.</p>
<p>We create a type alias for unique lists and name it <code>UList</code>.</p>
<pre><span class=hs-linenum>121: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>ListUnique</span> <span class='hs-conid'>X</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set_emp</span> <span class='hs-layout'>(</span><span class='hs-varid'>dups</span> <span class='hs-conid'>X</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>122: </span>
<span class=hs-linenum>123: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>UList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conid'>ListUnique</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span><span class='hs-layout'>}</span>     <span class='hs-keyword'>@-}</span>
</pre>

<h1 id="functions-on-unique-lists">Functions on Unique Lists<a class="headerlink" href="#functions-on-unique-lists" title="Permanent link">&para;</a></h1>
<p>In the previous post, we proved interesting properties about 
the list trilogy, i.e., <code>append</code>, <code>reverse</code>, and <code>filter</code>.
Now, we will prove that apart from these properties,
all these functions preserve list uniqueness.</p>
<h2 id="append">Append<a class="headerlink" href="#append" title="Permanent link">&para;</a></h2>
<p>To begin with, we proved that the output of append
indeed includes the elements from both the input lists.
Now, we can also prove that if both input lists are 
unique <em>and their elements are disjoint</em>, then the 
output list is also unique.</p>
<pre><span class=hs-linenum>145: </span><span class='hs-keyword'>infixr</span> <span class='hs-num'>5</span> <span class='hs-varop'>++</span>
<span class=hs-linenum>146: </span><span class='hs-keyword'>{-@</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>UList</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum>147: </span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ys</span><span class='hs-conop'>:</span><span class='hs-keyword'>{v:</span> <span class='hs-conid'>UList</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| (DisjointElts v xs)}</span>
<span class=hs-linenum>148: </span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span> <span class='hs-conid'>UList</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| (UnionElts v xs ys)}</span>
<span class=hs-linenum>149: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>150: </span><span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>151: </span><span class='hs-conid'>[]</span> <a class=annot href="#"><span class=annottext>forall a.
xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; ys:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts xs)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts ys)))}</span><span class='hs-varop'>++</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | ((Set_emp (dups VV)))}</span><span class='hs-varid'>ys</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == ys) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>ys</span></a>
<span class=hs-linenum>152: </span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | (VV == x)}</span><span class='hs-varid'>x</span></a><a class=annot href="#"><span class=annottext>forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class='hs-conop'>:</span></a><span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>xs</span></a> <a class=annot href="#"><span class=annottext>xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; ys:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts xs)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts ys)))}</span><span class='hs-varop'>++</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == ys) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>ys</span></a><span class='hs-layout'>)</span>
</pre>

<h2 id="reverse">Reverse<a class="headerlink" href="#reverse" title="Permanent link">&para;</a></h2>
<p>Next, we can prove that if a unique list is reversed, 
the output list has the same elements as the input,
and also it is unique.</p>
<pre><span class=hs-linenum>163: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reverse</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>UList</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span> <span class='hs-conid'>UList</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| (EqElts v xs)}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>164: </span><span class='hs-definition'>reverse</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>165: </span><a class=annot href="#"><span class=annottext>forall a.
xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (listElts xs))}</span><span class='hs-definition'>reverse</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((len VV) == 0)}
-&gt; x2:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts x1)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x1) (listElts x2))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x2) (listElts x1))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>166: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>167: </span>    <a class=annot href="#"><span class=annottext>a:{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((len VV) &gt;= 0)}
-&gt; x1:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts a)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts a) (listElts x1))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x1) (listElts a))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>a</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == a) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>a</span></a>
<span class=hs-linenum>168: </span>    <span class='hs-varid'>go</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a:{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((len VV) &gt;= 0)}
-&gt; x1:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts a)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts a) (listElts x1))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x1) (listElts a))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>go</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : a | (VV == x)}</span><span class='hs-varid'>x</span></a><a class=annot href="#"><span class=annottext>forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class='hs-conop'>:</span></a><a class=annot href="#"><span class=annottext>{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == a) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>a</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>xs</span></a> 
</pre>

<h2 id="filter">Filter<a class="headerlink" href="#filter" title="Permanent link">&para;</a></h2>
<p>Finally, filtering a unique list returns a list with a subset of
values of the input list, that once again is unique! </p>
<pre><span class=hs-linenum>178: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>filter</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> 
<span class=hs-linenum>179: </span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>UList</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> 
<span class=hs-linenum>180: </span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>UList</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| (SubElts v xs)}</span> 
<span class=hs-linenum>181: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>182: </span><a class=annot href="#"><span class=annottext>forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; x2:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts x2))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-definition'>filter</span></a> <a class=annot href="#"><span class=annottext>a -&gt; (GHC.Types.Bool)</span><span class='hs-varid'>p</span></a> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
{VV : [{VV : a | false}]&lt;p&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0)}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>183: </span><span class='hs-definition'>filter</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> 
<span class=hs-linenum>184: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>a -&gt; (GHC.Types.Bool)</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{VV : a | (VV == x)}</span><span class='hs-varid'>x</span></a>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | (VV == x)}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class='hs-conop'>:</span></a> <a class=annot href="#"><span class=annottext>forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; x2:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts x2))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>filter</span></a> <a class=annot href="#"><span class=annottext>a -&gt; (GHC.Types.Bool)</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>185: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; x2:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts x2))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>filter</span></a> <a class=annot href="#"><span class=annottext>a -&gt; (GHC.Types.Bool)</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>xs</span></a>
</pre>

<h1 id="unique-zipper">Unique Zipper<a class="headerlink" href="#unique-zipper" title="Permanent link">&para;</a></h1>
<p>That was easy enough! Now, lets look at a slightly more interesting
structure fashioned from lists.  A <a href="http://en.wikipedia.org/wiki/Zipper_(data_structure)">zipper</a> is an aggregate
data stucture that is used to arbitrary traverse the structure and update
its contents.</p>
<p>We define a zipper as a data type that contains an element (called <code>focus</code>)
that we are currently using, a list of elements (called <code>up</code>) before
the current one, and a list of elements (called <code>down</code>) after the current one.</p>
<pre><span class=hs-linenum>202: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Zipper</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Zipper</span> <span class='hs-layout'>{</span> <a class=annot href="#"><span class=annottext>forall a. (UniqueZipper.Zipper a) -&gt; a</span><span class='hs-varid'>focus</span></a> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span>       <span class='hs-comment'>-- focused element in this set</span>
<span class=hs-linenum>203: </span>                       <span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>forall a. (UniqueZipper.Zipper a) -&gt; [a]</span><span class='hs-varid'>up</span></a>    <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>     <span class='hs-comment'>-- elements to the left</span>
<span class=hs-linenum>204: </span>                       <span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>forall a. (UniqueZipper.Zipper a) -&gt; [a]</span><span class='hs-varid'>down</span></a>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span>   <span class='hs-comment'>-- elements to the right</span>
</pre>

<p>One well-known application of zippers is in the
<a href="http://xmonad.org/">XMonad</a> tiling window manager. 
The set of windows being managed is stored in a zipper 
similar to the above. The <code>focus</code> happily coincides with 
the window currently in focus, and the <code>up</code> and <code>down</code> 
to the list of windows that come before and after it.</p>
<p>One crucial invariant maintained by XMonad is that the zipper structure is
unique -- i.e. each window appears at most once inside the zipper.</p>
<p>Lets see how we can state and check that all the values in a zipper are unique.</p>
<p>To start with, we would like to refine the <code>Zipper</code> data declaration
to express that both the lists in the structure are unique <strong>and</strong> 
do not include <code>focus</code> in their values.</p>
<p>LiquidHaskell allow us to refine data type declarations, using the liquid comments.
So, apart from above definition definition for the <code>Zipper</code>, we add a refined one,
stating that the data structure always enjoys the desired properties.</p>
<pre><span class=hs-linenum>229: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Zipper</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Zipper</span> <span class='hs-layout'>{</span> <span class='hs-varid'>focus</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>230: </span>                           <span class='hs-layout'>,</span> <span class='hs-varid'>up</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UListDif</span> <span class='hs-varid'>a</span> <span class='hs-varid'>focus</span>
<span class=hs-linenum>231: </span>                           <span class='hs-layout'>,</span> <span class='hs-varid'>down</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UListDif</span> <span class='hs-varid'>a</span> <span class='hs-varid'>focus</span><span class='hs-layout'>}</span>
<span class=hs-linenum>232: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>233: </span>
<span class=hs-linenum>234: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>UListDif</span> <span class='hs-varid'>a</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>UList</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-conid'>ListElt</span> <span class='hs-conid'>N</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>

<p>It is worth noting that the above is kind of <em>dependent</em> record in that
the types of the <code>up</code> and <code>down</code> fields depend on the value of the <code>focus</code>
field.</p>
<p>With this annotation any time we use a <code>Zipper</code> in the code LiquidHaskell
knows that the <code>up</code> and <code>down</code> components are unique lists
that do not include <code>focus</code>. Moreover, when a new <code>Zipper</code> is constructed
LiquidHaskell proves that this property holds, otherwise a liquid type 
error is reported.</p>
<p>Hold on a minute!</p>
<p>The awake reader will have noticed that values inside the <code>Zipper</code> as 
specified so far, are <em>not unique</em>, as nothing prevents a value from 
appearing in both the <code>up</code> and the <code>down</code> components.</p>
<p>So, we have to specify that the contents of those two fields are <em>disjoint</em>.</p>
<p>One way to achieve this is by defining two measures <code>getUp</code> and <code>getDown</code>
that return the relevant parts of the <code>Zipper</code></p>
<pre><span class=hs-linenum>260: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>getUp</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> 
<span class=hs-linenum>261: </span>    <span class='hs-varid'>getUp</span> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>focus</span> <span class='hs-varid'>up</span> <span class='hs-varid'>down</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>up</span>
<span class=hs-linenum>262: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>263: </span>
<span class=hs-linenum>264: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>getDown</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> 
<span class=hs-linenum>265: </span>    <span class='hs-varid'>getDown</span> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>focus</span> <span class='hs-varid'>up</span> <span class='hs-varid'>down</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>down</span>
<span class=hs-linenum>266: </span>  <span class='hs-keyword'>@-}</span>
</pre>

<p>With these definitions, we create a type alias <code>UZipper</code>
that states that the two list components are disjoint, and hence,
that we have a <em>unique zipper</em> with no duplicates.</p>
<pre><span class=hs-linenum>274: </span><span class='hs-keyword'>{-@</span> 
<span class=hs-linenum>275: </span>  <span class='hs-keyword'>type</span> <span class='hs-conid'>UZipper</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conid'>DisjointElts</span> <span class='hs-layout'>(</span><span class='hs-varid'>getUp</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>getDown</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>}</span> 
<span class=hs-linenum>276: </span>  <span class='hs-keyword'>@-}</span>
</pre>

<h1 id="functions-on-unique-zippers">Functions on Unique Zippers<a class="headerlink" href="#functions-on-unique-zippers" title="Permanent link">&para;</a></h1>
<p>Now that we have defined a unique zipper, it is straightforward for
LiquidHaskell to prove that operations on zippers preserve uniqueness.</p>
<h2 id="differentiation">Differentiation<a class="headerlink" href="#differentiation" title="Permanent link">&para;</a></h2>
<p>We can prove that a zipper that built from elements from a unique list is
indeed unique.</p>
<pre><span class=hs-linenum>293: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>differentiate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>UZipper</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>294: </span><a class=annot href="#"><span class=annottext>forall a.
{VV : [a] | ((Set_emp (dups VV)))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class='hs-definition'>differentiate</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a. {VV : (Data.Maybe.Maybe a) | (((isJust VV)) &lt;=&gt; false)}</span><span class='hs-conid'>Nothing</span></a>
<span class=hs-linenum>295: </span><span class='hs-definition'>differentiate</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}) | (((isJust VV)) &lt;=&gt; true) &amp;&amp; ((fromJust VV) == x)}</span><span class='hs-conid'>Just</span></a> <a class=annot href="#"><span class=annottext>({VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}))
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class='hs-varop'>$</span></a> <a class=annot href="#"><span class=annottext>focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class='hs-conid'>Zipper</span></a> <a class=annot href="#"><span class=annottext>{VV : a | (VV == x)}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-conid'>[]</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>xs</span></a>
</pre>

<h2 id="integration">Integration<a class="headerlink" href="#integration" title="Permanent link">&para;</a></h2>
<p>And vice versa, all elements of a unique zipper yield a unique list.</p>
<pre><span class=hs-linenum>304: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>integrate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UZipper</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UList</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>305: </span><a class=annot href="#"><span class=annottext>forall a.
{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : [a] | ((Set_emp (dups VV)))}</span><span class='hs-definition'>integrate</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>x</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (listElts xs))}</span><span class='hs-varid'>reverse</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == l) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; ys:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts xs)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts ys)))}</span><span class='hs-varop'>++</span></a> <a class=annot href="#"><span class=annottext>{VV : a | (VV == x)}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class='hs-conop'>:</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == r) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>r</span></a>
</pre>

<p>Recall the types for <code>++</code> and <code>reverse</code> that we proved earlier -- hover
your mouse over the identifiers to refresh your memory. Those types are
essential for establishing the type of <code>integrate</code>. </p>
<ul>
<li>
<p>By the definition of <code>UZipper</code> we know that <code>l</code> is a unique list
  and that <code>x</code> is not an element of <code>l</code>.</p>
</li>
<li>
<p>Thus via the type of <code>reverse</code> we know that  <code>reverse l</code> is also
  unique and disjoint from <code>x</code> and <code>r</code>.</p>
</li>
<li>
<p>Finally, using the previously established type for <code>++</code> 
  LiquidHaskell can prove that since <code>x : r</code> is a unique 
  list with elements disjoint from <code>reverse l</code> the concatenation
  of the two lists is also a unique list.</p>
</li>
</ul>
<p>With the exact same reasoning, we use the above list operations to create more zipper operations.</p>
<h2 id="reverse_1">Reverse<a class="headerlink" href="#reverse_1" title="Permanent link">&para;</a></h2>
<p>We can reverse a unique zipper</p>
<pre><span class=hs-linenum>332: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reverseZipper</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UZipper</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UZipper</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>333: </span><span class='hs-definition'>reverseZipper</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Zipper</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Zipper</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>334: </span><a class=annot href="#"><span class=annottext>forall a.
{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class='hs-definition'>reverseZipper</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>t</span> <span class='hs-varid'>ls</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class='hs-conid'>Zipper</span></a> <a class=annot href="#"><span class=annottext>{VV : a | (VV == t)}</span><span class='hs-varid'>t</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>rs</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>ls</span></a>
</pre>

<h2 id="shifting-focus">Shifting Focus<a class="headerlink" href="#shifting-focus" title="Permanent link">&para;</a></h2>
<p>More the focus up or down</p>
<pre><span class=hs-linenum>343: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>focusUp</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UZipper</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UZipper</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>344: </span><a class=annot href="#"><span class=annottext>forall a.
{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class='hs-definition'>focusUp</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>t</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class='hs-conid'>Zipper</span></a> <a class=annot href="#"><span class=annottext>{VV : a | (VV == x) &amp;&amp; (VV == x)}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == xs) &amp;&amp; (VV == xs) &amp;&amp; ((len VV) == (len xs)) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts xs))) &amp;&amp; ((listElts VV) == (listElts xs)) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>xs</span></a> <a class=annot href="#"><span class=annottext>{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-conid'>[]</span></a> 
<span class=hs-linenum>345: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>346: </span>    <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : a | (VV == x)}</span><span class='hs-varid'>x</span></a><span class='hs-conop'>:</span><a class=annot href="#"><span class=annottext>{VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == xs) &amp;&amp; ((len VV) == (len xs)) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts xs))) &amp;&amp; ((listElts VV) == (listElts xs)) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span>                   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (listElts xs))}</span><span class='hs-varid'>reverse</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : a | (VV == t)}</span><span class='hs-varid'>t</span></a><a class=annot href="#"><span class=annottext>forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class='hs-conop'>:</span></a><a class=annot href="#"><span class=annottext>{VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>rs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>347: </span>
<span class=hs-linenum>348: </span><span class='hs-definition'>focusUp</span> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>t</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-conop'>:</span><span class='hs-varid'>ls</span><span class='hs-layout'>)</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class='hs-conid'>Zipper</span></a> <a class=annot href="#"><span class=annottext>{VV : a | (VV == l)}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>ls</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : a | (VV == t)}</span><span class='hs-varid'>t</span></a><a class=annot href="#"><span class=annottext>forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class='hs-conop'>:</span></a><a class=annot href="#"><span class=annottext>{VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>rs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>349: </span>
<span class=hs-linenum>350: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>focusDown</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UZipper</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UZipper</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>351: </span><a class=annot href="#"><span class=annottext>forall a.
{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class='hs-definition'>focusDown</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class='hs-varid'>reverseZipper</span></a> <a class=annot href="#"><span class=annottext>forall &lt;q :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool, p :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool&gt;.
(x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; {VV : (UniqueZipper.Zipper a)&lt;p x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})
-&gt; (y:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
    -&gt; {VV : (UniqueZipper.Zipper a)&lt;q y&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})
-&gt; x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; exists [z:{VV : (UniqueZipper.Zipper a)&lt;q x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}].{VV : (UniqueZipper.Zipper a)&lt;p z&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class='hs-varop'>.</span></a> <a class=annot href="#"><span class=annottext>{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class='hs-varid'>focusUp</span></a> <a class=annot href="#"><span class=annottext>forall &lt;q :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool, p :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool&gt;.
(x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; {VV : (UniqueZipper.Zipper a)&lt;p x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})
-&gt; (y:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
    -&gt; {VV : (UniqueZipper.Zipper a)&lt;q y&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})
-&gt; x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; exists [z:{VV : (UniqueZipper.Zipper a)&lt;q x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}].{VV : (UniqueZipper.Zipper a)&lt;p z&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class='hs-varop'>.</span></a> <a class=annot href="#"><span class=annottext>{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class='hs-varid'>reverseZipper</span></a>
</pre>

<h2 id="filter_1">Filter<a class="headerlink" href="#filter_1" title="Permanent link">&para;</a></h2>
<p>Finally, using the filter operation on lists allows LiquidHaskell to prove
that filtering a zipper also preserves uniqueness.</p>
<pre><span class=hs-linenum>361: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>filterZipper</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UZipper</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>UZipper</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>362: </span><a class=annot href="#"><span class=annottext>forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class='hs-definition'>filterZipper</span></a> <a class=annot href="#"><span class=annottext>a -&gt; (GHC.Types.Bool)</span><span class='hs-varid'>p</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Zipper</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ls</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span> 
<span class=hs-linenum>363: </span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>(a -&gt; (GHC.Types.Bool))
-&gt; xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts xs)))}</span><span class='hs-varid'>filter</span></a> <a class=annot href="#"><span class=annottext>a -&gt; (GHC.Types.Bool)</span><span class='hs-varid'>p</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : a | (VV == f)}</span><span class='hs-varid'>f</span></a><a class=annot href="#"><span class=annottext>forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class='hs-conop'>:</span></a><a class=annot href="#"><span class=annottext>{VV : [a] | (not (((Set_mem f (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>rs</span></a><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<span class=hs-linenum>364: </span>      <span class='hs-varid'>f'</span><span class='hs-conop'>:</span><span class='hs-varid'>rs'</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}) | (((isJust VV)) &lt;=&gt; true) &amp;&amp; ((fromJust VV) == x)}</span><span class='hs-conid'>Just</span></a> <a class=annot href="#"><span class=annottext>({VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}))
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class='hs-varop'>$</span></a> <a class=annot href="#"><span class=annottext>focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class='hs-conid'>Zipper</span></a> <a class=annot href="#"><span class=annottext>{VV : a | (VV == f')}</span><span class='hs-varid'>f'</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(a -&gt; (GHC.Types.Bool))
-&gt; xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts xs)))}</span><span class='hs-varid'>filter</span></a> <a class=annot href="#"><span class=annottext>a -&gt; (GHC.Types.Bool)</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | (not (((Set_mem f (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>ls</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{VV : [a] | (VV == rs') &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>rs'</span></a>
<span class=hs-linenum>365: </span>      <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>(a -&gt; (GHC.Types.Bool))
-&gt; xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts xs)))}</span><span class='hs-varid'>filter</span></a> <a class=annot href="#"><span class=annottext>a -&gt; (GHC.Types.Bool)</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | (not (((Set_mem f (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>ls</span></a> <span class='hs-keyword'>of</span>                  
<span class=hs-linenum>366: </span>                  <span class='hs-varid'>f'</span><span class='hs-conop'>:</span><span class='hs-varid'>ls'</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}) | (((isJust VV)) &lt;=&gt; true) &amp;&amp; ((fromJust VV) == x)}</span><span class='hs-conid'>Just</span></a> <a class=annot href="#"><span class=annottext>({VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}))
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class='hs-varop'>$</span></a> <a class=annot href="#"><span class=annottext>focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class='hs-conid'>Zipper</span></a> <a class=annot href="#"><span class=annottext>{VV : a | (VV == f')}</span><span class='hs-varid'>f'</span></a> <a class=annot href="#"><span class=annottext>{VV : [a] | (VV == ls') &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-varid'>ls'</span></a> <a class=annot href="#"><span class=annottext>{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>367: </span>                  <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>forall a. {VV : (Data.Maybe.Maybe a) | (((isJust VV)) &lt;=&gt; false)}</span><span class='hs-conid'>Nothing</span></a>
</pre>

<h1 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">&para;</a></h1>
<p>That's all for now! This post illustrated</p>
<ol>
<li>
<p>How we can use set theory to express properties the values of the list,
   such as list uniqueness.</p>
</li>
<li>
<p>How we can use LuquidHaskell to prove that these properties are
   preserved through list operations.</p>
</li>
<li>
<p>How we can embed this properties in complicated data structures that use
   lists, such as a zipper.</p>
</li>
</ol>
<pre><span class=hs-linenum>390: </span><span class='hs-comment'>-- TODO: Dummy function to provide qualifier hint.</span>
<span class=hs-linenum>391: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>q</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-keyword'>{v:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>|(not (Set_mem x (listElts v)))}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>392: </span><span class='hs-definition'>q</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>393: </span><a class=annot href="#"><span class=annottext>forall a. x:a -&gt; {VV : [a] | (not (((Set_mem x (listElts VV)))))}</span><span class='hs-definition'>q</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
{VV : [{VV : a | false}]&lt;p&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0)}</span><span class='hs-conid'>[]</span></a>
</pre>







  
  






                


<div class="blogpost-meta">
  
  <div class="blogpost-meta-whowhen">
    
        <div class="blogpost-meta-author">
            Niki Vazou
        </div>
    
    
        <div class="blogpost-meta-date">
            2013-05-10 16:12
        </div>
    
  </div>
  
  
  <div class="blogpost-meta-tags">
              
      <a href="../../tags.html#basic" class="tag-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5.5 7A1.5 1.5 0 0 1 4 5.5 1.5 1.5 0 0 1 5.5 4 1.5 1.5 0 0 1 7 5.5 1.5 1.5 0 0 1 5.5 7m15.91 4.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.11 0-2 .89-2 2v7c0 .55.22 1.05.59 1.41l8.99 9c.37.36.87.59 1.42.59s1.05-.23 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.56-.23-1.06-.59-1.42"/></svg>basic</a>
              
      <a href="../../tags.html#measures" class="tag-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5.5 7A1.5 1.5 0 0 1 4 5.5 1.5 1.5 0 0 1 5.5 4 1.5 1.5 0 0 1 7 5.5 1.5 1.5 0 0 1 5.5 7m15.91 4.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.11 0-2 .89-2 2v7c0 .55.22 1.05.59 1.41l8.99 9c.37.36.87.59 1.42.59s1.05-.23 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.56-.23-1.06-.59-1.42"/></svg>measures</a>
              
      <a href="../../tags.html#sets" class="tag-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5.5 7A1.5 1.5 0 0 1 4 5.5 1.5 1.5 0 0 1 5.5 4 1.5 1.5 0 0 1 7 5.5 1.5 1.5 0 0 1 5.5 7m15.91 4.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.11 0-2 .89-2 2v7c0 .55.22 1.05.59 1.41l8.99 9c.37.36.87.59 1.42.59s1.05-.23 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.56-.23-1.06-.59-1.42"/></svg>sets</a>
              
      <a href="../../tags.html#uniqueness" class="tag-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5.5 7A1.5 1.5 0 0 1 4 5.5 1.5 1.5 0 0 1 5.5 4 1.5 1.5 0 0 1 7 5.5 1.5 1.5 0 0 1 5.5 7m15.91 4.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.11 0-2 .89-2 2v7c0 .55.22 1.05.59 1.41l8.99 9c.37.36.87.59 1.42.59s1.05-.23 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.56-.23-1.06-.59-1.42"/></svg>uniqueness</a>
    
  </div>
  
</div>



              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
    <a href="https://join.slack.com/t/liquidhaskell/shared_invite/enQtMjY4MTk3NDkwODE3LTFmZGFkNGEzYWRkNDJmZDQ0ZGU1MzBiZWZiZDhhNmY3YTJiMjUzYTRlNjMyZDk1NDU3ZGIxYzhlOTIzN2UxNWE" target="_blank" rel="noopener" title="Join the LiquidHaskell slack channel" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 15a2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2h2zm1 0a2 2 0 0 1 2-2 2 2 0 0 1 2 2v5a2 2 0 0 1-2 2 2 2 0 0 1-2-2zm2-8a2 2 0 0 1-2-2 2 2 0 0 1 2-2 2 2 0 0 1 2 2v2zm0 1a2 2 0 0 1 2 2 2 2 0 0 1-2 2H4a2 2 0 0 1-2-2 2 2 0 0 1 2-2zm8 2a2 2 0 0 1 2-2 2 2 0 0 1 2 2 2 2 0 0 1-2 2h-2zm-1 0a2 2 0 0 1-2 2 2 2 0 0 1-2-2V5a2 2 0 0 1 2-2 2 2 0 0 1 2 2zm-2 8a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2v-2zm0-1a2 2 0 0 1-2-2 2 2 0 0 1 2-2h5a2 2 0 0 1 2 2 2 2 0 0 1-2 2z"/></svg>
    </a>
  
    
    
    
    
    <a href="https://groups.google.com/forum/#!forum/liquidhaskell" target="_blank" rel="noopener" title="Mail the LiquidHaskell users mailing list" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21.35 11.1h-9.17v2.73h6.51c-.33 3.81-3.5 5.44-6.5 5.44C8.36 19.27 5 16.25 5 12c0-4.1 3.2-7.27 7.2-7.27 3.09 0 4.9 1.97 4.9 1.97L19 4.72S16.56 2 12.1 2C6.42 2 2.03 6.8 2.03 12c0 5.05 4.13 10 10.22 10 5.35 0 9.25-3.67 9.25-9.09 0-1.15-.15-1.81-.15-1.81"/></svg>
    </a>
  
    
    
    
    
    <a href="https://github.com/ranjitjhala" target="_blank" rel="noopener" title="Drop Ranjit Jhala an email" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M498.1 5.6c10.1 7 15.4 19.1 13.5 31.2l-64 416c-1.5 9.7-7.4 18.2-16 23s-18.9 5.4-28 1.6L284 427.7l-68.5 74.1c-8.9 9.7-22.9 12.9-35.2 8.1S160 493.2 160 480v-83.6c0-4 1.5-7.8 4.2-10.8l167.6-182.8c5.8-6.3 5.6-16-.4-22s-15.7-6.4-22-.7L106 360.8l-88.3-44.2C7.1 311.3.3 300.7 0 288.9s5.9-22.8 16.1-28.7l448-256c10.7-6.1 23.9-5.5 34 1.4"/></svg>
    </a>
  
    
    
    
    
    <a href="https://github.com/nikivazou" target="_blank" rel="noopener" title="Drop Niki Vazou an email" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M16.1 260.2c-22.6 12.9-20.5 47.3 3.6 57.3L160 376v103.3c0 18.1 14.6 32.7 32.7 32.7 9.7 0 18.9-4.3 25.1-11.8l62-74.3 123.9 51.6c18.9 7.9 40.8-4.5 43.9-24.7l64-416c1.9-12.1-3.4-24.3-13.5-31.2s-23.3-7.5-34-1.4zm52.1 25.5L409.7 90.6 190.1 336l1.2 1zm335.1 139.7-166.6-69.5 214.1-239.3z"/></svg>
    </a>
  
    
    
    
    
    <a href="https://github.com/ucsd-progsys/liquidhaskell/issues" target="_blank" rel="noopener" title="Open a GitHub issue" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34-.46-1.16-1.11-1.47-1.11-1.47-.91-.62.07-.6.07-.6 1 .07 1.53 1.03 1.53 1.03.87 1.52 2.34 1.07 2.91.83.09-.65.35-1.09.63-1.34-2.22-.25-4.55-1.11-4.55-4.92 0-1.11.38-2 1.03-2.71-.1-.25-.45-1.29.1-2.64 0 0 .84-.27 2.75 1.02.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02.55 1.35.2 2.39.1 2.64.65.71 1.03 1.6 1.03 2.71 0 3.82-2.34 4.66-4.57 4.91.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.top"], "search": "../../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.83f73b43.min.js"></script>
      
    
  </body>
</html>