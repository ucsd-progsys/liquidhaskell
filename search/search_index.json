{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"","text":"<p>LiquidHaskell (LH) refines Haskell's types with logical predicates that let you enforce important properties at compile time.</p>"},{"location":"#guarantee-functions-are-total","title":"Guarantee Functions are Total","text":"<p> LH warns you that head is not total as it is missing the case for <code>[]</code> and checks that it is total on <code>NonEmpty</code> lists. (more...) </p> <p> The input contract propagates to uses of <code>head</code> which are verified by ensuring the arguments are <code>NonEmpty</code>. </p>"},{"location":"#keep-pointers-within-bounds","title":"Keep Pointers Within Bounds","text":"<p> LH lets you avoid off-by-one errors that can lead to crashes or buffer overflows. (more...) </p> <p> Dependent contracts let you specify, e.g. that <code>dotProduct</code> requires equal-sized vectors. </p>"},{"location":"#avoid-infinite-loops","title":"Avoid Infinite Loops","text":"<p> LH checks that functions terminate and so warns about the infinite recursion due to the missing case in <code>fib</code>. (more...) </p> <p> Metrics let you check that recursive functions over complex data types terminate. </p>"},{"location":"#enforce-correctness-properties","title":"Enforce Correctness Properties","text":"<p> Write correctness requirements, for example a list is ordered, as refinements. LH makes illegal values be unrepresentable. (more...) </p> <p> LH automatically points out logic bugs, and proves that functions return correct outputs for all inputs. </p>"},{"location":"#prove-laws-by-writing-code","title":"Prove Laws by Writing Code","text":"<p> Specify laws, e.g. that the append function <code>++</code> is associative, as Haskell functions. </p> <p> Verify laws via equational proofs that are plain Haskell functions. Induction is simply recursion, and case-splitting is just pattern-matching. </p>"},{"location":"#get-started","title":"Get Started","text":"<p>The easiest way to try LiquidHaskell is online, in your browser. This environment is ideal for quick experiments or following one of the tutorials:</p> <ul> <li>The Official Tutorial (long but complete) (has interactive exercises)</li> <li>Andres Loeh's Tutorial (concise but incomplete)</li> </ul> <p>For links to more documentation, see the nav-bar at the top of this page.</p>"},{"location":"#get-involved","title":"Get Involved","text":"<p>If you are interested in contributing to LH and its ecosystem, that's great! We have more information on our GitHub repository.</p>"},{"location":"install/","title":"How to Install","text":"<p>This sections documents how to install LH and its dependencies.</p>"},{"location":"install/#external-software-requirements","title":"External Software Requirements","text":"<p>In order to use LiquidHaskell, you will need a SMT solver installed on your system. Download and install at least one of:</p> <ul> <li>Z3 or Microsoft official binary</li> <li>CVC4</li> <li>MathSat</li> </ul> <p>When in doubt, install Z3, which is the SMT solver most tested with LiquidHaskell.</p> <p>Note: The SMT solver binary should be on your <code>PATH</code>; LiquidHaskell will execute it as a child process.</p>"},{"location":"install/#installing-liquidhaskell","title":"Installing LiquidHaskell","text":"<p>LiquidHaskell itself is installed&amp;enabled by adding it as a dependency in your project's <code>.cabal</code> file.</p> <p>Depending on your version of GHC, you might want to use a build of LiquidHaskell from github or from Hackage.</p> <ul> <li><code>ghc-9.10.1</code>: use liquidhaskell-0.9.10.1 from Hackage or use LiquidHaskell from github</li> <li><code>ghc-9.8.2</code>: use liquidhaskell-0.9.8.2 from Hackage</li> <li><code>ghc-9.6.3</code>: use liquidhaskell-0.9.6.3 from Hackage</li> <li><code>ghc-9.4.7</code>: use liquidhaskell-0.9.4.7.0 from Hackage</li> </ul> <p>Newer versions of GHC aren't supported yet.</p> <p>To use liquidhaskell from Hackage, add <code>liquidhaskell</code> to the <code>build-depends</code> section of your <code>.cabal</code> file, as you would any other dependency.</p> <p>This causes <code>cabal</code> to automatically:</p> <ol> <li>Install LiquidHaskell</li> <li>Tell GHC to use LH during compilation in modules that contain the pragma <code>{-# OPTIONS_GHC -fplugin=LiquidHaskell #-}</code></li> <li>Display liquid type errors during compilation</li> <li>Integrate LH with <code>ghci</code>, <code>ghcid</code> and all GHC compatible tooling for your favorite editor.</li> </ol> <p><code>stack</code> requires some further configuration to indicate which version of <code>liquidhaskell</code> and dependencies to use. See this repository for example <code>stack.yaml</code> files.</p>"},{"location":"install/#examples","title":"Examples","text":"<p>The following concrete examples show the LiquidHaskell plugin in action:</p> <ul> <li>Example Project 1</li> <li>Example Project 2 (uses Example Project 1 as a dependency)</li> </ul> <p>You can use the <code>.cabal</code>, <code>stack.yaml</code> and <code>cabal.project</code> files in the example packages to see how to write the equivalent files for your own codebase.</p>"},{"location":"install/#liquid-dependencies","title":"Liquid Dependencies","text":"<p>If you project depends on some well known library package <code>foo</code> (e.g. <code>base</code> or <code>vector</code>), then it's likely that the LiquidHaskell developers have written some specs for it. For boot libraries, that is those comming with the compiler, they are provided without further configuration. For other libraries like <code>vector</code>, a package like <code>liquid-vector</code> needs to be added to your <code>build-depends</code>.</p> <p>In order to see what specs are used for boot libraries, you can check the modules in src.</p> <p>For the vector library, you can find the specs here.</p> <p>In general, whenever your module imports another module <code>A.B.C</code>, Liquid Haskell will look for additional specs in any module of packages in <code>build-depends</code> with name <code>A.B.C_LHAssumptions</code>.</p>"},{"location":"install/#editor-integration","title":"Editor Integration","text":"<p>Since LiquidHaskell is implemented as a GHC plugin, you get to automatically reuse all <code>ghc</code>-based support for your editor as is. The sample packages include examples for <code>vscode</code>, <code>vim</code> and <code>emacs</code>.</p>"},{"location":"install/#uninstallation","title":"Uninstallation","text":"<p>Just remove the <code>liquid</code> packages from your <code>build-depends</code> again, and GHC won't use LiquidHaskell anymore. You may also want to delete the <code>.liquid</code> directories placed alongside your source files (they contain debug information).</p>"},{"location":"install/#other-options","title":"Other Options","text":"<p>Online Demo: For small projects without a <code>.cabal</code> file, you can paste your code into the online demo.</p>"},{"location":"options/","title":"Options and Pragmas","text":"<p>LiquidHaskell supports several configuration options, to alter the type checking.</p> <p>You can pass options in different ways:</p> <ol> <li> <p>As a pragma, directly added to the source file: (recommended)</p> <pre><code>{-@ LIQUID \"--opt1\" @-}\n</code></pre> </li> <li> <p>As a plugin option:</p> <pre><code>ghc-options: -fplugin-opt=LiquidHaskell:--opt1 -fplugin-opt=LiquidHaskell:--opt2\n</code></pre> </li> <li> <p>In the environment variable <code>LIQUIDHASKELL_OPTS</code> (e.g. in your <code>.bashrc</code> or <code>Makefile</code>):</p> <pre><code>LIQUIDHASKELL_OPTS=\"--opt1 --opt2\"\n</code></pre> </li> <li> <p>From the command line, if you use the legacy executable:</p> <pre><code>liquid --opt1 --opt2 ...\n</code></pre> </li> </ol> <p>The options are descibed below (and by the legacy executable: <code>liquid --help</code>)</p>"},{"location":"options/#theorem-proving","title":"Theorem Proving","text":"<p>Options: <code>reflection</code>, <code>ple</code>, <code>ple-local</code>, <code>extensionality</code>, <code>ple-with-undecided-guards</code>, <code>--dump-opaque-reflections</code>, <code>--etabeta</code>, <code>--dependantcase</code></p> <p>Directives: <code>automatic-instances</code></p> <p>To enable theorem proving, e.g. as described here use the option</p> <pre><code>    {-@ LIQUID \"--reflection\" @-}\n</code></pre> <p>To additionally turn on proof by logical evaluation (PLE) use the option</p> <pre><code>    {-@ LIQUID \"--ple\" @-}\n</code></pre> <p>You can see many examples of proofs by logical evaluation in <code>tests/benchmarks/popl18/ple/pos</code></p> <p>This flag is global and will symbolically evaluate all the terms that appear in the specifications.</p> <p>As an alternative, the <code>--ple-local</code> flag has local behavior. See</p> <pre><code>{-@ LIQUID \"--ple-local\" @-}\n</code></pre> <p>will only evaluate terms appearing in the specifications of the function <code>theorem</code>, if the function <code>theorem</code> is annotated for automatic instantiation using the following liquid annotation</p> <pre><code>{-@ automatic-instances theorem @-}\n</code></pre> <p>Normally, PLE will only unfold invocations only if the arguments are known with enough precision to enter some of the equations of the function. For instance, in</p> <pre><code>{-@ reflect boolToInt @-}\nboolToInt :: Bool -&gt; Int\nboolToInt False = 0\nboolToInt True = 1\n\n{-@ nonNegativeInt :: b:_ -&gt; { boolToInt b &gt;= 0 } @-}\nnonNegativeInt :: Bool -&gt; ()\nnonNegativeInt _ = ()\n</code></pre> <p>the equations <code>boolToInt False = 0</code> and <code>boolToInt True = 1</code> would only be used if <code>b</code> is known to be either <code>True</code> or <code>False</code>. Now, if nothing is known about <code>b</code> and we still would like to use the fact that</p> <pre><code>boolToInt b = if b then 1 else 0\n</code></pre> <p>we can instruct Liquid Haskell to do so and accept <code>nonNegativeInt</code> with</p> <pre><code>{-@ LIQUID \"--ple-with-undecided-guards\" @-}\n</code></pre> <p><code>--ple-with-undecided-guards</code> causes all invocations that haven't been unfolded due to undecided guards to be unfolded at the end of the algorithm. Alternatively, one could selectively unfold the invocations of some particular function only with <code>Language.Haskell.Liquid.ProofCombinators.pleUnfold</code>.</p> <pre><code>boolToInt b = pleUnfold (if b then 1 else 0)\n</code></pre> <p>Now, PLE will unfold <code>boolToInt</code> as above every time <code>b</code> is undecided. But won't unfold any other invocations with undecided guards unless they also start with an application of <code>pleUnfold</code>.</p> <p>To allow reasoning about function extensionality use the <code>--extensionality</code> flag. See test T1577.</p> <pre><code>{-@ LIQUID \"--extensionality\" @-}\n</code></pre> <p>Furthermore, you may also want to assume the reflection of some functions that you haven't defined, but need in your own reflected functions, or in the logic. For instance, let's say that you want to define the following function:</p> <pre><code>{-@ reflect keepDigits @-}\nkeepDigits :: [Char] -&gt; [Char]\nkeepDigits = filter isDigit\n</code></pre> <p>Or that you want to prove a property of filter:</p> <pre><code>{-@ lemma :: {v:[Char] | v == []} @-}\nlemma::  [Char]\nlemma = filter isDigit []\n</code></pre> <p>Both will fail because <code>GHC.List.filter</code> was not reflected in the first place, nor was <code>isDigit</code>. To overcome the problem, you can assume the reflection of both functions by defining a pretended function that should behave in the same way as the actual function. Therein lies the assumption: if both functions don't actually behave in the same way, then you may introduce falsity in your logic. Thus, you have to use it with caution, only when the function wasn't already reflected, and when you actually know how it will behave. In the following snippet, <code>myfilter</code> is the pretended function whose definition is given in our module, and the actual function <code>GHC.List.filter</code> and <code>myfilter</code> and tied through  the <code>{-@ assume reflect filter as myfilter @-}</code> annotation. This annotation must be read as: \"reflect <code>filter</code>, assuming it has the  same reflection as <code>myfilter</code>\".</p> <pre><code>-- Reflect filter\n{-@ reflect myfilter @-}\n{-@ myfilter :: (a -&gt; Bool) -&gt; xs:[a] -&gt; {v:[a] | len xs &gt;= len v} @-}\nmyfilter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]\nmyfilter _pred []   = []\nmyfilter pred (x:xs)\n  | pred x      = x : myfilter pred xs\n  | otherwise   = myfilter pred xs\n\n{-@ assume reflect filter as myfilter @-}\n\n-- Reflect isDigit\n\n{-@ reflect myIsDigit @-}\nmyIsDigit :: Char -&gt; Bool\nmyIsDigit x = '0' &lt;= x &amp;&amp; x &lt;= '9'\n\n{-@ assume reflect isDigit as myIsDigit @-}\n</code></pre>"},{"location":"options/#higher-order-reasoning","title":"Higher order reasoning","text":"<p>To make PLE aware of eta-expansion and beta-reduction rules, you can use the <code>--etabeta</code> flag:</p> <pre><code>{-@ LIQUID \"--etabeta\" @-}\n</code></pre> <pre><code>{-@ eta :: f:_ -&gt; { f = \\x:Int -&gt; f x } @-}\neta :: (Int -&gt; Int) -&gt; Proof\neta _ = trivial\n\n{-@ beta :: { (\\x:Int -&gt; x) (12) = 12 } @-}\nbeta :: Proof\nbeta = trivial\n</code></pre> <p>This also allows PLE to unfold partially applied reflected functions.</p> <p>Note: The eta-expansion rule should be able to prove the same goals as the <code>--extensionality</code> flag, so enabling both flags together shouldn't be necessary.</p> <p>Additionally, you can make PLE aware of rewrites obtained from dependent pattern matching on indexed inductive dependent types using the <code>--dependantcase</code> flag:</p> <pre><code>{-@ LIQUID \"--dependantcase\"  @-}\n</code></pre> <pre><code>data Term where\n    {-@ MkId :: Prop (Term id) @-}\n    MkId :: Term\ndata TERM = Term (Int -&gt; Int)\n\n\n{-@ patternMatch :: x:_ -&gt; f:_ -&gt; Prop (Term f) -&gt; { f x = x } @-}\npatternMatch :: Int -&gt; (Int -&gt; Int) -&gt; Term -&gt; Proof\npatternMatch _ _ MkId = trivial\n</code></pre> <p>From the pattern maching of <code>MkId</code>, Liquid Haskell can infer the equality <code>Term f = Term id</code>. But this is not enough to allow PLE to unfold <code>f</code> in the goal <code>f x = x</code>. The <code>--dependantcase</code> flag unifies the arguments of data constructors in equalities like <code>Term f = Term id</code>, which produces the equality <code>f = id</code>. This equality induces a rewrite rule that PLE uses to derive <code>id x = x</code> from <code>f x = x</code>, where <code>id</code> can then be unfolded.</p> <p>While both flags work independently, enabling <code>--dependantcase</code> might need to be complemented with the flag <code>--etabeta</code> to complete the verification of function equalities.</p>"},{"location":"options/#opaque-reflection","title":"Opaque reflection","text":"<p>LH automatically introduces uninterpreted functions / measures for all symbols which appear in the expression to reflect, but which are not already defined in the refinement logic. However, if you want to see exactly which symbols will be opaque-reflected (that's the term for it), you use this pragma:</p> <pre><code>{-@ LIQUID \"--dump-opaque-reflections\" @-}\n</code></pre> <p>It will dump the list of opaque reflections to the output. For example, assuming that <code>GHC.Internal.List.filter</code> and <code>GHC.Internal.Real.even</code> are not reflected, we get the following output for the following snippet.</p> <pre><code>{-@ LIQUID \"--reflection\"      @-}\n{-@ LIQUID \"--dump-opaque-reflections\"      @-}\n\nmodule OpaqueRefl06 where\n\n{-@ reflect keepEvens @-}\nkeepEvens :: [Int] -&gt; [Int]\nkeepEvens = filter even\n</code></pre> <pre><code>Opaque reflections:\n- GHC.Internal.List.filter\n- GHC.Internal.Real.even\n</code></pre> <p>Note: you can also reflect functions away from their definition, using interface files. For instance, you may do:</p> <pre><code>{-@ reflect uncurry @-}\n\n{-@ reflect otherFn @-}\notherFn :: (Int , Int) -&gt; Int\notherFn = uncurry myAdd\n\n{-@ reflect myAdd @-}\nmyAdd :: Int -&gt; Int -&gt; Int\nmyAdd a b = a + b + 1\n</code></pre> <p>Even though <code>uncurry</code> is an external, imported symbol.</p> <p>For this, LH will go and fetch the unfoldings of the function, which is essentially its content that is also used when the compiler does inlining. The unfoldings of these functions must be available, which is not always the case. Also note that even when they are available, not all functions can be reflected, for the same reasons as some of your own functions may not be reflected (presence of recursive definitions,  for instance).</p> <p>If the reflection of these happen to need the reflection of private variables inside those modules, you can also request their reflection with another <code>reflect</code> annotation with the fully-qualified name of the private variable to reflect, i.e. something like:</p> <pre><code>{-@ reflect MyMod.privFn @-}\n</code></pre> <p>Note: reflection of private variables only work if these variables occur in the definition of other variables that could already be reflected. You cannot reflect a private variable in general otherwise. Note 2: if these private variables are not manually reflected by you, they are, as usual, opaque-reflected automatically, as you can see by dumping the opaque reflections.</p>"},{"location":"options/#fast-checking","title":"Fast Checking","text":"<p>Options: <code>fast</code>, <code>nopolyinfer</code></p> <p>The option <code>--fast</code> or <code>--nopolyinfer</code> greatly recudes verification time, can also reduces precision of type checking. It, per module, deactivates inference of refinements during instantiation of polymorphic type variables. It is suggested to use on theorem proving style when reflected functions are trivially refined.</p>"},{"location":"options/#incremental-checking","title":"Incremental Checking","text":"<p>Options: <code>diff</code></p> <p>The LiquidHaskell executable supports incremental checking where each run only checks the part of the program that has been modified since the previous run. Each run of <code>liquid</code> saves the file to a <code>.bak</code> file and the subsequent run does a <code>diff</code> to see what has changed w.r.t. the <code>.bak</code> file only generates constraints for the <code>[CoreBind]</code> corresponding to the changed top-level binders and their transitive dependencies.</p> <p>The time savings are quite significant. For example:</p> <pre><code>    $ time liquid --notermination -i . Data/ByteString.hs &gt; log 2&gt;&amp;1\n\n    real    7m3.179s\n    user    4m18.628s\n    sys     0m21.549s\n</code></pre> <p>Now if you go and tweak the definition of <code>spanEnd</code> on line 1192 and re-run:</p> <pre><code>    $ time liquid --diff --notermination -i . Data/ByteString.hs &gt; log 2&gt;&amp;1\n\n    real    0m11.584s\n    user    0m6.008s\n    sys     0m0.696s\n</code></pre> <p>The diff is only performed against code, i.e. if you only change specifications, qualifiers, measures, etc. <code>liquid -d</code> will not perform any checks. In this case, you may specify individual definitions to verify:</p> <pre><code>    $ liquid -b bar -b baz foo.hs\n</code></pre> <p>This will verify <code>bar</code> and <code>baz</code>, as well as any functions they use.</p> <p>If you always want to run a given file with diff-checking, add the pragma:</p> <pre><code>{-@ LIQUID \"--diff\" @-}\n</code></pre>"},{"location":"options/#full-checking-default","title":"Full Checking (DEFAULT)","text":"<p>Options: <code>full</code></p> <p>You can force LiquidHaskell to check the whole file (which is the DEFAULT) using the <code>--full</code> option. This will override any other <code>--diff</code> incantation elsewhere (e.g. inside the file). If you always want to run a given file with full-checking, add the pragma:</p> <pre><code>{-@ LIQUID \"--full\" @-}\n</code></pre>"},{"location":"options/#specifying-different-smt-solvers","title":"Specifying Different SMT Solvers","text":"<p>Options: <code>smtsolver</code></p> <p>By default, LiquidHaskell uses the SMTLIB2 interface for Z3.</p> <p>To run a different solver (supporting SMTLIB2) do:</p> <pre><code>$ liquid --smtsolver=NAME foo.hs\n</code></pre> <p>Currently, LiquidHaskell supports</p> <ul> <li>CVC4</li> <li>MathSat</li> </ul> <p>To use these solvers, you must install the corresponding binaries from the above web-pages into your <code>PATH</code>.</p>"},{"location":"options/#short-error-messages","title":"Short Error Messages","text":"<p>Options: <code>short-errors</code></p> <p>By default, subtyping error messages will contain the inferred type, the expected type -- which is not a super-type, hence the error -- and a context containing relevant variables and their type to help you understand the error. If you don't want the above and instead, want only the source position of the error use <code>--short-errors</code>.</p>"},{"location":"options/#short-unqualified-module-names","title":"Short (Unqualified) Module Names","text":"<p>Options: <code>short-names</code></p> <p>By default, the inferred types will have fully qualified module names. To use unqualified names, much easier to read, use <code>--short-names</code>.</p>"},{"location":"options/#disabling-checks-on-functions","title":"Disabling Checks on Functions","text":"<p>Directives: <code>ignore</code></p> <p>You can disable checking of a particular function (e.g. because it is unsafe, or somehow not currently outside the scope of LH) by using the <code>ignore</code> directive.</p> <p>For example,</p> <pre><code>{-@ ignore foo @-}\n</code></pre> <p>will disable the checking of the code for the top-level binder <code>foo</code>.</p> <p>See <code>tests/pos/Ignores.hs</code> for an example.</p>"},{"location":"options/#totality-check","title":"Totality Check","text":"<p>Options: <code>no-totality</code></p> <p>LiquidHaskell proves the absence of pattern match failures.</p> <p>For example, the definition</p> <pre><code>fromJust :: Maybe a -&gt; a\nfromJust (Just a) = a\n</code></pre> <p>is not total and it will create an error message. If we exclude <code>Nothing</code> from its domain, for example using the following specification</p> <pre><code>{-@ fromJust :: {v:Maybe a | (isJust v)} -&gt; a @-}\n</code></pre> <p><code>fromJust</code> will be safe.</p> <p>Use the <code>no-totality</code> flag to disable totality checking.</p>"},{"location":"options/#termination-check","title":"Termination Check","text":"<p>Options: <code>no-termination</code></p> <p>By default a termination check is performed on all recursive functions, but you can disable the check with the <code>--no-termination</code> option.</p> <p>See the specifications section for how to write termination specifications.</p>"},{"location":"options/#positivity-check","title":"Positivity Check","text":"<p>Options: <code>no-positivity-check</code> By default a positivity check is performed on data definitions. </p> <pre><code>data Bad = Bad (Bad -&gt; Bad) | Good Bad \n    --           A      B           C\n    -- A is in a negative position, B and C are OK\n</code></pre> <p>Negative declarations are rejected because they admit non-terminating functions.</p> <p>If the positivity check is disabled, so that a similar declaration of <code>Bad</code> is allowed,  it is possible to construct a term of the empty type, even without recursion. For example see tests/neg/Positivity1.hs and tests/neg/Positivity2.hs</p> <pre><code>data Evil a = Very (Evil a -&gt; a)\n\n{-@ type Bot = {v: () | false} @-}\n\n{-@ bad :: Evil Bot -&gt; Bot @-}\nbad :: Evil () -&gt; ()\nbad (Very f) = f (Very f)\n\n{-@ worse :: Bot @-}\nworse :: ()\nworse = bad (Very bad)\n</code></pre> <p>Note that all positive occurrences are permited, unlike Coq that only allows the strictly positive ones (see: https://vilhelms.github.io/posts/why-must-inductive-types-be-strictly-positive/)</p>"},{"location":"options/#total-haskell","title":"Total Haskell","text":"<p>Options: <code>total-Haskell</code></p> <p>LiquidHaskell provides a total Haskell flag that checks both totallity and termination of the program, overriding a potential no-termination flag.</p>"},{"location":"options/#lazy-variables","title":"Lazy Variables","text":"<p>A variable can be specified as <code>LAZYVAR</code></p> <pre><code>{-@ LAZYVAR z @-}\n</code></pre> <p>With this annotation the definition of <code>z</code> will be checked at the points where it is used. For example, with the above annotation the following code is SAFE:</p> <pre><code>foo   = if x &gt; 0 then z else x\n  where\n    z = 42 `safeDiv` x\n    x = choose 0\n</code></pre> <p>By default, all the variables starting with <code>fail</code> are marked as LAZY, to defer failing checks at the point where these variables are used.</p>"},{"location":"options/#no-measure-fields","title":"No measure fields","text":"<p>Options: <code>no-measure-fields</code></p> <p>When a data type is refined, Liquid Haskell automatically turns the data constructor fields into measures. For example,</p> <pre><code>{-@ data L a = N | C {hd :: a, tl :: L a} @-}\n</code></pre> <p>will automatically create two measures <code>hd</code> and <code>td</code>. To deactivate this automatic measure definition, and speed up verification, you can use the <code>--no-measure-fields</code> flag.</p>"},{"location":"options/#prune-unsorted-predicates","title":"Prune Unsorted Predicates","text":"<p>Options: <code>prune-unsorted</code></p> <p>The <code>--prune-unsorted</code> flag is needed when using measures over specialized instances of ADTs.</p> <p>For example, consider a measure over lists of integers</p> <pre><code>sum :: [Int] -&gt; Int\nsum [] = 0\nsum (x:xs) = 1 + sum xs\n</code></pre> <p>This measure will translate into strengthening the types of list constructors</p> <pre><code>[] :: {v:[Int] | sum v = 0 }\n(:) :: x:Int -&gt; xs:[Int] -&gt; {v:[Int] | sum v = x + sum xs}\n</code></pre> <p>But what if our list is polymorphic <code>[a]</code> and later instantiate to list of ints? The workaround we have right now is to strengthen the polymorphic list with the <code>sum</code> information</p> <pre><code>[] :: {v:[a] | sum v = 0 }\n(:) :: x:a -&gt; xs:[a] -&gt; {v:[a] | sum v = x + sum xs}\n</code></pre> <p>But for non numeric <code>a</code>s, refinements like <code>x + sum xs</code> are ill-sorted!</p> <p>We use the flag <code>--prune-unsorted</code> to prune away unsorted expressions (like <code>x + sum xs</code>) inside refinements.</p>"},{"location":"options/#case-expansion","title":"Case Expansion","text":"<p>Options: <code>no-case-expand</code></p> <p>By default LiquidHaskell expands all data constructors to the case statements. For example, given the definition</p> <pre><code>data F = A1 | A2 | .. | A10\n</code></pre> <p>LiquidHaskell will expand the code</p> <pre><code>case f of {A1 -&gt; True; _ -&gt; False}\n</code></pre> <p>to</p> <pre><code>case f of {A1 -&gt; True; A2 -&gt; False; ...; A10 -&gt; False}\n</code></pre> <p>This expansion can lead to more precise code analysis but it can get really expensive due to code explosion. The <code>--no-case-expand</code> flag prevents this expansion and keeps the user provided cases for the case expression.</p>"},{"location":"options/#higher-order-logic","title":"Higher order logic","text":"<p>Options: <code>higherorder</code></p> <p>The flag <code>--higherorder</code> allows reasoning about higher order functions.</p>"},{"location":"options/#restriction-to-linear-arithmetic","title":"Restriction to Linear Arithmetic","text":"<p>Options: <code>linear</code></p> <p>When using <code>z3</code> as the solver, LiquidHaskell allows for non-linear arithmetic: division and multiplication on integers are interpreted by <code>z3</code>. To treat division and multiplication as uninterpreted functions use the <code>--linear</code> flag.</p>"},{"location":"options/#counter-examples","title":"Counter examples","text":"<p>Options: <code>counter-examples</code></p> <p>Status: <code>experimental</code></p> <p>When given the <code>--counter-examples</code> flag, LiquidHaskell will attempt to produce counter-examples for the type errors it discovers. For example, see tests/neg/ListElem.hs</p> <pre><code>% liquid --counter-examples tests/neg/ListElem.hs\n\n...\n\ntests/neg/ListElem.hs:12:1-8: Error: Liquid Type Mismatch\n\n 12 | listElem _ []      = False\n      ^^^^^^^^\n\n   Inferred type\n     VV : {VV : Bool | VV == True}\n     VV = True\n\n   not a subtype of Required type\n     VV : {VV : Bool | Prop VV &lt;=&gt; Set_mem ?b (listElts ?a)}\n\n   In Context\n     ?a : {?a : [a] | len ?a &gt;= 0}\n     ?a = [1]\n\n     ?b : a\n     ?b = 0\n</code></pre> <p>The <code>--counter-examples</code> flag requires that each type in the context be an instance of <code>GHC.Generics.Generic</code> or <code>Test.Targetable.Targetable</code> (provided as part of LiquidHaskell).  LiquidHaskell cannot generate counter-examples for polymorphic types, but will try (naively) to instantiate type variables with <code>Int</code> (as seen in the example above).</p>"},{"location":"options/#typeclasses","title":"Typeclasses","text":"<p>Options: <code>typeclass</code></p> <p>Status: <code>experimental</code></p> <p>The <code>--typeclass</code> flag enables LiquidHaskell's support of typeclasses. One limitation is that proofs cannot be written directly within the instance definition unless the <code>--aux-inline</code> flag is turned on as well.</p>"},{"location":"options/#generating-html-output","title":"Generating HTML Output","text":"<p>The system produces HTML files with colorized source, and mouseover inferred type annotations, which are quite handy for debugging failed verification attempts.</p> <ul> <li> <p>Regular Haskell When you run: <code>liquid foo.hs</code> you get a file   <code>foo.hs.html</code> with the annotations. The coloring is done using   <code>hscolour</code>.</p> </li> <li> <p>Markdown + Literate Haskell You can also feed in literate haskell files   where the comments are in Pandoc markdown.   In this case, the tool will run <code>pandoc</code> to generate the HTML from the comments.   Of course, this requires that you have <code>pandoc</code> installed as a binary on   your system. If not, <code>hscolour</code> is used to render the HTML.</p> </li> </ul> <p>It is also possible to generate slide shows from the above.   See the slides directory for an example.</p>"},{"location":"options/#loading-specifications-automatically","title":"Loading specifications automatically","text":"<p>By default, Liquid Haskell will load the specifications from module <code>A.B.C_LHAssumptions</code> whenever it finds an import of module <code>A.B.C</code>. For instance,</p> <pre><code>import Data.Vector\nimport Data.Vector.Unboxed\n</code></pre> <p>would cause Liquid Haskell to try modules <code>Data.Vector_LHAssumptions</code> and <code>Data.Vector.Unboxed_LHAssumptions</code>. If the <code>_LHAssumptions</code> module is missing, vecrification proceeds without any extra specifications.</p> <p><code>A.B.C_LHAssumptions</code> is looked in any package that is visible to GHC when verifying a module. But the following flag can be used to stop this automatic loading when the imported module belongs to the given package.</p> <p>Options: <code>--exclude-automatic-assumptions-for=PACKAGE</code></p> <p>Liquid Haskell will not load <code>_LHAssumptions</code> modules upon finding an import of a module coming from package <code>PACKAGE</code>. e.g. <code>--exclude-automatic-assumptions-for=vector</code> would stop loading <code>_LHAssumptions</code> modules for any imports coming from package <code>vector</code>.</p>"},{"location":"papers/","title":"Papers etc.","text":""},{"location":"papers/#papers","title":"Papers","text":"<p>To learn about the theory behind Liquid Types, I recommend reading first the PLDI 2008 paper and then the ESOP 2013 paper. Alternatively, one lazy weekend, you could curl up with:</p> <ul> <li>Pat Rondon's Ph.D Dissertation</li> <li>Tech Report</li> </ul>"},{"location":"papers/#haskell","title":"Haskell","text":"<ul> <li>REST: Integrating Term Rewriting with Program Verification, ECOOP 2022</li> <li>Refinement Reflection: Complete Verification with SMT, POPL 2018</li> <li>Local Refinement Typing, ICFP 2017</li> <li>Bounded Refinement Types, ICFP 2015</li> <li>Refinement Types For Haskell, ICFP 2014</li> <li>LiquidHaskell in the Real World, Haskell 2014</li> <li>Abstract Refinement Types, ESOP 2013</li> </ul>"},{"location":"papers/#ml","title":"ML","text":"<ul> <li>Liquid Types, PLDI 2008</li> <li>Type-based Data Structure Verification, PLDI 2009</li> <li>Dsolve: Safety Verification via Liquid Types, CAV 2010</li> <li>HMC: Verifying Functional Programs with Abstract Interpreters, CAV 2011</li> </ul>"},{"location":"papers/#c","title":"C","text":"<ul> <li>Low-level Liquid Types, POPL 2010</li> <li>Deterministic Parallelism With Liquid Effects, PLDI 2012</li> <li>Verifying C With Liquid Types, CAV 2012</li> </ul>"},{"location":"papers/#talks","title":"Talks","text":"<ul> <li>Untangle your spaghetti with Liquid Haskell (slides)</li> <li>Resource Analysis with Refinement Types, YOW! Lambda Jam 2021</li> <li>Liquid Haskell: Theorem Proving for All, Haskell Exchange 2018</li> <li>Scrap your Bounds Checks with Liquid Haskell, Haskell Exchange 2017 (slides)</li> </ul> <p>The following talks are good tutorial introductions to the techniques.</p> <ul> <li>Tutorial at VMCAI</li> <li>Tutorial at CAV</li> </ul>"},{"location":"papers/#other-articles","title":"Other articles","text":"<ul> <li>Assumptions for Liquid Haskell in the Large, Tweag blog 2023</li> <li>A Dialog with Liquid Haskell, Tweag blog 2022</li> <li>Why Liquid Haskell Matters, Tweag blog 2022</li> <li>Compile-time memory safety using Liquid Haskell, Haskell for all blog 2015</li> </ul>"},{"location":"papers/#people","title":"People","text":"<p>Liquid Types have been developed in the UCSD Programming Systems group by</p> <ul> <li>Alexander Bakst</li> <li>Ranjit Jhala</li> <li>Ming Kawaguchi</li> <li>Patrick Rondon</li> <li>Eric Seidel</li> <li>Michael Smith</li> <li>Anish Tondwalkar</li> <li>Chris Tetreault</li> <li>Niki Vazou</li> </ul>"},{"location":"papers/#thanks","title":"Thanks","text":"<p>This work is funded by NSF grants CCF-0644361, CNS-0720802, CCF-0702603, and generous gifts from Microsoft Research.</p>"},{"location":"specifications/","title":"Writing Specifications","text":"<p>This section documents how you can actually annotate new or existing code with refinement types, leveraging the full power of LiquidHaskell. As syntax reference you can also check this index.</p> <p>There are a lot of different ways to annotate your code, and so we've included a brief summary of each here.</p> <ul> <li><code>{-@ inline &lt;binding-name&gt; @-}</code> copies a Haskell definition to the refinement logic.   (Jump to: Inlines)<ul> <li>All parts of the definition must already be available to the refinement logic.</li> <li>The definition cannot be recursive.</li> </ul> </li> <li><code>{-@ measure &lt;function-name&gt;[ &lt;refinement-type&gt;] @-}</code> copies a Haskell function to the refinement logic,   adds an inferred refinement type to the constructor of the function's first argument,   and emits an inferred global invariant related to the refinement.   (Jump to: Measures)<ul> <li>All parts of the definition must already be available to the refinement logic.</li> <li>The function must have only one argument and it must pattern match on the constructors of the type.</li> <li>The function may structurally recurse on the single argument.</li> </ul> </li> <li><code>{-@ reflect &lt;function-name&gt; @-}</code> creates an uninterpreted function of the same name in the refinement logic,   copies the implementation to a refinement type alias,   and adds a refinement to the type of the uninterpreted function that specifies the type alias as a post-condition.   (See more: Section 2.2 of this paper)<ul> <li>If not all parts of the definition are in the refinement logic, then uninterpreted functions will be introduced for all symbols that   are not in the logic. To list those symbols, you can use the <code>--dump-opaque-reflections</code> flag.</li> <li>The function may be recursive.</li> </ul> </li> <li><code>{-@ assume reflect &lt;actual-function-name&gt; as &lt;pretended-function-name&gt; @-}</code> creates an assumption that the actual function   behaves as the pretended function. Whence the actual function becomes reflected and can be used in the logic. Its refinement type is strengthened with   the post-condition that the result of the actual function is the same as the result of the pretended function.   (Jump to: Theorem Proving)<ul> <li>The pretended function must be already reflected in the logic</li> </ul> </li> <li><code>{-@ type &lt;type-alias-head&gt; = &lt;refinement-type&gt; @-}</code> introduces a type alias that looks like Haskell syntax but can contain refinements and may be parameterized over both types and values.   (Jump to: Type Aliases)</li> <li><code>{-@ predicate .. @-}</code> introduces something like <code>{-@ type .. @-}</code>.   (Deprecated, use <code>inline</code> instead, Jump to: Predicate Aliases)</li> <li><code>{-@ invariant &lt;refinement-type&gt; @-}</code> introduces a globally available refinement which may be used by Liquid Haskel, but is not checked.   (Unchecked, Deprecated, Jump to: Invariants)</li> <li><code>{-@ data &lt;data-type-head&gt;&lt;termination-measure&gt;[ &lt;data-type-body] @-}</code> introduces a refined datatype,   and introduces measures for each field of a record datatype.   (Jump to: Data Refinements)<ul> <li>Optionally you may also add refinements to datatype fields.</li> <li>Optionally you may also add a termination measure to the datatype.</li> </ul> </li> <li><code>{-@ assume &lt;binding-signature-with-refinement-type&gt; @-}</code> introduces a refinement type for the named Haskell definition.   (Unchecked)<ul> <li>For a function, the refinements become pre and post conditions for the functions use.</li> </ul> </li> <li><code>{-@ &lt;binding-signature-with-refinement-type&gt; @-}</code> introduces a refinement type for the named Haskell definition.<ul> <li>For a function, the refinements become pre and post conditions for the functions use.</li> <li>This is probably the most used Liquid Haskell annotation!</li> </ul> </li> </ul> <p>The following sections detail more variety for the uses of the above annotations.</p>"},{"location":"specifications/#modules-without-code","title":"Modules WITHOUT code","text":"<p>See the installation section, which cointains a link to a walkthrough document that describes how to add refinements for external packages (cfr. \"Providing Specifications for Existing Packages\")</p>"},{"location":"specifications/#modules-with-code-data","title":"Modules WITH code: Data","text":"<p>Write the specification directly into the .hs or .lhs file, above the data definition. See, for example, tests/pos/Map.hs:</p> <pre><code>{-@\ndata Map k a &lt;l :: k -&gt; k -&gt; Prop, r :: k -&gt; k -&gt; Prop&gt;\n  = Tip\n  | Bin (sz    :: Size)\n        (key   :: k)\n        (value :: a)\n        (left  :: Map &lt;l, r&gt; (k &lt;l key&gt;) a)\n        (right :: Map &lt;l, r&gt; (k &lt;r key&gt;) a)\n@-}\ndata Map k a = Tip\n             | Bin Size k a (Map k a) (Map k a)\n</code></pre> <p>You can also write invariants for data type definitions together with the types. For example, see tests/pos/record0.hs:</p> <pre><code>{-@ \ndata LL a = BXYZ { size  :: {v: Int | v &gt; 0 }\n                 , elems :: {v: [a] | (len v) = size }\n                 }\n@-}\n</code></pre> <p>You can also specify a decreasing size for each data.  For example, see tests/pos/FancyMutualTerm.hs:</p> <pre><code>{-@ measure tsize :: Tree a -&gt; Nat @-}\n{-@ data size (Tree a) tsize @-}\n\n{-@ data Tree a where \n      Leaf :: a -&gt; {t:Tree a  | tsize t == 0 } \n      Node :: f:(Int -&gt; Tree a) -&gt; Tree a  @-}\n</code></pre> <p>The annotation <code>data size (Tree a) tsize</code> ensures that each <code>Tree a</code> in the fields of <code>Tree</code> has <code>tsize</code> less than the result <code>Tree</code>.  The <code>data size</code> annotation can be used for mutually defined types  as  <code>data size (M1 a, M2 a) msize</code>.</p> <p>Finally you can specify the variance of type variables for data types. For example, see tests/pos/Variance.hs, where data type <code>Foo</code> has four type variables <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, specified as invariant, bivariant, covariant and contravariant, respectively.</p> <pre><code>{-@ data variance Foo invariant bivariant covariant contravariant @-}\ndata Foo a b c d\n</code></pre>"},{"location":"specifications/#modules-with-code-functions","title":"Modules WITH code: Functions","text":"<p>Write the specification directly into the .hs or .lhs file, above the function definition. For example:</p> <pre><code>{-@ incr :: x:{v: Int | v &gt; 0} -&gt; {v: Int | v &gt; x} @-}\nincr   :: Int -&gt; Int\nincr x = x + 1\n</code></pre>"},{"location":"specifications/#modules-with-code-type-classes","title":"Modules WITH code: Type Classes","text":"<p>Write the specification directly into the .hs or .lhs file. The constrained variable must match the one from the class definition. A class must have at least one refinement signature (even if it's a trivial one) to be lifted to the refinement logic. For example:</p> <pre><code>class Semigroup a where\n    {-@ mappend :: a -&gt; a -&gt; a @-}\n    mappend :: a -&gt; a -&gt; a\n    sconcat :: NonEmpty a -&gt; a\n\nclass Semigroup a =&gt; VSemigroup a where\n    {-@ lawAssociative :: v:a -&gt; v':a -&gt; v'':a -&gt;\n          {mappend (mappend v v') v'' == mappend v (mappend v' v'')} @-}\n    lawAssociative :: a -&gt; a -&gt; a -&gt; ()\n</code></pre> <p>Without the extra signature for <code>mappend</code>, the above example would not work.</p> <p>Instances can be defined without any special annotations:</p> <pre><code>data PNat = Z | S PNat\n\ninstance Semigroup PNat where\n  mappend Z     n = n\n  mappend (S m) n = S (mappend m n)\n  sconcat (NonEmpty h t) = foldlList mappend h t\n\ninstance VSemigroup PNat where\n  lawAssociative Z     _ _ = ()\n  lawAssociative (S p) m n = lawAssociative p m n\n</code></pre> <p>The example above inlines the proofs directly into the instance definition. This requires the <code>--aux-inline</code> flag.</p>"},{"location":"specifications/#modules-with-code-type-classes-legacy","title":"Modules WITH code: Type Classes (Legacy)","text":"<p>Write the specification directly into the .hs or .lhs file, above the type class definition. For example:</p> <pre><code>{-@ class Sized s where\n      size :: forall a. x:s a -&gt; {v:Int | v = (size x)}\n@-}\nclass Sized s where\n  size :: s a -&gt; Int\n</code></pre> <p>Any measures used in the refined class definition will need to be generic (see Specifying Measures).</p> <p>As an alternative, you can refine class instances. For example:</p> <pre><code>instance Compare Int where\n\n{-@ instance Compare Int where\n    cmax :: Odd -&gt; Odd -&gt; Odd\n  @-}\n\ncmax y x = if x &gt;= y then x else y\n</code></pre> <p>When <code>cmax</code> method is used on <code>Int</code>, <code>liquidHaskell</code> will give it the refined type <code>Odd -&gt; Odd -&gt; Odd</code>.</p> <p>Note that currently <code>liquidHaskell</code> does not allow refining instances of refined classes.</p>"},{"location":"specifications/#modules-with-code-quasiquotation","title":"Modules WITH code: QuasiQuotation","text":"<p>Instead of writing both a Haskell type signature and a LiquidHaskell specification for a function, the <code>lq</code> quasiquoter in the <code>LiquidHaskell</code> module can be used to generate both from just the LiquidHaskell specification.</p> <pre><code>module Nats (nats) where\n\n{-@ nats :: [{v:Int | 0 &lt;= v}] @-}\nnats :: [Int]\nnats = [1,2,3]\n</code></pre> <p>can be written as</p> <pre><code>{-# LANGUAGE QuasiQuotes #-}\nmodule Nats (nats) where\n\nimport LiquidHaskell\n\n[lq| nats :: [{v:Int | 0 &lt;= v}] |]\nnats = [1,2,3]\n</code></pre> <p>and the <code>lq</code> quasiquoter will generate the plain <code>nats :: [Int]</code> when GHC compiles the module.</p> <p>Refined type aliases (see the next section) can also be written inside <code>lq</code>; for example:</p> <pre><code>{-# LANGUAGE QuasiQuoters #-}\nmodule Nats (Nat, nats) where\n\n[lq| type Nat = {v:Int | 0 &lt;= v} |]\n\n[lq| nats :: [Nat] |]\nnats = [1,2,3]\n</code></pre> <p>Here, the <code>lq</code> quasiquoter will generate a plain Haskell type synonym for <code>Nat</code> as well as the refined one.</p> <p>Note that this is still an experimental feature, and currently requires that one depend on LiquidHaskell as a build dependency for your project; the quasiquoter will be split out eventually into an independent, dependency-light package. Also, at this time, writing a type inside <code>lq</code> which refers to a refined type alias for which there is not a plain Haskell type synonym of the same name will result in a \"not in scope\" error from GHC.</p>"},{"location":"specifications/#specifications-for-dependencies","title":"Specifications for dependencies","text":"<p>Suppose you have a dependency without specifications like</p> <pre><code>module Lib (foo) where\n\nfoo a = a\n</code></pre> <p>Instead of adding specifications to this file, we could add them to a module with a name suffixed with <code>_LHAssumptions</code>. For instance,</p> <pre><code>module Lib_LHAssumptions where\n\nimport Lib\n\n-- Don't forget to qualify the name!\n\n{-@ Lib.foo :: {v:a | false} -&gt; a @-}\n</code></pre> <p>Whenever LiquidHaskell sees an import of <code>M</code>, it will look for a module <code>M_LHAssumptions</code> in the dependency packages. If it finds it, it will use the specifications from that module. In this way, you can add specifications to dependencies without modifying their source code.</p> <p>Here's an example usage</p> <pre><code>module Client where\n\nimport Lib  -- When LH finds this import it will look for specifications in Lib_LHAssumptions\n\nbar = foo 1  -- The specification should cause this call to be rejected by LH\n</code></pre> <p>If <code>Lib_LHAssumptions</code> cannot be found, then no extra specifications are loaded, and verification of <code>Client.hs</code> should succeed. At the moment <code>Lib_LHAssumptions</code> is only looked for in external packages, that is, not in the package being currently compiled. See this blog post for additional context on this feature.</p>"},{"location":"specifications/#inductive-predicates","title":"Inductive Predicates","text":"<p>Status: <code>very_experimental</code></p> <p>LH recently added support for Inductive Predicates in the style of Isabelle, Coq etc. These are encoded simply as plain Haskell GADTs but suitably refined.</p> <p>Apologies for the minimal documentation; see the following examples for details:</p> <ul> <li>Palindrome</li> <li>Permutations</li> <li>Transitive Closure</li> <li>RegExp Derivatives</li> <li>Type Safety of STLC</li> </ul>"},{"location":"specifications/#refinement-type-aliases","title":"Refinement Type Aliases","text":""},{"location":"specifications/#predicate-aliases","title":"Predicate Aliases","text":"<p>Often, the propositions in the refinements can get rather long and verbose. You can write predicate aliases like so:</p> <pre><code>{-@ predicate Lt X Y = X &lt; Y        @-}\n{-@ predicate Ge X Y = not (Lt X Y) @-}\n</code></pre> <p>and then use the aliases inside refinements, for example</p> <pre><code>{-@ incr :: x:{v:Int | (Pos v)} -&gt; { v:Int | ((Pos v) &amp;&amp; (Ge v x))} @-}\nincr :: Int -&gt; Int\nincr x = x + 1\n</code></pre> <p>See Data.Map for a more substantial and compelling example.</p> <p>Syntax: The key requirements for type aliases are:</p> <ul> <li>Value parameters are specified in uppercase: <code>X</code>, <code>Y</code>, <code>Z</code> etc.</li> </ul>"},{"location":"specifications/#type-aliases","title":"Type Aliases","text":"<p>Similarly, it is often quite tedious to keep writing</p> <pre><code>{v: Int | v &gt; 0}\n</code></pre> <p>Thus, LiquidHaskell supports refinement-type aliases of the form:</p> <pre><code>{-@ type Gt      N = {v: Int | N &lt;  v} @-}\n{-@ type GeNum a N = {v: a   | N &lt;= v} @-}\n</code></pre> <p>or</p> <pre><code>{-@ type SortedList a = [a]&lt;{\\fld v -&gt; (v &gt;= fld)}&gt; @-}\n</code></pre> <p>or</p> <pre><code>{-@ type OMap k a = Map &lt;{\\root v -&gt; v &lt; root}, {\\root v -&gt; v &gt; root}&gt; k a @-}\n</code></pre> <p>or</p> <pre><code>{-@ type MinSPair a = (a, OSplay a) &lt;\\fld -&gt; {v : Splay {v:a|v&gt;fld} | 0=0}&gt; @-}\n</code></pre> <p>and then use the above in signatures like:</p> <pre><code>{-@ incr: x: Int -&gt; GeNum Int x @-}\n</code></pre> <p>or</p> <pre><code>{-@ incr: x: Int -&gt; Gt x @-}\n</code></pre> <p>and:</p> <pre><code>{-@ assert insert :: (Ord a) =&gt; a -&gt; SortedList a -&gt; SortedList a @-}\n</code></pre> <p>see tests/pos/ListSort.hs</p> <p>and:</p> <pre><code>{-@ assert insert :: (Ord k) =&gt; k -&gt; a -&gt; OMap k a -&gt; OMap k a @-}\n</code></pre> <p>see tests/pos/Map.hs</p> <p>Syntax: The key requirements for type aliases are:</p> <ol> <li>Type parameters are specified in lowercase: <code>a</code>, <code>b</code>, <code>c</code> etc.</li> <li>Value parameters are specified in uppercase: <code>X</code>, <code>Y</code>, <code>Z</code> etc.</li> </ol>"},{"location":"specifications/#infix-operators","title":"Infix  Operators","text":"<p>You can define infix types and logical operators in logic Haskell's infix notation. For example, if <code>(+++)</code> is defined as a measure or reflected function, you can use it infix by declaring</p> <pre><code>{-@ infixl 9 +++ @-}\n</code></pre> <p>Note: infix operators cannot contain the dot character <code>.</code>.</p> <p>If <code>(==&gt;)</code> is a Haskell infix type (see)</p> <pre><code>infixr 1 ==&gt;\n</code></pre> <p>then to use it as infix in the refinements types you need to add the refinement infix notation. </p> <pre><code>{-@ infixr 1 ==&gt; @-}\n{-@ test :: g:(f ==&gt; g) -&gt; f x -&gt; f y -&gt; ()  @-}\n</code></pre>"},{"location":"specifications/#failing-specifications","title":"Failing Specifications","text":"<p>The <code>fail b</code> declaration checks that the definition of <code>b</code> is unsafe. E.g., the following is SAFE.</p> <pre><code>{-@ fail unsafe @-}\n{-@ unsafe :: () -&gt; { 0 == 1 } @-}\nunsafe :: () -&gt; ()\nunsafe _ = ()\n</code></pre> <p>An error is created if <code>fail</code> definitions are safe or binders defined as <code>fail</code> are used by (failing or not) definitions.</p>"},{"location":"specifications/#specifying-measures","title":"Specifying Measures","text":"<p>They can be placed in a .hs/.lhs file wrapped around <code>{-@ @-}</code>.</p> <p>Value measures: GHC/Base_LHAssumptions.hs</p> <pre><code>measure len :: forall a. [a] -&gt; GHC.Types.Int\nlen ([])     = 0\nlen (y:ys)   = 1 + len(ys)\n</code></pre> <p>Propositional measures: tests/pos/LambdaEval.hs</p> <pre><code>{-@\nmeasure isValue      :: Expr -&gt; Bool\nisValue (Const i)    = true\nisValue (Lam x e)    = true\nisValue (Var x)      = false\nisValue (App e1 e2)  = false\nisValue (Plus e1 e2) = false\nisValue (Fst e)      = false\nisValue (Snd e)      = false\nisValue (Pair e1 e2) = ((? (isValue(e1))) &amp;&amp; (? (isValue(e2))))\n@-}\n</code></pre> <p>Raw measures: tests/pos/meas8.hs</p> <pre><code>{-@ measure rlen :: [a] -&gt; Int\nrlen ([])   = {v | v = 0}\nrlen (y:ys) = {v | v = (1 + rlen(ys))}\n@-}\n</code></pre> <p>Generic measures: tests/pos/Class.hs</p> <pre><code>{-@ class measure size :: a -&gt; Int @-}\n{-@ instance measure size :: [a] -&gt; Int\n    size ([])   = 0\n    size (x:xs) = 1 + (size xs)\n@-}\n{-@ instance measure size :: Tree a -&gt; Int\n    size (Leaf)       = 0\n    size (Node x l r) = 1 + (size l) + (size r)\n@-}\n</code></pre> <p>Note: Measure names do not have to be the same as field name, e.g. we could call the measure <code>sz</code> in the above as shown in tests/pos/Class2.hs.</p> <p>Haskell Functions as Measures (beta): tests/pos/HaskellMeasure.hs</p> <p>Inductive Haskell Functions from Data Types to some type can be lifted to logic</p> <pre><code>-- Note that in this case the type signature must be omitted in the measure\n-- directive\n{-@ measure llen @-}\nllen        :: [a] -&gt; Int\nllen []     = 0\nllen (x:xs) = 1 + llen xs\n</code></pre> <p>The above definition:</p> <ul> <li>refines list's data constructors types with the llen information, and</li> <li>specifies a singleton type for the haskell function <code>llen :: xs:[a] -&gt; {v:Int | v == llen xs}</code>.   If the user specifies another type for <code>llen</code>, say <code>llen :: xs:[a] -&gt; {v:Int | llen xs &gt;= 0}</code>,   then the auto generated singleton type is overwritten.</li> </ul>"},{"location":"specifications/#inlines","title":"Inlines","text":"<p>The <code>inline</code> lets you use a Haskell function in a type specification. </p> <pre><code>{-@ inline max @-}\n{-@ max :: Int -&gt; Int -&gt; Int @-}\nmax :: Int -&gt; Int -&gt; Int\nmax x y = if x &gt; y then x else y\n</code></pre> <p>For example, if you write the above you can then write a function:</p> <pre><code>{-@ floor :: x:Int -&gt; {v:Int | max 0 x} @-}\nfloor :: Int -&gt; Int\nfloor x \n  | x &lt;= 0    = 0\n  | otherwise = x\n</code></pre> <p>That is, you can use the haskell <code>max</code> in the refinement type and  it will automatically get \u201cexpanded\u201d out to the full definition.  This makes it useful e.g. to reuse plain Haskell code to compose  specifications, and to share definitions common to refinements and code.</p> <p>However, as they are expanded at compile time, <code>inline</code> functions  cannot be recursive. The can call other (non-recursive) inline functions.</p> <p>If you want to talk about arbitrary (recursive) functions inside your types,  then you need to use <code>reflect</code> described in the blog.</p>"},{"location":"specifications/#self-invariants","title":"Self-Invariants","text":"<p>Sometimes, we require specifications that allow inner components of a type to refer to the outer components, typically, to measure-based properties of outer components. For example, the following invariant about <code>Maybe</code> values</p> <pre><code>{-@ type IMaybe a = {v0 : Maybe {v : a | ((isJust v0) &amp;&amp; v = (fromJust v0))} | 0 = 0 } @-}\n</code></pre> <p>states that the inner <code>a</code> enjoys the property that the outer container is definitely a <code>Just</code> and furthermore, the inner value is exactly the same as the <code>fromJust</code> property of the outer container.</p> <p>As another example, suppose we have a measure:</p> <pre><code>measure listElts :: [a] -&gt; (Set a)\nlistElts([])   = {v | (? Set_emp(v))}\nlistElts(x:xs) = {v | v = Set_cup(Set_sng(x), listElts(xs)) }\n</code></pre> <p>Now, all lists enjoy the property</p> <pre><code>{-@ type IList a = {v0 : List  {v : a | (Set_mem v (listElts v0)) } | true } @-}\n</code></pre> <p>which simply states that each inner element is indeed, a member of the set of the elements belonging to the entire list.</p> <p>One often needs these circular or self invariants to connect different levels (or rather, to reify the connections between the two levels.) See this test for a simple example and <code>hedgeUnion</code> and Data.Map.Base for a complex one.</p>"},{"location":"specifications/#abstract-and-bounded-refinements","title":"Abstract and Bounded Refinements","text":"<p>This is probably the best example of the abstract refinement syntax:</p> <ul> <li>Abstract Refinements</li> <li>Bounded Refinements</li> </ul> <p>Unfortunately, the best documentation for these two advanced features is the relevant papers at:</p> <ul> <li>ESOP 2013</li> <li>ICFP 2015</li> </ul> <p>The bounds correspond to Horn implications between abstract refinements, which, as in the classical setting, correspond to subtyping constraints that must be satisfied by the concrete refinements used at any call-site.</p>"},{"location":"specifications/#dependent-pairs","title":"Dependent Pairs","text":"<p>Dependent Pairs are expressed by binding the initial tuples of the pair. For example <code>incrPair</code> defines an increasing pair.</p> <pre><code>{-@ incrPair :: Int -&gt; (x::Int, {v:Int | x &lt;= v}) @-}\nincrPair i = (i, i+1)\n</code></pre> <p>Internally dependent pairs are implemented using abstract refinement types. That is <code>(x::a, {v:b | p x})</code> desugars to <code>(a,b)&lt;\\x -&gt; {v:b | p x}&gt;</code>.</p>"},{"location":"specifications/#invariants","title":"Invariants","text":"<p>LH lets you locally associate invariants with specific data types.</p> <p>For example, in tests/measure/pos/Using00.hs every list is treated as a <code>Stream</code>. To establish this local invariant one can use the <code>using</code> declaration</p> <pre><code>{-@ using ([a]) as  {v:[a] | (len v &gt; 0)} @-}\n</code></pre> <p>denoting that each list is not empty.</p> <p>Then, LiquidHaskell will prove that this invariant holds, by proving that all calls to List's constructors (ie., <code>:</code> and <code>[]</code>) satisfy it, and will assume that each list element that is created satisfies this invariant.</p> <p>With this, at the above test LiquidHaskell proves that taking the <code>head</code> of a list is safe. But, at tests/measure/neg/Using00.hs the usage of <code>[]</code> falsifies this local invariant resulting in an \"Invariant Check\" error.</p> <p>WARNING: There is an older global invariant mechanism that attaches a refinement to a datatype globally. Do not use this mechanism -- it is unsound and about to deprecated in favor of something that is actually sound</p> <p>For example,  the length of a list cannot be negative</p> <pre><code>{-@ invariant {v:[a] | (len v &gt;= 0)} @-}\n</code></pre> <p>LiquidHaskell can prove that this invariant holds, by proving that all List's constructors (ie., <code>:</code> and <code>[]</code>) satisfy it.(TODO!) Then, LiquidHaskell assumes that each list element that is created satisfies this invariant.</p>"},{"location":"specifications/#rewriting","title":"Rewriting","text":"<p>Status: <code>experimental</code></p> <p>You use the <code>rewriteWith</code> annotation to indicate equalities that PLE will apply automatically. For example, suppose that you have proven associativity of <code>++</code> for lists.</p> <pre><code>{-@ assoc :: xs:[a] -&gt; ys:[a] -&gt; zs:[a] \n          -&gt; { xs ++ (ys ++ zs) == (xs ++ ys) ++ zs } @-}\n</code></pre> <p>Using the <code>rewriteWith</code> annotation, PLE will automatically apply the equality for associativity whenever it encounters an expression of the form <code>xs ++ (ys ++ zs)</code> or <code>(xs ++ ys) ++ zs</code>. For example, you can prove <code>assoc2</code> for free.</p> <pre><code>{-@ rewriteWith assoc2 [assoc] @-} \n{-@ assoc2 :: xs:[a] -&gt; ys:[a] -&gt; zs:[a] -&gt; ws:[a]\n          -&gt; { xs ++ (ys ++ (zs ++ ws)) == ((xs ++ ys) ++ zs) ++ ws } @-}\nassoc2 :: [a] -&gt; [a] -&gt; [a] -&gt; [a] -&gt; ()\nassoc2 xs ys zs ws = () \n</code></pre> <p>You can also annotate a function as being a global rewrite rule by using the <code>rewrite</code> annotation, in which case PLE will apply it across the entire module.</p> <pre><code>{-@ rewrite assoc @-}\n{-@ assoc :: xs:[a] -&gt; ys:[a] -&gt; zs:[a] \n          -&gt; { xs ++ (ys ++ zs) == (xs ++ ys) ++ zs } @-}\n</code></pre>"},{"location":"specifications/#limitations","title":"Limitations","text":"<p>Currently, rewriting does not work if the equality that uses the rewrite rule includes parameters that contain inner refinements (test).</p> <p>Rewriting works by pattern-matching expressions to determine if there is a variable substitution that would allow it to match against either side of a rewrite rule. If so, that substitution is applied to the opposite side and the corresponding equality is generated. If one side of the equality contains any parameters that are not bound on the other side, it will not be possible to generate a rewrite in that direction, because those variables cannot be instantiated. Likewise, if there are free variables on both sides of an equality, no rewrite can be generated at all (test).</p> <p>It's possible in theory for rewriting rules to diverge. We have a simple check  to ensure that rewriting rules that will always diverge do not get instantiated.  However, it's possible that applying a combination of rewrite rules could cause divergence.</p>"},{"location":"specifications/#formal-grammar-of-refinement-predicates","title":"Formal Grammar of Refinement Predicates","text":""},{"location":"specifications/#constants","title":"(C)onstants","text":"<pre><code>c := 0, 1, 2, ...\n</code></pre>"},{"location":"specifications/#variables","title":"(V)ariables","text":"<pre><code>v := x, y, z, ...\n</code></pre>"},{"location":"specifications/#expressions","title":"(E)xpressions","text":"<pre><code>e := v                      -- variable\n   | c                      -- constant\n   | (e + e)                -- addition\n   | (e - e)                -- subtraction\n   | (c * e)                -- multiplication by constant\n   | (v e1 e2 ... en)       -- uninterpreted function application\n   | (if p then e else e)   -- if-then-else\n</code></pre>"},{"location":"specifications/#relations","title":"(R)elations","text":"<pre><code>r := ==               -- equality\n   | /=               -- disequality\n   | &gt;=               -- greater than or equal\n   | &lt;=               -- less than or equal\n   | &gt;                -- greater than\n   | &lt;                -- less than\n</code></pre>"},{"location":"specifications/#predicates","title":"(P)redicates","text":"<pre><code>p := (e r e)          -- binary relation\n   | (v e1 e2 ... en) -- predicate (or alias) application\n   | (p &amp;&amp; p)         -- and\n   | (p || p)         -- or\n   | (p =&gt; p)         -- implies\n   | (not p)          -- negation\n   | true\n   | false\n</code></pre>"},{"location":"specifications/#specifying-qualifiers","title":"Specifying Qualifiers","text":"<p>There are several ways to specify qualifiers.</p>"},{"location":"specifications/#by-separate-hquals-files","title":"By Separate <code>.hquals</code> Files","text":"<p>You can write qualifier files e.g. Prelude.hquals..</p> <p>If a module is called or imports</p> <pre><code>Foo.Bar.Baz\n</code></pre> <p>Then the system automatically searches for</p> <pre><code>include/Foo/Bar/Baz.hquals\n</code></pre>"},{"location":"specifications/#by-including-hquals-files","title":"By Including <code>.hquals</code> Files","text":"<p>Additional qualifiers may be used by adding lines of the form:</p> <pre><code>{-@ include &lt;path/to/file.hquals&gt; @-}\n</code></pre> <p>to the Haskell source. See, this for example.</p>"},{"location":"specifications/#in-haskell-source-or-spec-files","title":"In Haskell Source or Spec Files","text":"<p>Finally, you can specify qualifiers directly inside source (.hs or .lhs) files by writing them as shown here</p> <pre><code>{-@ qualif Foo(v:Int, a: Int) : (v = a + 100)   @-}\n</code></pre> <p>Note In addition to these, LiquidHaskell scrapes qualifiers from all the specifications you write i.e.</p> <ol> <li>all imported type signatures,</li> <li>measure bodies and,</li> <li>data constructor definitions.</li> </ol>"},{"location":"specifications/#termination-metrics","title":"Termination Metrics","text":"<p>In recursive functions the first algebraic or integer argument should be decreasing.</p> <p>The default decreasing measure for lists is length and Integers its value.</p>"},{"location":"specifications/#default-termination-metrics","title":"Default Termination Metrics","text":"<p>The user can specify the size of a data-type in the data definition</p> <pre><code>{-@ data L [llen] a = Nil | Cons { x::a, xs:: L a} @-}\n</code></pre> <p>In the above, the measure <code>llen</code>, which needs to be defined by the user (see below), is defined as the default metric for the type <code>L a</code>. LH will use this default metric to automatically prove that the following terminates:</p> <pre><code>append :: L a -&gt; L a -&gt; L a  \nappend N           ys = ys\nappend (Cons x xs) ys = Cons x (append xs ys)\n</code></pre> <p>as, by default the first (non-function) argument with an associated size metric is checked to be strictly terminating and non-negative at each recursive call.</p> <p>A default termination metric is a Haskell function that is proved terminating  using structural induction. To deactivate structional induction check on the  termination metric, use the <code>--trust-sizes</code> flag. </p>"},{"location":"specifications/#explicit-termination-metrics","title":"Explicit Termination Metrics","text":"<p>However, consider the function <code>reverse</code>:</p> <pre><code>reverseAcc :: L a -&gt; L a -&gt; L a  \nreverseAcc acc N           = acc\nreverseAcc acc (Cons x xs) = reverseAcc (Cons x acc) xs\n</code></pre> <p>Here, the first argument does not decrease, instead the second does. We can tell LH to use the second argument using the explicit termination metric</p> <pre><code>reverseAcc :: L a -&gt; xs:L a -&gt; L a / [llen xs]  \n</code></pre> <p>which tells LH that the <code>llen</code> of the second argument <code>xs</code> is what decreases at each recursive call.</p> <p>Decreasing expressions can be arbitrary refinement expressions, e.g.,</p> <pre><code>{-@ merge :: Ord a =&gt; xs:L a -&gt; ys:L a -&gt; L a / [llen xs + llen ys] @-}\n</code></pre> <p>states that at each recursive call of <code>merge</code> the sum of the lengths of its arguments will decrease.</p>"},{"location":"specifications/#lexicographic-termination-metrics","title":"Lexicographic Termination Metrics","text":"<p>Some functions do not decrease on a single argument, but rather a combination of arguments, e.g. the Ackermann function.</p> <pre><code>{-@ ack :: m:Int -&gt; n:Int -&gt; Nat / [m, n] @-}\nack m n\n  | m == 0          = n + 1\n  | m &gt; 0 &amp;&amp; n == 0 = ack (m-1) 1\n  | m &gt; 0 &amp;&amp; n &gt;  0 = ack (m-1) (ack m (n-1))\n</code></pre> <p>In all but one recursive call <code>m</code> decreases, in the final call <code>m</code> does not decrease but <code>n</code> does. We can capture this notion of <code>m</code> normally decreases, but if it does not, <code>n</code> will decrease with a lexicographic termination metric <code>[m, n]</code>.</p> <p>An alternative way to express this specification is by annotating the function's type with the appropriate numeric decreasing expressions. As an example, you can give <code>ack</code> a type</p> <pre><code>{-@ ack :: m:Nat -&gt; n:Nat -&gt; Nat / [m,n] @-}\n</code></pre> <p>stating that the numeric expressions <code>[m, n]</code> are lexicographically decreasing.</p>"},{"location":"specifications/#mutually-recursive-functions","title":"Mutually Recursive Functions","text":"<p>When dealing with mutually recursive functions you may run into a situation where the decreasing parameter must be measured across a series of invocations, e.g.</p> <pre><code>even :: Int -&gt; Bool\neven 0 = True\neven n = odd (n-1)\n\nodd :: Int -&gt; Bool\nodd  n = not (even n)\n</code></pre> <p>In this case, you can introduce a ghost parameter that orders the functions</p> <pre><code>{-@ isEven :: n:Nat -&gt; Bool / [n, 0] @-}\nisEven :: Int -&gt; Bool\nisEven 0 = True\nisEven n = isOdd (n-1)\n\n{-@ isOdd :: n:Nat -&gt; Bool / [n, 1] @-}\nisOdd :: Int -&gt; Bool\nisOdd  n = not $ isEven n\n</code></pre> <p>thus recovering a decreasing measure for the pair of functions, the pair of arguments. This can be encoded with the lexicographic termination annotation as shown above. See tests/pos/mutrec.hs for the full example.</p>"},{"location":"specifications/#automatic-termination-metrics","title":"Automatic Termination Metrics","text":"<p>Apart from specifying a specific decreasing measure for an Algebraic Data Type, the user can specify that the ADT follows the expected decreasing measure by</p> <pre><code>{-@ autosize L @-}\n</code></pre> <p>Then, LH will define an instance of the function <code>autosize</code> for <code>L</code> that decreases by 1 at each recursive call and use <code>autosize</code> at functions that recurse on <code>L</code>.</p> <p>For example, <code>autosize L</code> will refine the data constructors of <code>L a</code> with the <code>autosize :: a -&gt; Int</code> information, such that</p> <pre><code>Nil  :: {v:L a | autosize v = 0}\nCons :: x:a -&gt; xs:L a -&gt; {v:L a | autosize v = 1 + autosize xs}\n</code></pre> <p>Also, an invariant that <code>autosize</code> is non negative will be generated</p> <pre><code>invariant  {v:L a| autosize v &gt;= 0 }\n</code></pre> <p>This information is all LiquidHaskell needs to prove termination on functions that recurse on <code>L a</code> (on ADTs in general.)</p>"},{"location":"specifications/#disabling-termination-checking","title":"Disabling Termination Checking","text":"<p>To disable termination checking for <code>foo</code> that is, to assume that it is terminating (possibly for some complicated reason currently beyond the scope of LH) you can write</p> <pre><code>{-@ lazy foo @-}\n</code></pre>"},{"location":"specifications/#relational-types","title":"Relational Types","text":"<p>Status: <code>experimental</code></p> <p>LH supports relational specifications that automatically compare two expressions. The implementation is based on an algorithmic subsystem of Relational Higher-Order Logic.</p>"},{"location":"specifications/#example-proving-monotonicity-of-increment","title":"Example: Proving Monotonicity of Increment","text":"<p>In this example, we are going to prove monotonicity of an increment function. First, we define a function:</p> <pre><code>incr :: Int -&gt; Int \nincr = (+ 1)\n</code></pre> <p>Monotonicity states that for any <code>x1, x2 :: Int</code> such that <code>x1 &lt; x2</code>, inequality <code>incr x1 &lt; incr x2</code> holds. This can be expressed as a comparison property on <code>incr</code>.</p> <pre><code>{-@ relational incr ~ incr :: { x1:Int -&gt; Int \n                              ~ x2:Int -&gt; Int \n                              | x1 &lt; x2 :=&gt; r1 x1 &lt; r2 x2 } @-}\n</code></pre> <p>Relational signature starts with the keyword <code>relational</code>. Next, it contains two functions being compared <code>incr ~ incr</code>. To prove monotonicity, we compare <code>incr</code> to itself. In the general case, it is possible to compare two different functions.</p> <p>Related expressions are followed by their type signatures <code>x1:Int -&gt; Int</code> and <code>x2:Int -&gt; Int</code> separated with a tilde. The last component of the signature is a predicate <code>x1 &lt; x2 :=&gt; r1 x1 &lt; r2 x2</code>. </p> <p>Binders <code>x1</code> and <code>x2</code> refer to the functions' arguments. Keywords <code>r1</code> and <code>r2</code> are aliases for lhs <code>incr</code> and rhs <code>incr</code> respectively. The predicate is logically equivalent to <code>x1 &lt; x2 =&gt; r1 x1 &lt; r2 x2</code>. Implication symbol <code>:=&gt;</code> separates the precondition on the arguments from the postcondition on the return values.</p>"},{"location":"specifications/#relational-predicate-syntax","title":"Relational Predicate Syntax","text":"<p>A relational predicate is a sequence of clauses separated by top-level implication connectives <code>:=&gt;</code> (logically equivalent to <code>=&gt;</code>):</p> <pre><code>x1 &lt; x2 :=&gt; y1 &lt; y2 :=&gt; r1 x1 y1 &lt; r2 x2 y2\n^^^^^^^     ^^^^^^^     ^^^^^^^^^^^^^^^^^^^\n  1st         2nd            3rd clause               \n</code></pre> <ul> <li> <p>Number of Clauses</p> <p>The number of clauses must match the number of arguments of each of the compared expressions. Hence, a relational signature can only be assigned to two expressions with the same number of arguments. </p> <p>```haskell plus :: Int -&gt; Int -&gt; Int  plus = (+)</p> <p>-- clauses == arguments + 1</p> <p>{-@ relational plus ~ plus :: { x1:Int   -&gt; y1:Int   -&gt; Int                                ~ x2:Int   -&gt; y2:Int   -&gt; Int                               | x1 &lt; x2 :=&gt; y1 &lt; y2 :=&gt; r1 x1 y1 &lt; r2 x2 y2 } @-}                                 ^^^^^^^     ^^^^^^^     ^^^^^^^^^^^^^^^^^^^   ```</p> <p>For example, function <code>incr</code> has 1 argument. Its relational predicate has 1 implication that separates the precondition from the postcondition: <code>x1 &lt; x2 :=&gt; r1 x1 &lt; r2 x2</code>. </p> <p>Nested, non-top-level implications are allowed, e.g. <code>(true =&gt; x1 &lt; x2) :=&gt; (r1 x1 &lt; r2 x2)</code>.</p> </li> <li> <p>Argument Scopes</p> <p>Similar to the number of clauses, the order of the argument introduction must match that of the compared functions. A binder that appears in ith clause of the predicate must appear on ith position in the function argument list or earlier.</p> <p>These relational signatures are syntactically invalid: ```haskell -- ERROR: clauses &lt; arguments + 1 </p> <p>{-@ relational plus ~ plus :: { x1:Int -&gt; y1:Int -&gt; Int                                ~ x2:Int -&gt; y2:Int -&gt; Int                               | x1 &lt; x2 &amp;&amp; y1 &lt; y2 :=&gt; r1 x1 y1 &lt; r2 x2 y2 } @-}</p> <p>-- ERROR: y1 and y2 used before their introduction</p> <p>{-@ relational plus ~ plus :: { x1:Int -&gt; y1:Int -&gt; Int                                ~ x2:Int -&gt; y2:Int -&gt; Int                               | y1 &lt; y2 :=&gt; x1 &lt; x2 :=&gt; r1 x1 y1 &lt; r2 x2 y2 } @-}</p> <p>```</p> <p>Correct versions could look like this: ```haskell {-@ relational plus ~ plus :: { x1:Int   -&gt; y1:Int   -&gt; Int                                ~ x2:Int   -&gt; y2:Int   -&gt; Int                               | x1 &lt; x2 :=&gt; y1 &lt; y2 :=&gt; r1 x1 y1 &lt; r2 x2 y2 } @-}</p> <p>{-@ relational plus ~ plus :: { x1:Int -&gt; y1:Int -&gt; Int                                ~ x2:Int -&gt; y2:Int -&gt; Int                               | true :=&gt; x1 &lt; x2 &amp;&amp; y1 &lt; y2 :=&gt; r1 x1 y1 &lt; r2 x2 y2 } @-}</p> <p>{-@ relational plus ~ plus :: { x1:Int -&gt; y1:Int -&gt; Int                                ~ x2:Int -&gt; y2:Int -&gt; Int                               | true :=&gt; true :=&gt; x1 &lt; x2 =&gt; y1 &lt; y2 =&gt; r1 x1 y1 &lt; r2 x2 y2 } @-}  ```</p> </li> </ul>"},{"location":"specifications/#provided-guarantees","title":"Provided Guarantees","text":"<p>For all possible inputs of the two compared functions, it is guaranteed that the relational predicate holds. </p>"},{"location":"specifications/#running-relational-checks","title":"Running Relational Checks","text":"<p>Enable reflection. </p> <p>In the command line:</p> <pre><code>liquid --reflection path/to/File.hs\n</code></pre> <p>Or in a Haskell source file: </p> <pre><code>{-@ LIQUID --reflection @-}\n</code></pre>"},{"location":"specifications/#current-limitations","title":"Current limitations","text":"<ul> <li> <p>No support for abstract refinements. All abstract refinements are erased before relational typechecking. Notably, this happens for the standard list <code>[a]</code> and tuple <code>(a, b)</code> types!</p> </li> <li> <p>Limited support for higher-order relational signatures. Use <code>!=&gt;</code> instead of <code>:=&gt;</code> after the function arguments to enable higher-order checking.</p> </li> </ul>"},{"location":"blogposts/2013-01-01-refinement-types-101.lhs/","title":"Refinement Types 101","text":"<p>One of the great things about Haskell is its brainy type system that allows one to enforce a variety of invariants at compile time, thereby nipping a large swathe of run-time errors in the bud. Refinement types allow us to use modern logic solvers (aka SAT and SMT engines) to dramatically extend the scope of invariants that can be statically verified.</p>","tags":["basic"]},{"location":"blogposts/2013-01-01-refinement-types-101.lhs/#what-is-a-refinement-type","title":"What is a Refinement Type?","text":"<p>In a nutshell, </p> <p> Refinement Types = Types + Logical Predicates </p> <p>That is, refinement types allow us to decorate types with  logical predicates (think boolean-valued Haskell expressions)  which constrain the set of values described by the type, and hence  allow us to specify sophisticated invariants of the underlying values. </p> <p>Say what? </p> <p>(Btw, click the title to demo LiquidHaskell on the code in this article)</p> <pre>42: module Intro where\n43: \n44: import Language.Haskell.Liquid.Prelude  (liquidAssert)\n</pre> <p>Let us jump right in with a simple example, the number <code>0 :: Int</code>.  As far as Haskell is concerned, the number is simply an <code>Int</code> (lets not worry about things like <code>Num</code> for the moment). So are <code>2</code>, <code>7</code>, and  <code>904</code>. With refinements we can dress up these values so that they  stand apart. For example, consider the binder</p> <pre>54: zero' :: Int\n55: {VV : (GHC.Types.Int) | (0 &lt;= VV)}zero' = x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}0\n</pre> <p>We can ascribe to the variable <code>zero'</code> the refinement type</p> <pre>61: {-@ zero' :: {v: Int | 0 &lt;= v} @-}\n</pre> <p>which is simply the basic type <code>Int</code> dressed up with a predicate. The binder <code>v</code> is called the value variable, and so the above denotes  the set of <code>Int</code> values which are greater than <code>0</code>. Of course, we can attach other predicates to the above value, for example</p> <p>Note: We will use <code>@</code>-marked comments to write refinement type  annotations the Haskell source file, making these types, quite literally, machine-checked comments!</p> <pre>75: {-@ zero'' :: {v: Int | (0 &lt;= v &amp;&amp; v &lt; 100) } @-}\n76: zero'' :: Int\n77: {VV : (GHC.Types.Int) | (VV &lt; 100),(0 &lt;= VV)}zero'' = x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}0\n</pre> <p>which states that the number is in the range <code>0</code> to <code>100</code>, or</p> <pre>83: {-@ zero''' :: {v: Int | ((v mod 2) = 0) } @-}\n84: zero''' :: Int\n85: {VV : (GHC.Types.Int) | ((VV mod 2) = 0)}zero''' = x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}0\n</pre> <p>where <code>mod</code> is the modulus operator in the refinement logic. Thus, the type above states that zero is an even number.</p> <p>We can also use a singleton type that precisely describes the constant</p> <pre>94: {-@ zero'''' :: {v: Int | v = 0 } @-}\n95: zero'''' :: Int\n96: {VV : (GHC.Types.Int) | (VV = 0)}zero'''' = x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}0\n</pre> <p>(Aside: we use a different names <code>zero'</code>, <code>zero''</code> etc. for a silly technical  reason -- LiquidHaskell requires that we ascribe a single refinement type to  a top-level name.)</p> <p>Finally, we could write a single type that captures all the properties above:</p> <pre>106: {-@ zero :: {v: Int | ((0 &lt;= v) &amp;&amp; ((v mod 2) = 0) &amp;&amp; (v &lt; 100)) } @-}\n107: zero     :: Int\n108: {VV : (GHC.Types.Int) | ((VV mod 2) = 0),(VV &lt; 100),(0 &lt;= VV)}zero     =  x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}0\n</pre> <p>The key points are:</p> <ol> <li>A refinement type is just a type decorated with logical predicates.</li> <li>A value can have different refinement types that describe different properties.</li> <li>If we erase the green bits (i.e. the logical predicates) we get back exactly     the usual Haskell types that we know and love.</li> <li>A vanilla Haskell type, say <code>Int</code> has the trivial refinement <code>true</code> i.e. is     really <code>{v: Int | true}</code>.</li> </ol> <p>We have built a refinement type-based verifier called LiquidHaskell.  Lets see how we can use refinement types to specify and verify interesting  program invariants in LiquidHaskell.</p>","tags":["basic"]},{"location":"blogposts/2013-01-01-refinement-types-101.lhs/#writing-safety-specifications","title":"Writing Safety Specifications","text":"<p>We can use refinement types to write various kinds of more interesting safety specifications.</p> <p>First, we can write a wrapper around the usual <code>error</code> function </p> <pre>133: {-@ error' :: {v: String | false } -&gt; a  @-}\n134: error'     :: String -&gt; a\n135: {VV : [(GHC.Types.Char)] | false} -&gt; aerror'     = [(GHC.Types.Char)] -&gt; aerror\n</pre> <p>The interesting thing about the type signature for <code>error'</code> is that the input type has the refinement <code>false</code>. That is, the function must only be called with <code>String</code>s that satisfy the predicate <code>false</code>. Of course, there are no such values. Thus, a program containing the above function typechecks exactly when LiquidHaskell can prove that the function <code>error'</code> is never called.</p> <p>Next, we can use refinements to encode arbitrary programmer-specified  assertions by defining a function</p> <pre>149: {-@ lAssert     :: {v:Bool | (Prop v)} -&gt; a -&gt; a  @-}\n150: lAssert         :: Bool -&gt; a -&gt; a \n151: {VV : (GHC.Types.Bool) | (? Prop([VV]))} -&gt; a -&gt; alAssert True  ax = {VV : a | (VV = x)}x\n152: lAssert False _ = {VV : [(GHC.Types.Char)] | false} -&gt; {VV : a | false}error' {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"lAssert failure\" \n</pre> <p>In the refinement, <code>(Prop v)</code> denotes the Haskell <code>Bool</code> value <code>v</code>  interpreted as a logical predicate. In other words, the input type for  this function specifies that the function must only be called with the value <code>True</code>.</p>","tags":["basic"]},{"location":"blogposts/2013-01-01-refinement-types-101.lhs/#refining-function-types-preconditions","title":"Refining Function Types : Preconditions","text":"<p>Lets use the above to write a divide function that only accepts non-zero denominators. </p> <pre>168: divide     :: Int -&gt; Int -&gt; Int\n169: (GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (VV != 0)} -&gt; (GHC.Types.Int)divide (GHC.Types.Int)n 0 = {VV : [(GHC.Types.Char)] | false} -&gt; {VV : (GHC.Types.Int) | false}error' {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"divide by zero\"\n170: divide n d = {VV : (GHC.Types.Int) | (VV = n)}n x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x / y))}`div` {VV : (GHC.Types.Int) | (VV != 0)}d\n</pre> <p>We can specify that the non-zero denominator precondition with a suitable  refinement on the input component of the function's type </p> <pre>177: {-@ divide :: Int -&gt; {v: Int | v != 0 } -&gt; Int @-}\n</pre> <p>How does LiquidHaskell verify the above function? </p> <p>The key step is that LiquidHaskell deduces that the expression  <code>\"divide by zero\"</code> is not merely of type <code>String</code>, but in fact  has the the refined type <code>{v:String | false}</code> in the context  in which the call to <code>error'</code> occurs.</p> <p>LiquidHaskell arrives at this conclusion by using the fact that  in the first equation for <code>divide</code> the denominator parameter  is in fact <code>0 :: {v: Int | v = 0}</code> which contradicts the  precondition (i.e. input) type.</p> <p>In other words, LiquidHaskell deduces by contradiction, that  the first equation is dead code and hence <code>error'</code> will  not be called at run-time.</p> <p>If you are paranoid, you can put in an explicit assertion</p> <pre>199: divide'     :: Int -&gt; Int -&gt; Int\n200: {VV : (GHC.Types.Int) | false}\n-&gt; {VV : (GHC.Types.Int) | false} -&gt; {VV : (GHC.Types.Int) | false}divide' {VV : (GHC.Types.Int) | false}n 0 = {VV : [(GHC.Types.Char)] | false} -&gt; {VV : (GHC.Types.Int) | false}error' {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"divide by zero\"\n201: divide' n d = {VV : (GHC.Types.Bool) | (? Prop([VV]))}\n-&gt; {VV : (GHC.Types.Int) | false} -&gt; {VV : (GHC.Types.Int) | false}lAssert ({VV : (GHC.Types.Int) | false}d x:{VV : (GHC.Types.Int) | false}\n-&gt; y:{VV : (GHC.Types.Int) | false}\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x != y))}/= {VV : (GHC.Types.Int) | (VV = (0  :  int))}0) ({VV : (GHC.Types.Int) | false} -&gt; {VV : (GHC.Types.Int) | false})\n-&gt; {VV : (GHC.Types.Int) | false} -&gt; {VV : (GHC.Types.Int) | false}$ {VV : (GHC.Types.Int) | false}n x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x / y))}`div` {VV : (GHC.Types.Int) | false}d\n</pre> <p>and LiquidHaskell will verify the assertion (by verifying the call to <code>lAssert</code>) for you.</p>","tags":["basic"]},{"location":"blogposts/2013-01-01-refinement-types-101.lhs/#refining-function-types-postconditions","title":"Refining Function Types : Postconditions","text":"<p>Next, lets see how we can use refinements to describe the outputs of a function. Consider the following simple absolute value function</p> <pre>214: abz               :: Int -&gt; Int\n215: (GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (0 &lt;= VV)}abz (GHC.Types.Int)n | {VV : (GHC.Types.Int) | (VV = (0  :  int))}0 x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt; y))}&lt; {VV : (GHC.Types.Int) | (VV = n)}n     = {VV : (GHC.Types.Int) | (VV = n)}n\n216:       | otherwise = {VV : (GHC.Types.Int) | (VV = (0  :  int))}0 x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x - y))}- {VV : (GHC.Types.Int) | (VV = n)}n\n</pre> <p>We can use a refinement on the output type to specify that the function  returns non-negative values</p> <pre>223: {-@ abz :: Int -&gt; {v: Int | 0 &lt;= v } @-}\n</pre> <p>LiquidHaskell verifies that <code>abz</code> indeed enjoys the above type by deducing that <code>n</code> is trivially non-negative when <code>0 &lt; n</code> and that in  the <code>otherwise</code> case, i.e. when <code>not (0 &lt; n)</code> the value <code>0 - n</code> is indeed non-negative (lets not worry about underflows for the moment.) LiquidHaskell is able to automatically make these arithmetic deductions by using an SMT solver which has decision built-in procedures for arithmetic, to reason about the logical refinements.</p>","tags":["basic"]},{"location":"blogposts/2013-01-01-refinement-types-101.lhs/#putting-it-all-together","title":"Putting It All Together","text":"<p>Lets wrap up this introduction with a simple <code>truncate</code> function  that connects all the dots. </p> <pre>244: {-@ truncate :: Int -&gt; Int -&gt; Int @-}\n245: (GHC.Types.Int) -&gt; (GHC.Types.Int) -&gt; (GHC.Types.Int)truncate (GHC.Types.Int)i (GHC.Types.Int)max  \n246:   | {VV : (GHC.Types.Int) | (VV = i'),(0 &lt;= VV)}i' x:{VV : (GHC.Types.Int) | (VV &gt;= 0),(VV &gt;= zero''''),(0 &lt;= VV)}\n-&gt; y:{VV : (GHC.Types.Int) | (VV &gt;= 0),(VV &gt;= zero''''),(0 &lt;= VV)}\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt;= y))}&lt;= {VV : (GHC.Types.Int) | (VV = max'),(0 &lt;= VV)}max' = {VV : (GHC.Types.Int) | (VV = i)}i\n247:   | otherwise  = {VV : (GHC.Types.Int) | (VV = max'),(0 &lt;= VV)}max' x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (&amp;&amp; [(x &gt;= 0); (y &gt;= 0)] =&gt; (VV &gt;= 0))}* ({VV : (GHC.Types.Int) | (VV = i)}i (GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (VV != 0)} -&gt; (GHC.Types.Int)`divide` {VV : (GHC.Types.Int) | (VV = i'),(0 &lt;= VV)}i')\n248:     where {VV : (GHC.Types.Int) | (0 &lt;= VV)}i'   = (GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (0 &lt;= VV)}abz {VV : (GHC.Types.Int) | (VV = i)}i\n249:           {VV : (GHC.Types.Int) | (0 &lt;= VV)}max' = (GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (0 &lt;= VV)}abz {VV : (GHC.Types.Int) | (VV = max)}max \n</pre> <p><code>truncate i n</code> simply returns <code>i</code> if its absolute value is less the upper bound <code>max</code>, and otherwise truncates the value at the maximum. LiquidHaskell verifies that the use of <code>divide</code> is safe by inferring that  at the call site</p> <ol> <li><code>i' &gt; max'</code> from the branch condition.</li> <li><code>0 &lt;= i'</code>   from the <code>abz</code> postcondition (hover mouse over <code>i'</code>).</li> <li><code>0 &lt;= max'</code> from the <code>abz</code> postcondition (hover mouse over <code>max'</code>).</li> </ol> <p>From the above, LiquidHaskell infers that <code>i' != 0</code>. That is, at the call site <code>i' :: {v: Int | v != 0}</code>, thereby satisfying the precondition for <code>divide</code> and verifying that the program has no pesky  divide-by-zero errors. Again, if you really want to make sure, put  in an assertion</p> <pre>268: {-@ truncate' :: Int -&gt; Int -&gt; Int @-}\n269: (GHC.Types.Int) -&gt; (GHC.Types.Int) -&gt; (GHC.Types.Int)truncate' (GHC.Types.Int)i (GHC.Types.Int)max  \n270:   | {VV : (GHC.Types.Int) | (VV = i'),(0 &lt;= VV)}i' x:{VV : (GHC.Types.Int) | (VV &gt;= 0),(VV &gt;= zero''''),(0 &lt;= VV)}\n-&gt; y:{VV : (GHC.Types.Int) | (VV &gt;= 0),(VV &gt;= zero''''),(0 &lt;= VV)}\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt;= y))}&lt;= {VV : (GHC.Types.Int) | (VV = max'),(0 &lt;= VV)}max' = {VV : (GHC.Types.Int) | (VV = i)}i\n271:   | otherwise  = {VV : (GHC.Types.Bool) | (? Prop([VV]))}\n-&gt; (GHC.Types.Int) -&gt; (GHC.Types.Int)lAssert ({VV : (GHC.Types.Int) | (VV = i'),(0 &lt;= VV)}i' x:{VV : (GHC.Types.Int) | (VV &gt;= 0),\n                          (VV &gt;= zero''''),\n                          (0 &lt;= VV),\n                          (VV &lt;= i')}\n-&gt; y:{VV : (GHC.Types.Int) | (VV &gt;= 0),\n                             (VV &gt;= zero''''),\n                             (0 &lt;= VV),\n                             (VV &lt;= i')}\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x != y))}/= {VV : (GHC.Types.Int) | (VV = (0  :  int))}0) ((GHC.Types.Int) -&gt; (GHC.Types.Int))\n-&gt; (GHC.Types.Int) -&gt; (GHC.Types.Int)$ {VV : (GHC.Types.Int) | (VV = max'),(0 &lt;= VV)}max' x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (&amp;&amp; [(x &gt;= 0); (y &gt;= 0)] =&gt; (VV &gt;= 0))}* ({VV : (GHC.Types.Int) | (VV = i)}i (GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (VV != 0)} -&gt; (GHC.Types.Int)`divide` {VV : (GHC.Types.Int) | (VV = i'),(0 &lt;= VV)}i')\n272:     where {VV : (GHC.Types.Int) | (0 &lt;= VV)}i'   = (GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (0 &lt;= VV)}abz {VV : (GHC.Types.Int) | (VV = i)}i\n273:           {VV : (GHC.Types.Int) | (0 &lt;= VV)}max' = (GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (0 &lt;= VV)}abz {VV : (GHC.Types.Int) | (VV = max)}max \n</pre> <p>and lo! LiquidHaskell will verify it for you.</p>","tags":["basic"]},{"location":"blogposts/2013-01-01-refinement-types-101.lhs/#modular-verification","title":"Modular Verification","text":"<p>Incidentally, note the <code>import</code> statement at the top. Rather than rolling our own <code>lAssert</code> we can import and use a pre-defined version <code>liquidAssert</code> defined in an external module</p> <pre>286: {-@ truncate'' :: Int -&gt; Int -&gt; Int @-}\n287: (GHC.Types.Int) -&gt; (GHC.Types.Int) -&gt; (GHC.Types.Int)truncate'' (GHC.Types.Int)i (GHC.Types.Int)max  \n288:   | {VV : (GHC.Types.Int) | (VV = i'),(0 &lt;= VV)}i' x:{VV : (GHC.Types.Int) | (VV &gt;= 0),(VV &gt;= zero''''),(0 &lt;= VV)}\n-&gt; y:{VV : (GHC.Types.Int) | (VV &gt;= 0),(VV &gt;= zero''''),(0 &lt;= VV)}\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt;= y))}&lt;= {VV : (GHC.Types.Int) | (VV = max'),(0 &lt;= VV)}max' = {VV : (GHC.Types.Int) | (VV = i)}i\n289:   | otherwise  = {VV : (GHC.Types.Bool) | (? Prop([VV]))}\n-&gt; (GHC.Types.Int) -&gt; (GHC.Types.Int)liquidAssert ({VV : (GHC.Types.Int) | (VV = i'),(0 &lt;= VV)}i' x:{VV : (GHC.Types.Int) | (VV &gt;= 0),\n                          (VV &gt;= zero''''),\n                          (0 &lt;= VV),\n                          (VV &lt;= i')}\n-&gt; y:{VV : (GHC.Types.Int) | (VV &gt;= 0),\n                             (VV &gt;= zero''''),\n                             (0 &lt;= VV),\n                             (VV &lt;= i')}\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x != y))}/= {VV : (GHC.Types.Int) | (VV = (0  :  int))}0) ((GHC.Types.Int) -&gt; (GHC.Types.Int))\n-&gt; (GHC.Types.Int) -&gt; (GHC.Types.Int)$ {VV : (GHC.Types.Int) | (VV = max'),(0 &lt;= VV)}max' x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (&amp;&amp; [(x &gt;= 0); (y &gt;= 0)] =&gt; (VV &gt;= 0))}* ({VV : (GHC.Types.Int) | (VV = i)}i (GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (VV != 0)} -&gt; (GHC.Types.Int)`divide` {VV : (GHC.Types.Int) | (VV = i'),(0 &lt;= VV)}i')\n290:     where {VV : (GHC.Types.Int) | (0 &lt;= VV)}i'   = (GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (0 &lt;= VV)}abz {VV : (GHC.Types.Int) | (VV = i)}i\n291:           {VV : (GHC.Types.Int) | (0 &lt;= VV)}max' = (GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (0 &lt;= VV)}abz {VV : (GHC.Types.Int) | (VV = max)}max \n</pre> <p>In fact, LiquidHaskell comes equipped with suitable refinements for standard functions and it is easy to add refinements as we shall demonstrate in subsequent articles.</p>","tags":["basic"]},{"location":"blogposts/2013-01-01-refinement-types-101.lhs/#conclusion","title":"Conclusion","text":"<p>This concludes our quick introduction to Refinement Types and LiquidHaskell. Hopefully you have some sense of how to </p> <ol> <li>Specify fine-grained properties of values by decorating their    types with logical predicates.</li> <li>Encode assertions, preconditions, and postconditions with suitable    function types.</li> <li>Verify semantic properties of code by using automatic logic engines     (SMT solvers) to track and establish the key relationships between     program values.</li> </ol>","tags":["basic"]},{"location":"blogposts/2013-01-27-refinements101-reax.lhs/","title":"Refinements 101 (contd.)","text":"<p>Hopefully, the previous article gave you a basic idea about what refinement types look like. Several folks had interesting questions, that are worth discussing in a separate post, since they throw a lot of light  on the strengths (or weaknesses, depending on your point of view!) of LiquidHaskell.</p> <pre>22: module Refinements101Reax where\n</pre>","tags":["basic"]},{"location":"blogposts/2013-01-27-refinements101-reax.lhs/#how-to-relate-outputs-and-inputs","title":"How to relate outputs and inputs","text":"<p>Recall the function <code>divide</code></p> <pre>31: {-@ divide :: Int -&gt; {v: Int | v /= 0 } -&gt; Int @-}\n32: divide     :: Int -&gt; Int -&gt; Int\n33: (GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (VV != 0)} -&gt; (GHC.Types.Int)divide (GHC.Types.Int)n 0 = [(GHC.Types.Char)] -&gt; {VV : (GHC.Types.Int) | false}error {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"divide by zero\"\n34: divide n d = {VV : (GHC.Types.Int) | (VV = n)}n x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x / y))}`div` {VV : (GHC.Types.Int) | (VV != 0)}d\n</pre> <p>and <code>abz</code> was the absolute value function</p> <pre>40: abz               :: Int -&gt; Int\n41: x:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | ((VV = 0) &lt;=&gt; (x = 0)),(0 &lt;= VV)}abz (GHC.Types.Int)n | {VV : (GHC.Types.Int) | (VV = (0  :  int))}0 x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt; y))}&lt; {VV : (GHC.Types.Int) | (VV = n)}n     = {VV : (GHC.Types.Int) | (VV = n)}n\n42:       | otherwise = {VV : (GHC.Types.Int) | (VV = (0  :  int))}0 x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x - y))}- {VV : (GHC.Types.Int) | (VV = n)}n\n</pre> <p>nanothief remarked that LiquidHaskell was unable to verify the safety of the following call to <code>divide</code> (i.e. was unable to show that <code>x</code> was non-zero at the callsite).</p> <pre>50: {-@ f :: Int -&gt; Int @-}\n51: (GHC.Types.Int) -&gt; (GHC.Types.Int)f (GHC.Types.Int)x | x:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | ((VV = 0) &lt;=&gt; (x = 0)),(0 &lt;= VV)}abz {VV : (GHC.Types.Int) | (VV = x)}x x:{VV : (GHC.Types.Int) | (VV &gt;= 0),(0 &lt;= VV)}\n-&gt; y:{VV : (GHC.Types.Int) | (VV &gt;= 0),(0 &lt;= VV)}\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x = y))}== {VV : (GHC.Types.Int) | (VV = (0  :  int))}0 = x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}3\n52:     | otherwise  = {VV : (GHC.Types.Int) | (VV = (3  :  int))}3 (GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (VV != 0)} -&gt; (GHC.Types.Int)`divide` {VV : (GHC.Types.Int) | (VV = x)}x\n</pre> <p>Nanothief correctly argues that the code is clearly safe as \"<code>abz x == 0</code> being false implies <code>x /= 0</code>\".  Indeed, the code is safe, however, the reason that LiquidHaskell rejected it has nothing to do with its inability to  \"track the constraints of values based on tests using new values derived from that value\" as Nanothief surmised, but instead, because LiquidHaskell supports modular verification  where the only thing known about <code>abz</code> at a use site is  whatever is specified in its type. </p> <p>Concretely speaking, the type </p> <pre>64: abz :: Int -&gt; {v: Int | 0 &lt;= v }\n</pre> <p>is too anemic to verify <code>f</code> above, as it tells us nothing  about the relationship between the output and input -- looking at it, we have now way of telling that when the output (of <code>abz</code>) is  non-zero, the input  must also have been non-zero.</p> <p>Instead, we can write a stronger type which does capture this information, for example</p> <pre>73: abz :: x:Int -&gt; {v:Int | v = (if (x &gt; 0) then x else (0 - x))}\n</pre> <p>where </p> <pre>77: v = (if p then e1 else e2)\n</pre> <p>is an abbreviation for the formula </p> <pre>81: (p =&gt; v == e1) &amp;&amp; ((not p) =&gt; v = e2)\n</pre> <p>With this specification for <code>abz</code>, LiquidHaskell is able to reason that when <code>abz x</code> is non-zero, <code>x</code> is also non-zero. Of course, <code>abz</code> is trivial  enough that we can very precisely capture its exact semantics in the  refinement type, but thats is rarely the case. </p> <p>Nevertheless, even here, you could write a somewhat weaker specification, that still had enough juice to allow the verification of the <code>divide</code> call in <code>f</code>. In particular, we might write</p> <pre>94: {-@ abz :: x:Int -&gt; {v:Int | ((0 &lt;= v) &amp;&amp; ((v = 0) &lt;=&gt; (x = 0))) } @-}\n</pre> <p>which states the output is <code>0</code> if and only if the input is <code>0</code>. LiquidHaskell will happily verify that <code>abz</code> implements this specification, and will use it to verify the safety of <code>f</code> above.</p> <p>(BTW, follow the link above to demo this code  yourself.)</p>","tags":["basic"]},{"location":"blogposts/2013-01-27-refinements101-reax.lhs/#how-to-tell-a-fib","title":"How to tell a Fib","text":"<p>Chris Done asked why LiquidHaskell refused to verify the following definition of <code>fib</code>.</p> <pre>110: {-@ fib :: n:Int -&gt; { b:Int | (n &gt;= 0 &amp;&amp; b &gt;= n) } @-}\n111: fib :: Int -&gt; Int\n112: n:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV &gt;= n),(n &gt;= 0)}fib 0 = x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}0\n113: fib 1 = x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}1\n114: fib n = n:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV &gt;= n),(n &gt;= 0)}fib ((GHC.Types.Int)nx:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x - y))}-{VV : (GHC.Types.Int) | (VV = (1  :  int))}1) x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x + y))}+ n:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV &gt;= n),(n &gt;= 0)}fib ((GHC.Types.Int)nx:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x - y))}-{VV : (GHC.Types.Int) | (VV = (2  :  int))}2)\n</pre> <p>Indeed, the both the specification and the implementation look pretty legit, so what gives?  It turns out that there are two different reasons why. </p> <p>Reason 1: Assumptions vs. Guarantees</p> <p>What we really want to say over here is that the input <code>n</code>  is non-negative. However, putting the refinement <code>n &gt;= 0</code> in  the output constraint means that it becomes something that  LiquidHaskell checks that the function <code>fib</code> guarantees  (or ensures). That is, the type states that we can pass <code>fib</code> any value  <code>n</code> (including negative values) and yet, <code>fib</code> must return  values <code>b</code> such that <code>b &gt;= n</code> and <code>n &gt;= 0</code>. </p> <p>The latter requirement is a rather tall order when an arbitrary <code>n</code>  is passed in as input. <code>fib</code> can make no such guarantees since  it was given the value <code>n</code> as a parameter. The only way <code>n</code> could  be non-negative was that if the caller had sent in a non-negative value.  Thus, we want to put the burden of proof on the right entity here,  namely the caller.</p> <p>To assign the burden of proof appropriately, we place the non-negative refinement on the input type</p> <pre>142: {-@ fib' :: n:{v:Int | v &gt;= 0} -&gt; {b:Int | (n &gt;= 0 &amp;&amp; b &gt;= n) } @-}\n143: fib' :: Int -&gt; Int\n144: n:{VV : (GHC.Types.Int) | (VV &gt;= 0)}\n-&gt; {VV : (GHC.Types.Int) | (VV &gt;= n),(n &gt;= 0)}fib' 0 = x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}0\n145: fib' 1 = x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}1\n146: fib' n = n:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV &gt;= n),(n &gt;= 0)}fib ({VV : (GHC.Types.Int) | (VV &gt;= 0)}nx:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x - y))}-{VV : (GHC.Types.Int) | (VV = (1  :  int))}1) x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x + y))}+ n:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV &gt;= n),(n &gt;= 0)}fib ({VV : (GHC.Types.Int) | (VV &gt;= 0)}nx:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x - y))}-{VV : (GHC.Types.Int) | (VV = (2  :  int))}2)\n</pre> <p>where now at calls to <code>fib'</code> LiquidHaskell will check that the argument is non-negative, and furthermore, when checking <code>fib'</code> LiquidHaskell will  assume that the parameter <code>n</code> is indeed non-negative. So now the constraint <code>n &gt;= 0</code> on the output is somewhat redundant, and the non-negative <code>n</code> guarantee holds trivially.</p> <p>Reason 2: The Specification is a Fib</p> <p>If you run the above in the demo, you will see that LiquidHaskell still doth protest loudly, and frankly, one might start getting a little frustrated at the stubbornness and petulance of the checker.</p> <p>However, if you stare at the implementation, you will see that it in fact, does not meet the specification, as</p> <pre>162: fib' 2  == fib' 1 + fib' 0\n163:         == 0 + 1\n164:         == 1\n</pre> <p>LiquidHaskell is reluctant to prove things that are false. Rather than  anthropomorphize frivolously, lets see why it is unhappy. </p> <p>First, recall the somewhat simplified specification </p> <pre>171: fib' :: n:Int -&gt; { b:Int | (b &gt;= n) } \n</pre> <p>As we saw in the discussion about <code>abz</code>, at each recursive callsite the only information LiquidHaskell uses about the returned value,  is that described in the output type for that function call.</p> <p>Thus, LiquidHaskell reasons that the expression:</p> <pre>179: fib' (n-1) + fib' (n-2)\n</pre> <p>has the type</p> <pre>183: {b: Int | exists b1, b2. b  == b1 + b2 \n184:                       &amp;&amp; b1 &gt;= n-1 \n185:                       &amp;&amp; b2 &gt;= n-2     }\n</pre> <p>where the <code>b1</code> and <code>b2</code> denote the values returned by the  recursive calls --- we get the above by plugging the parameters <code>n-1</code> and <code>n-2</code> in for the parameter <code>n</code> in output type for <code>fib'</code>.</p> <p>The SMT solver simplifies the above to</p> <pre>193: {b: Int | b &gt;= 2n - 3}\n</pre> <p>Finally, to check the output guarantee is met, LiquidHaskell asks the SMT solver to prove that</p> <pre>197: (b &gt;= 2n - 2)  =&gt;  (b &gt;= n)\n</pre> <p>The SMT solver will refuse, of course, since the above implication is  not valid (e.g. when <code>n</code> is <code>2</code>) Thus, via SMT, LiquidHaskell proclaims that the function <code>fib'</code> does not implement the advertised type and hence marks it unsafe.</p>","tags":["basic"]},{"location":"blogposts/2013-01-27-refinements101-reax.lhs/#fixing-the-code","title":"Fixing The Code","text":"<p>How then, do we get Chris' specification to work out? It seems like it  should hold (except for that pesky case where <code>n=2</code>. Indeed, let's rig the code, so that all the base cases return <code>1</code>.</p> <pre>213: {-@ fibOK :: n:Int -&gt; {b:Int | ((b &gt;= n) &amp;&amp; (b &gt;= 1))} @-}\n214: fibOK :: Int -&gt; Int\n215: n:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV &gt;= 1),(VV &gt;= n)}fibOK 0 = x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}1\n216: fibOK 1 = x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}1\n217: fibOK n = n:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV &gt;= 1),(VV &gt;= n)}fibOK ((GHC.Types.Int)nx:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x - y))}-{VV : (GHC.Types.Int) | (VV = (1  :  int))}1) x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x + y))}+ n:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV &gt;= 1),(VV &gt;= n)}fibOK ((GHC.Types.Int)nx:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x - y))}-{VV : (GHC.Types.Int) | (VV = (2  :  int))}2)\n</pre> <p>Here' we specify that not only is the output greater than the input, it is also greater than <code>1</code>. </p> <p>Now in the recursive case, LiquidHaskell reasons that the value being output is</p> <pre>224: {b: Int | exists b1, b2. b  == b1 + b2 \n225:                       &amp;&amp; b1 &gt;= n-1 &amp;&amp; b1 &gt;= 1 \n226:                       &amp;&amp; b2 &gt;= n-2 &amp;&amp; b2 &gt;= 1 }\n</pre> <p>which reduces to </p> <pre>230: {b: Int | b = 2n - 3 &amp;&amp; n &gt;= 2 }\n</pre> <p>which, the SMT solver is happy to verify, is indeed a subtype</p> <pre>234: of (i.e. implies the refinement of) the specified output\n235: {b: Int | b &gt;= n &amp;&amp; b &gt;= 1 } \n</pre>","tags":["basic"]},{"location":"blogposts/2013-01-27-refinements101-reax.lhs/#conclusion","title":"Conclusion","text":"<p>There are several things to take away. </p> <ol> <li> <p>We need to distinguish between assumptions and guarantees     when writing specifications for functions.</p> </li> <li> <p>For modularity, LiquidHaskell, like every type system, uses only    the (refinement) type  of each function at each use site, and not the     function's body.</p> </li> <li> <p>Some seemingly intuitive specifications often aren't; in future work it    would be useful to actually generate tests as     counterexamples that illustrate when a specification    fails.</p> </li> </ol>","tags":["basic"]},{"location":"blogposts/2013-01-28-bounding-vectors.lhs/","title":"Bounding Vectors","text":"<p>Hopefully, these [articlesref102 gave you a basic idea about  what basic refinement types look like. Today, lets move on to some  fancier properties, namely, the static verification of  vector access bounds. Along the way, we'll see some examples that illustrate how LiquidHaskell reasons about recursion,  higher-order functions, data types, and polymorphism.</p> <pre>23: module VectorBounds (\n24:     safeLookup \n25:   , unsafeLookup, unsafeLookup'\n26:   , absoluteSum, absoluteSum'\n27:   , dotProduct\n28:   , sparseProduct, sparseProduct'\n29:   ) where\n30: \n31: import Prelude      hiding (length)\n32: import Data.List    (foldl')\n33: import Data.Vector  hiding (foldl') \n</pre>","tags":["basic"]},{"location":"blogposts/2013-01-28-bounding-vectors.lhs/#specifying-bounds-for-vectors","title":"Specifying Bounds for Vectors","text":"<p>One classical use-case for refinement types is to verify the safety of accesses of arrays and vectors and such, by proving that the  indices used in such accesses are within the vector bounds.  In this article, we will illustrate this use case by writing a few short functions that manipulate vectors, in particular, those from the popular vector library. </p> <p>To start off, lets specify bounds safety by refining the types for the key functions exported by the module <code>Data.Vector</code>. </p> <p>Specifications for <code>Data.Vector</code></p> <pre>50: module spec Data.Vector where\n51: \n52: import GHC.Base\n53: \n54: measure vlen    ::   (Vector a) -&gt; Int \n55: assume length   :: x:(Vector a) -&gt; {v : Int | v = (vlen x)}\n56: assume !        :: x:(Vector a) -&gt; {v : Int | ((0 &lt;= v) &amp;&amp; (v &lt; (vlen x))) } -&gt; a \n</pre> <p>In particular, we </p> <ul> <li>define a property called <code>vlen</code> which denotes the size of the vector,</li> <li>assume that the <code>length</code> function returns an integer equal to the vector's size, and</li> <li>assume that the lookup function <code>!</code> requires an index between <code>0</code> and the vector's size.</li> </ul> <p>There are several things worth paying close attention to in the above snippet.</p> <p>Measures</p> <p>Measures define auxiliary (or so-called ghost) properties of data values that are useful for specification and verification, but which  don't actually exist at run-time. Thus, they will only appear in specifications, i.e. inside type refinements, but never inside code. Often we will use helper functions like <code>length</code> in this case, which pull or materialize the ghost values from the refinement world into the actual code world.</p> <p>Assumes</p> <p>We write <code>assume</code> because in this scenario we are not verifying the implementation of <code>Data.Vector</code>, we are simply using the properties of the library to verify client code.  If we wanted to verify the library itself, we would ascribe the above types to the relevant functions in the Haskell source for <code>Data.Vector</code>. </p> <p>Dependent Refinements</p> <p>Notice that in the function type (e.g. for <code>length</code>) we have named the input parameter <code>x</code> so that we can refer to it in the output refinement. </p> <p>In this case, the type </p> <pre>90: assume length   :: x:(Vector a) -&gt; {v : Int | v = (vlen x)}\n</pre> <p>states that the <code>Int</code> output is exactly equal to the size of the input <code>Vector</code> named <code>x</code>.</p> <p>In other words, the output refinement depends on the input value, which crucially allows us to write properties that relate different program values.</p> <p>Verifying a Simple Wrapper</p> <p>Lets try write some simple functions to sanity check the above specifications.  First, consider an unsafe vector lookup function:</p> <pre>104: forall a.\nvec:(Vector a) -&gt; {VV : (Int) | (VV &lt; vlen([vec])),(0 &lt;= VV)} -&gt; aunsafeLookup (Vector a)vec {VV : (Int) | (VV &gt;= 0),(VV &lt; vlen([vec])),(0 &lt;= VV)}index = {VV : (Vector a) | (VV = vec),(vlen([VV]) &gt;= 0)}vec x:(Vector a) -&gt; {VV : (Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; a! {VV : (Int) | (VV = index),(VV &gt;= 0),(VV &lt; vlen([vec])),(0 &lt;= VV)}index\n</pre> <p>If we run this through LiquidHaskell, it will spit back a type error for the expression <code>x ! i</code> because (happily!) it cannot prove that <code>index</code> is between <code>0</code> and the <code>vlen vec</code>. Of course, we can specify the bounds  requirement in the input type</p> <pre>113: {-@ unsafeLookup :: vec:Vector a \n114:                  -&gt; {v: Int | (0 &lt;= v &amp;&amp; v &lt; (vlen vec))} \n115:                  -&gt; a \n116:   @-}\n</pre> <p>then LiquidHaskell is happy to verify the lookup. Of course, now the burden of ensuring the index is valid is pushed to clients of <code>unsafeLookup</code>.</p> <p>Instead, we might write a safe lookup function that performs the bounds check before looking up the vector:</p> <pre>126: forall a.\n{VV : (Vector {VV : a | false}) | false}\n-&gt; {VV : (Int) | false} -&gt; {VV : (Maybe {VV : a | false}) | false}safeLookup {VV : (Vector {VV : a | false}) | false}x {VV : (Int) | false}i \n127:   | {VV : (Int) | (VV = (0  :  int))}0 x:{VV : (Int) | false}\n-&gt; y:{VV : (Int) | false}\n-&gt; {VV : (Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt;= y))}&lt;= {VV : (Int) | false}i x:(Bool)\n-&gt; y:(Bool)\n-&gt; {VV : (Bool) | ((? Prop([VV])) &lt;=&gt; &amp;&amp; [(? Prop([x]));\n                                          (? Prop([y]))])}&amp;&amp; {VV : (Int) | false}i x:{VV : (Int) | false}\n-&gt; y:{VV : (Int) | false}\n-&gt; {VV : (Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt; y))}&lt; x:(Vector {VV : a | false})\n-&gt; {VV : (Int) | (VV = vlen([x])),(VV &gt;= 0)}length {VV : (Vector {VV : a | false}) | false}x = x:{VV : a | false}\n-&gt; {VV : (Maybe {VV : a | false}) | ((? isJust([VV])) &lt;=&gt; true),\n                                    (fromJust([VV]) = x)}Just ({VV : (Vector {VV : a | false}) | false}x x:(Vector {VV : a | false})\n-&gt; {VV : (Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; {VV : a | false}! {VV : (Int) | false}i)\n128:   | otherwise              = {VV : (Maybe {VV : a | false}) | ((? isJust([VV])) &lt;=&gt; false)}Nothing \n</pre> <p>Predicate Aliases</p> <p>The type for <code>unsafeLookup</code> above is rather verbose as we have to spell out the upper and lower bounds and conjoin them. Just as we enjoy abstractions when programming, we will find it handy to have abstractions in the specification mechanism. To this end, LiquidHaskell supports  predicate aliases, which are best illustrated by example</p> <pre>140: {-@ predicate Btwn Lo I Hi = (Lo &lt;= I &amp;&amp; I &lt; Hi) @-}\n141: {-@ predicate InBounds I A = (Btwn 0 I (vlen A)) @-}\n</pre> <p>Now, we can simplify the type for the unsafe lookup function to</p> <pre>147: {-@ unsafeLookup' :: x:Vector a -&gt; {v:Int | (InBounds v x)} -&gt; a @-}\n148: unsafeLookup' :: Vector a -&gt; Int -&gt; a\n149: forall a.\nx:(Vector a) -&gt; {VV : (Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; aunsafeLookup' (Vector a)x {VV : (Int) | (VV &gt;= 0),(VV &lt; vlen([x])),(0 &lt;= VV)}i = {VV : (Vector a) | (VV = x),(vlen([VV]) &gt;= 0)}x x:(Vector a) -&gt; {VV : (Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; a! {VV : (Int) | (VV = i),(VV &gt;= 0),(VV &lt; vlen([x])),(0 &lt;= VV)}i\n</pre>","tags":["basic"]},{"location":"blogposts/2013-01-28-bounding-vectors.lhs/#our-first-recursive-function","title":"Our First Recursive Function","text":"<p>OK, with the tedious preliminaries out of the way, lets write some code!</p> <p>To start: a vanilla recursive function that adds up the absolute values of the elements of an integer vector.</p> <pre>162: absoluteSum       :: Vector Int -&gt; Int \n163: (Vector (Int)) -&gt; {VV : (Int) | (0 &lt;= VV)}absoluteSum (Vector (Int))vec   = x:(Int#) -&gt; {VV : (Int) | (VV = (x  :  int))}if {VV : (Int) | (VV = (0  :  int))}0 x:{VV : (Int) | (VV &gt;= 0),(0 &lt;= VV),(VV &lt;= n),(VV &lt;= vlen([vec]))}\n-&gt; y:{VV : (Int) | (VV &gt;= 0),\n                   (0 &lt;= VV),\n                   (VV &lt;= n),\n                   (VV &lt;= vlen([vec]))}\n-&gt; {VV : (Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt; y))}&lt; {VV : (Int) | (VV = n),(VV = vlen([vec])),(VV &gt;= 0)}n then x6:{VV : (Int) | (VV = 0),(VV &lt; n),(VV &lt; vlen([vec])),(0 &lt;= VV)}\n-&gt; x4:{VV : (Int) | (VV = 0),\n                    (VV = x6),\n                    (VV &lt; n),\n                    (VV &lt; vlen([vec])),\n                    (0 &lt;= VV),\n                    (x6 &lt;= VV)}\n-&gt; {VV : (Int) | (VV &gt;= 0),\n                 (VV &gt;= x6),\n                 (VV &gt;= x4),\n                 (0 &lt;= VV),\n                 (x6 &lt;= VV),\n                 (x4 &lt;= VV)}go {VV : (Int) | (VV = (0  :  int))}0 {VV : (Int) | (VV = (0  :  int))}0 else x:(Int#) -&gt; {VV : (Int) | (VV = (x  :  int))}0\n164:   where\n165:     x6:{VV : (Int) | (VV = 0),(VV &lt; n),(VV &lt; vlen([vec])),(0 &lt;= VV)}\n-&gt; x4:{VV : (Int) | (VV = 0),\n                    (VV = x6),\n                    (VV &lt; n),\n                    (VV &lt; vlen([vec])),\n                    (0 &lt;= VV),\n                    (x6 &lt;= VV)}\n-&gt; {VV : (Int) | (VV &gt;= 0),\n                 (VV &gt;= x6),\n                 (VV &gt;= x4),\n                 (0 &lt;= VV),\n                 (x6 &lt;= VV),\n                 (x4 &lt;= VV)}go {VV : (Int) | (VV &gt;= 0),(0 &lt;= VV)}acc {VV : (Int) | (VV &gt;= 0),\n              (0 &lt;= VV),\n              (VV &lt;= n),\n              (VV &lt;= vlen([vec])),\n              (VV &lt;= vlen([vec]))}i \n166:       | {VV : (Int) | (VV = i),\n              (VV &gt;= 0),\n              (0 &lt;= VV),\n              (VV &lt;= n),\n              (VV &lt;= vlen([vec])),\n              (VV &lt;= vlen([vec]))}i x:{VV : (Int) | (VV &gt;= 0),\n                (VV &gt;= i),\n                (0 &lt;= VV),\n                (VV &lt;= n),\n                (VV &lt;= vlen([vec])),\n                (VV &lt;= vlen([vec])),\n                (i &lt;= VV)}\n-&gt; y:{VV : (Int) | (VV &gt;= 0),\n                   (VV &gt;= i),\n                   (0 &lt;= VV),\n                   (VV &lt;= n),\n                   (VV &lt;= vlen([vec])),\n                   (VV &lt;= vlen([vec])),\n                   (i &lt;= VV)}\n-&gt; {VV : (Bool) | ((? Prop([VV])) &lt;=&gt; (x != y))}/= {VV : (Int) | (VV = n),(VV = vlen([vec])),(VV &gt;= 0)}n    = x6:{VV : (Int) | (VV = 0),(VV &lt; n),(VV &lt; vlen([vec])),(0 &lt;= VV)}\n-&gt; x4:{VV : (Int) | (VV = 0),\n                    (VV = x6),\n                    (VV &lt; n),\n                    (VV &lt; vlen([vec])),\n                    (0 &lt;= VV),\n                    (x6 &lt;= VV)}\n-&gt; {VV : (Int) | (VV &gt;= 0),\n                 (VV &gt;= x6),\n                 (VV &gt;= x4),\n                 (0 &lt;= VV),\n                 (x6 &lt;= VV),\n                 (x4 &lt;= VV)}go ({VV : (Int) | (VV = acc),(VV &gt;= 0),(0 &lt;= VV)}acc x:(Int) -&gt; y:(Int) -&gt; {VV : (Int) | (VV = (x + y))}+ n:(Int) -&gt; {VV : (Int) | (VV &gt;= 0),(VV &gt;= n)}abz ({VV : (Vector (Int)) | (VV = vec),\n                       (VV = vec),\n                       (vlen([VV]) = vlen([vec])),\n                       (vlen([VV]) &gt;= 0)}vec x:(Vector (Int))\n-&gt; {VV : (Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; (Int)! {VV : (Int) | (VV = i),\n              (VV &gt;= 0),\n              (0 &lt;= VV),\n              (VV &lt;= n),\n              (VV &lt;= vlen([vec])),\n              (VV &lt;= vlen([vec]))}i)) ({VV : (Int) | (VV = i),\n              (VV &gt;= 0),\n              (0 &lt;= VV),\n              (VV &lt;= n),\n              (VV &lt;= vlen([vec])),\n              (VV &lt;= vlen([vec]))}i x:(Int) -&gt; y:(Int) -&gt; {VV : (Int) | (VV = (x + y))}+ {VV : (Int) | (VV = (1  :  int))}1)\n167:       | otherwise = {VV : (Int) | (VV = acc),(VV &gt;= 0),(0 &lt;= VV)}acc \n168:     {VV : (Int) | (VV = vlen([vec])),(VV &gt;= 0)}n             = x:(Vector (Int)) -&gt; {VV : (Int) | (VV = vlen([x])),(VV &gt;= 0)}length {VV : (Vector (Int)) | (VV = vec),\n                       (VV = vec),\n                       (vlen([VV]) = vlen([vec])),\n                       (vlen([VV]) &gt;= 0)}vec\n</pre> <p>where the function <code>abz</code> is the absolute value function from before.</p> <pre>174: forall a.\n(Num a) -&gt; (Ord a) -&gt; n:a -&gt; {VV : a | (VV &gt;= 0),(VV &gt;= n)}abz an = {VV : (Integer) | (VV = 0)}if a0 x:a -&gt; y:a -&gt; {VV : (Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt;= y))}&lt;= {VV : a | (VV = n)}n then {VV : a | (VV = n)}n else (a0 x:a -&gt; y:a -&gt; {VV : a | (VV = (x - y))}- {VV : a | (VV = n)}n) \n</pre>","tags":["basic"]},{"location":"blogposts/2013-01-28-bounding-vectors.lhs/#digression-introducing-errors","title":"Digression: Introducing Errors","text":"<p>If you are following along in the demo page -- I heartily  recommend that you try the following modifications,  one at a time, and see what happens.</p> <p>What happens if: </p> <ul> <li> <p>You remove the check <code>0 &lt; n</code> </p> </li> <li> <p>You replace the guard with <code>i &lt;= n</code></p> </li> </ul> <p>In each case, LiquidHaskell will grumble that your program is unsafe.  Do you understand why?</p>","tags":["basic"]},{"location":"blogposts/2013-01-28-bounding-vectors.lhs/#refinement-type-inference","title":"Refinement Type Inference","text":"<p>LiquidHaskell happily verifies <code>absoluteSum</code> -- or, to be precise,  the safety of the vector accesses <code>vec ! i</code>. The verification works  out because LiquidHaskell is able automatically infer a suitable  type for <code>go</code>. Shuffle your mouse over the identifier above to see  the inferred type. Observe that the type states that The first parameter <code>acc</code> (and the output) is <code>0 &lt;= V</code>.  That is, the returned value is non-negative.</p> <p>More importantly, the type states that the second parameter <code>i</code> is  <code>0 &lt;= V</code> and <code>V &lt;= n</code> and <code>V &lt;= (vlen vec)</code>. That is, the parameter <code>i</code>  is between <code>0</code> and the vector length (inclusive). LiquidHaskell uses these  and the test that <code>i /= n</code> to establish that <code>i</code> is in fact between <code>0</code>  and <code>(vlen vec)</code> thereby verifing safety. </p> <p>In fact, if we want to use the function externally (i.e. in another module)  we can go ahead and strengthen its type to specify that the output is  non-negative.</p> <pre>215: {-@ absoluteSum :: Vector Int -&gt; {v: Int | 0 &lt;= v}  @-} \n</pre> <p>What happens if: You replace the output type for <code>absoluteSum</code> with <code>{v: Int | 0 &lt; v }</code> ?</p>","tags":["basic"]},{"location":"blogposts/2013-01-28-bounding-vectors.lhs/#bottling-recursion-with-a-higher-order-loop","title":"Bottling Recursion With a Higher-Order <code>loop</code>","text":"<p>Next, lets refactor the above low-level recursive function  into a generic higher-order <code>loop</code>.</p> <pre>227: loop :: Int -&gt; Int -&gt; a -&gt; (Int -&gt; a -&gt; a) -&gt; a \n228: forall a.\nlo:{VV : (Int) | (0 &lt;= VV)}\n-&gt; hi:{VV : (Int) | (0 &lt;= VV),(lo &lt;= VV)}\n-&gt; a\n-&gt; ({VV : (Int) | (VV &lt; hi),(lo &lt;= VV)} -&gt; a -&gt; a)\n-&gt; aloop {VV : (Int) | (VV &gt;= 0),(0 &lt;= VV)}lo {VV : (Int) | (VV &gt;= 0),(VV &gt;= lo),(0 &lt;= VV),(lo &lt;= VV)}hi abase {VV : (Int) | (VV &gt;= 0),(VV &gt;= lo),(VV &lt; hi),(0 &lt;= VV),(lo &lt;= VV)}\n-&gt; a -&gt; af = {VV : a | (VV = base)}\n-&gt; {VV : (Int) | (VV = lo),\n                 (VV &gt;= 0),\n                 (0 &lt;= VV),\n                 (VV &lt;= hi),\n                 (lo &lt;= VV)}\n-&gt; ago {VV : a | (VV = base)}base {VV : (Int) | (VV = lo),(VV &gt;= 0),(0 &lt;= VV)}lo\n229:   where\n230:     {VV : a | (VV = base)}\n-&gt; {VV : (Int) | (VV = lo),\n                 (VV &gt;= 0),\n                 (0 &lt;= VV),\n                 (VV &lt;= hi),\n                 (lo &lt;= VV)}\n-&gt; ago aacc {VV : (Int) | (VV &gt;= 0),\n              (VV &gt;= lo),\n              (VV &gt;= lo),\n              (0 &lt;= VV),\n              (VV &lt;= hi),\n              (VV &lt;= hi),\n              (lo &lt;= VV),\n              (lo &lt;= VV)}i     \n231:       | {VV : (Int) | (VV = i),\n              (VV &gt;= 0),\n              (VV &gt;= lo),\n              (VV &gt;= lo),\n              (0 &lt;= VV),\n              (VV &lt;= hi),\n              (VV &lt;= hi),\n              (lo &lt;= VV),\n              (lo &lt;= VV)}i x:{VV : (Int) | (VV &gt;= 0),\n                (VV &gt;= i),\n                (VV &gt;= lo),\n                (VV &gt;= lo),\n                (0 &lt;= VV),\n                (VV &lt;= hi),\n                (VV &lt;= hi),\n                (i &lt;= VV),\n                (lo &lt;= VV),\n                (lo &lt;= VV)}\n-&gt; y:{VV : (Int) | (VV &gt;= 0),\n                   (VV &gt;= i),\n                   (VV &gt;= lo),\n                   (VV &gt;= lo),\n                   (0 &lt;= VV),\n                   (VV &lt;= hi),\n                   (VV &lt;= hi),\n                   (i &lt;= VV),\n                   (lo &lt;= VV),\n                   (lo &lt;= VV)}\n-&gt; {VV : (Bool) | ((? Prop([VV])) &lt;=&gt; (x != y))}/= {VV : (Int) | (VV = hi),\n              (VV = hi),\n              (VV &gt;= 0),\n              (VV &gt;= lo),\n              (VV &gt;= lo),\n              (0 &lt;= VV),\n              (hi &lt;= VV),\n              (lo &lt;= VV),\n              (lo &lt;= VV)}hi   = {VV : a | (VV = base)}\n-&gt; {VV : (Int) | (VV = lo),\n                 (VV &gt;= 0),\n                 (0 &lt;= VV),\n                 (VV &lt;= hi),\n                 (lo &lt;= VV)}\n-&gt; ago ({VV : (Int) | (VV &gt;= 0),\n              (VV &gt;= lo),\n              (VV &gt;= lo),\n              (VV &lt; hi),\n              (VV &lt; hi),\n              (0 &lt;= VV),\n              (lo &lt;= VV),\n              (lo &lt;= VV)}\n-&gt; a -&gt; af {VV : (Int) | (VV = i),\n              (VV &gt;= 0),\n              (VV &gt;= lo),\n              (VV &gt;= lo),\n              (0 &lt;= VV),\n              (VV &lt;= hi),\n              (VV &lt;= hi),\n              (lo &lt;= VV),\n              (lo &lt;= VV)}i {VV : a | (VV = acc)}acc) ({VV : (Int) | (VV = i),\n              (VV &gt;= 0),\n              (VV &gt;= lo),\n              (VV &gt;= lo),\n              (0 &lt;= VV),\n              (VV &lt;= hi),\n              (VV &lt;= hi),\n              (lo &lt;= VV),\n              (lo &lt;= VV)}i x:(Int) -&gt; y:(Int) -&gt; {VV : (Int) | (VV = (x + y))}+ {VV : (Int) | (VV = (1  :  int))}1)\n232:       | otherwise = {VV : a | (VV = acc)}acc\n</pre> <p>Using <code>loop</code> to compute <code>absoluteSum</code></p> <p>We can now use <code>loop</code> to implement <code>absoluteSum</code> like so:</p> <pre>240: forall a.\n(Num a)\n-&gt; {VV : (Vector {VV : a | false}) | false} -&gt; {VV : a | false}absoluteSum' {VV : (Vector {VV : a | false}) | false}vec = {VV : (Integer) | (VV = 0)}if {VV : (Int) | (VV = (0  :  int))}0 x:{VV : (Int) | false}\n-&gt; y:{VV : (Int) | false}\n-&gt; {VV : (Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt; y))}&lt; {VV : (Int) | (VV = n),(VV = vlen([vec])),(VV &gt;= 0)}n then lo:{VV : (Int) | (0 &lt;= VV)}\n-&gt; hi:{VV : (Int) | (0 &lt;= VV),(lo &lt;= VV)}\n-&gt; {VV : a | false}\n-&gt; ({VV : (Int) | (VV &lt; hi),(lo &lt;= VV)}\n    -&gt; {VV : a | false} -&gt; {VV : a | false})\n-&gt; {VV : a | false}loop {VV : (Int) | (VV = (0  :  int))}0 {VV : (Int) | (VV = n),(VV = vlen([vec])),(VV &gt;= 0)}n a0 {VV : (Int) | false} -&gt; {VV : a | false} -&gt; {VV : a | false}body else {VV : (Integer) | (VV = 0)}0\n241:   where {VV : (Int) | false} -&gt; {VV : a | false} -&gt; {VV : a | false}body     = \\{VV : (Int) | false}i {VV : a | false}acc -&gt; {VV : a | false}acc x:a -&gt; y:a -&gt; {VV : a | (VV = (x + y))}+ ({VV : (Vector {VV : a | false}) | false}vec x:(Vector {VV : a | false})\n-&gt; {VV : (Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; {VV : a | false}! {VV : (Int) | false}i)\n242:         {VV : (Int) | (VV = vlen([vec])),(VV &gt;= 0)}n        = x:(Vector {VV : a | false})\n-&gt; {VV : (Int) | (VV = vlen([x])),(VV &gt;= 0)}length {VV : (Vector {VV : a | false}) | false}vec\n</pre> <p>LiquidHaskell verifies <code>absoluteSum'</code> without any trouble.</p> <p>It is very instructive to see the type that LiquidHaskell infers  for <code>loop</code> -- it looks something like</p> <pre>251: {-@ loop :: lo: {v: Int | (0 &lt;= v) }  \n252:          -&gt; hi: {v: Int | ((0 &lt;= v) &amp;&amp; (lo &lt;= v))} \n253:          -&gt; a \n254:          -&gt; (i: {v: Int | (Btwn lo v hi)} -&gt; a -&gt; a)\n255:          -&gt; a \n256:   @-}\n</pre> <p>In english, the above type states that </p> <ul> <li><code>lo</code> the loop lower bound is a non-negative integer</li> <li><code>hi</code> the loop upper bound is a greater than <code>lo</code>,</li> <li><code>f</code>  the loop body is only called with integers between <code>lo</code> and <code>hi</code>.</li> </ul> <p>Inference is a rather convenient option -- it can be tedious to have to keep  typing things like the above! Of course, if we wanted to make <code>loop</code> a public or exported function, we could use the inferred type to generate  an explicit signature too.</p> <p>At the call </p> <pre>271: loop 0 n 0 body \n</pre> <p>the parameters <code>lo</code> and <code>hi</code> are instantiated with <code>0</code> and <code>n</code> respectively (which, by the way is where the inference engine deduces non-negativity from) and thus LiquidHaskell concludes that <code>body</code> is only called with values of <code>i</code> that are between <code>0</code> and <code>(vlen vec)</code>, which shows the  safety of the call <code>vec ! i</code>.</p> <p>Using <code>loop</code> to compute <code>dotProduct</code></p> <p>Here's another use of <code>loop</code> -- this time to compute the <code>dotProduct</code>  of two vectors. </p> <pre>286: dotProduct     :: Vector Int -&gt; Vector Int -&gt; Int\n287: x:(Vector (Int))\n-&gt; {VV : (Vector (Int)) | (vlen([VV]) = vlen([x]))} -&gt; (Int)dotProduct (Vector (Int))x {VV : (Vector (Int)) | (vlen([VV]) = vlen([x])),(vlen([VV]) &gt;= 0)}y = lo:{VV : (Int) | (0 &lt;= VV)}\n-&gt; hi:{VV : (Int) | (0 &lt;= VV),(lo &lt;= VV)}\n-&gt; (Int)\n-&gt; ({VV : (Int) | (VV &lt; hi),(lo &lt;= VV)} -&gt; (Int) -&gt; (Int))\n-&gt; (Int)loop {VV : (Int) | (VV = (0  :  int))}0 (x:(Vector (Int)) -&gt; {VV : (Int) | (VV = vlen([x])),(VV &gt;= 0)}length {VV : (Vector (Int)) | (VV = x),(vlen([VV]) &gt;= 0)}x) {VV : (Int) | (VV = (0  :  int))}0 ({VV : (Int) | (VV &gt;= 0),\n              (VV &lt; vlen([x])),\n              (VV &lt; vlen([y])),\n              (0 &lt;= VV)}\n-&gt; (Int) -&gt; (Int)\\{VV : (Int) | (VV &gt;= 0),\n              (VV &lt; vlen([x])),\n              (VV &lt; vlen([y])),\n              (0 &lt;= VV)}i -&gt; (x:(Int) -&gt; y:(Int) -&gt; {VV : (Int) | (VV = (x + y))}+ ({VV : (Vector (Int)) | (VV = x),(vlen([VV]) &gt;= 0)}x x:(Vector (Int))\n-&gt; {VV : (Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; (Int)! {VV : (Int) | (VV = i),\n              (VV &gt;= 0),\n              (VV &lt; vlen([x])),\n              (VV &lt; vlen([y])),\n              (0 &lt;= VV)}i) x:(Int)\n-&gt; y:(Int) -&gt; {VV : (Int) | (&amp;&amp; [(x &gt;= 0); (y &gt;= 0)] =&gt; (VV &gt;= 0))}* ({VV : (Vector (Int)) | (VV = y),\n                       (vlen([VV]) = vlen([x])),\n                       (vlen([VV]) &gt;= 0)}y x:(Vector (Int))\n-&gt; {VV : (Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; (Int)! {VV : (Int) | (VV = i),\n              (VV &gt;= 0),\n              (VV &lt; vlen([x])),\n              (VV &lt; vlen([y])),\n              (0 &lt;= VV)}i))) \n</pre> <p>The gimlet-eyed reader will realize that the above is quite unsafe -- what if <code>x</code> is a 10-dimensional vector while <code>y</code> has only 3-dimensions? </p> <p>A nasty</p> <pre>294: *** Exception: ./Data/Vector/Generic.hs:244 ((!)): index out of bounds ...\n</pre> <p>Yech. </p> <p>This is precisely the sort of unwelcome surprise we want to do away with at  compile-time. Refinements to the rescue! We can specify that the vectors  have the same dimensions quite easily</p> <pre>304: {-@ dotProduct :: x:(Vector Int) \n305:                -&gt; y:{v: (Vector Int) | (vlen v) = (vlen x)} \n306:                -&gt; Int \n307:   @-}\n</pre> <p>after which LiquidHaskell will gladly verify that the implementation of <code>dotProduct</code> is indeed safe!</p>","tags":["basic"]},{"location":"blogposts/2013-01-28-bounding-vectors.lhs/#refining-data-types","title":"Refining Data Types","text":"<p>Next, suppose we want to write a sparse dot product, that is,  the dot product of a vector and a sparse vector represented by a list of index-value tuples.</p> <p>Representing Sparse Vectors</p> <p>We can represent the sparse vector with a refinement type alias </p> <pre>325: {-@ type SparseVector a N = [({v: Int | (Btwn 0 v N)}, a)] @-}\n</pre> <p>As with usual types, the alias <code>SparseVector</code> on the left is just a  shorthand for the (longer) type on the right, it does not actually  define a new type. Thus, the above alias is simply a refinement of Haskell's <code>[(Int, a)]</code> type, with a size parameter <code>N</code> that facilitates  easy specification reuse. In this way, refinements let us express  invariants of containers like lists in a straightforward manner. </p> <p>Aside: If you are familiar with the index-style length  encoding e.g. as found in DML or Agda, then note that despite appearances, our <code>SparseVector</code> definition is not  indexed. Instead, we deliberately choose to encode properties  with logical refinement predicates, to facilitate SMT based  checking and inference.</p> <p>Verifying Uses of Sparse Vectors</p> <p>Next, we can write a recursive procedure that computes the sparse product</p> <pre>347: {-@ sparseProduct :: (Num a) =&gt; x:(Vector a) \n348:                              -&gt; SparseVector a (vlen x) \n349:                              -&gt; a \n350:   @-}\n351: forall a.\n(Num a)\n-&gt; x:(Vector a)\n-&gt; [({VV : (Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} , a)]\n-&gt; asparseProduct (Vector a)x [({VV : (Int) | (VV &gt;= 0),(VV &lt; vlen([x])),(0 &lt;= VV)} , a)]y  = {VV : a | (VV = 0)}\n-&gt; {VV : [({VV : (Int) | (VV &gt;= 0),\n                         (VV &lt; vlen([x])),\n                         (0 &lt;= VV)} , a)] | (VV = y),\n                                            (len([VV]) = len([y])),\n                                            (len([VV]) &gt;= 0)}\n-&gt; ago a0 {VV : [({VV : (Int) | (VV &gt;= 0),\n                      (VV &lt; vlen([x])),\n                      (0 &lt;= VV)} , a)] | (VV = y),(len([VV]) &gt;= 0)}y\n352:   where \n353:     {VV : a | (VV = 0)}\n-&gt; {VV : [({VV : (Int) | (VV &gt;= 0),\n                         (VV &lt; vlen([x])),\n                         (0 &lt;= VV)} , a)] | (VV = y),\n                                            (len([VV]) = len([y])),\n                                            (len([VV]) &gt;= 0)}\n-&gt; ago asum ((i, v) : y') = {VV : a | (VV = 0)}\n-&gt; {VV : [({VV : (Int) | (VV &gt;= 0),\n                         (VV &lt; vlen([x])),\n                         (0 &lt;= VV)} , a)] | (VV = y),\n                                            (len([VV]) = len([y])),\n                                            (len([VV]) &gt;= 0)}\n-&gt; ago ({VV : a | (VV = sum)}sum x:a -&gt; y:a -&gt; {VV : a | (VV = (x + y))}+ a({VV : (Vector a) | (VV = x),\n                   (VV = x),\n                   (vlen([VV]) = vlen([x])),\n                   (vlen([VV]) &gt;= 0)}x x:(Vector a) -&gt; {VV : (Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; a! {VV : (Int) | (VV = i),\n              (VV &gt;= 0),\n              (VV &lt; vlen([x])),\n              (VV &lt; vlen([x])),\n              (0 &lt;= VV)}i) x:a -&gt; y:a -&gt; {VV : a | (&amp;&amp; [(x &gt;= 0); (y &gt;= 0)] =&gt; (VV &gt;= 0))}* {VV : a | (VV = v)}v) {VV : [({VV : (Int) | (VV &gt;= 0),\n                      (VV &lt; vlen([x])),\n                      (VV &lt; vlen([x])),\n                      (0 &lt;= VV)} , a)] | (VV = y'),(len([VV]) &gt;= 0)}y' \n354:     go sum []            = {VV : a | (VV = sum)}sum\n</pre> <p>LiquidHaskell verifies the above by using the specification for <code>y</code> to conclude that for each tuple <code>(i, v)</code> in the list, the value of <code>i</code> is  within the bounds of the vector <code>x</code>, thereby proving the safety of the  access <code>x ! i</code>.</p>","tags":["basic"]},{"location":"blogposts/2013-01-28-bounding-vectors.lhs/#refinements-and-polymorphism","title":"Refinements and Polymorphism","text":"<p>The sharp reader will have undoubtedly noticed that the sparse product  can be more cleanly expressed as a fold. </p> <p>Indeed! Let us recall the type of the <code>foldl</code> operation</p> <pre>369: foldl' :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a\n</pre> <p>Thus, we can simply fold over the sparse vector, accumulating the <code>sum</code> as we go along</p> <pre>376: {-@ sparseProduct' :: (Num a) =&gt; x:(Vector a) \n377:                              -&gt; SparseVector a (vlen x) \n378:                              -&gt; a \n379:   @-}\n380: forall a.\n(Num a)\n-&gt; x:(Vector a)\n-&gt; [({VV : (Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} , a)]\n-&gt; asparseProduct' (Vector a)x [({VV : (Int) | (VV &gt;= 0),(VV &lt; vlen([x])),(0 &lt;= VV)} , a)]y   = (a\n -&gt; ({VV : (Int) | (VV &gt;= 0),(VV &lt; vlen([x])),(0 &lt;= VV)} , a) -&gt; a)\n-&gt; a\n-&gt; [({VV : (Int) | (VV &gt;= 0),(VV &lt; vlen([x])),(0 &lt;= VV)} , a)]\n-&gt; afoldl' a -&gt; ({VV : (Int) | (VV &gt;= 0),(VV &lt; vlen([x])),(0 &lt;= VV)} , a) -&gt; abody a0 {VV : [({VV : (Int) | (VV &gt;= 0),\n                      (VV &lt; vlen([x])),\n                      (0 &lt;= VV)} , a)] | (VV = y),(len([VV]) &gt;= 0)}y   \n381:   where a -&gt; ({VV : (Int) | (VV &gt;= 0),(VV &lt; vlen([x])),(0 &lt;= VV)} , a) -&gt; abody asum (i, v) = {VV : a | (VV = sum)}sum x:a -&gt; y:a -&gt; {VV : a | (VV = (x + y))}+ a({VV : (Vector a) | (VV = x),(vlen([VV]) &gt;= 0)}x x:(Vector a) -&gt; {VV : (Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; a! {VV : (Int) | (VV = i),(VV &gt;= 0),(VV &lt; vlen([x])),(0 &lt;= VV)}i) x:a -&gt; y:a -&gt; {VV : a | (&amp;&amp; [(x &gt;= 0); (y &gt;= 0)] =&gt; (VV &gt;= 0))}* {VV : a | (VV = v)}v\n</pre> <p>LiquidHaskell digests this too, without much difficulty. </p> <p>The main trick is in how the polymorphism of <code>foldl'</code> is instantiated. </p> <ol> <li> <p>The GHC type inference engine deduces that at this site, the type variable    <code>b</code> from the signature of <code>foldl'</code> is instantiated to the Haskell type <code>(Int, a)</code>. </p> </li> <li> <p>Correspondingly, LiquidHaskell infers that in fact <code>b</code> can be instantiated    to the refined type <code>({v: Int | (Btwn 0 v (vlen x))}, a)</code>. </p> </li> </ol> <p>Walk the mouse over to <code>i</code> to see this inferred type. (You can also hover over <code>foldl'</code>above to see the rather more verbose fully instantiated type.)</p> <p>Thus, the inference mechanism saves us a fair bit of typing and allows us to reuse existing polymorphic functions over containers and such without ceremony.</p>","tags":["basic"]},{"location":"blogposts/2013-01-28-bounding-vectors.lhs/#conclusion","title":"Conclusion","text":"<p>Thats all for now folks! Hopefully the above gives you a reasonable idea of how one can use refinements to verify size related properties, and more generally, to specify and verify properties of recursive, and polymorphic functions operating over datatypes. Next time, we'll look at how we can teach LiquidHaskell to think about properties of recursive structures like lists and trees.</p>","tags":["basic"]},{"location":"blogposts/2013-01-31-safely-catching-a-list-by-its-tail.lhs/","title":"Safely Catching A List By Its Tail","text":"<p>Previously we saw some examples of how refinements could be used to encode invariants about basic <code>Int</code> values.  Today, let's see how refinements allow us specify and verify structural invariants about recursive data types like lists. In particular, we will learn about at a new mechanism called a <code>measure</code>,  use measures to describe the length of a list, and  use the resulting refinement types to obtain compile-time assurances that canonical list manipulating operations like <code>head</code>, <code>tail</code>, <code>foldl1</code> and (incomplete) pattern matches will not blow up at run-time.</p> <pre>26: module ListLengths where\n27: \n28: import Prelude hiding (length, map, filter, head, tail, foldl1)\n29: import Language.Haskell.Liquid.Prelude (liquidError)\n30: import qualified Data.HashMap.Strict as M\n31: import Data.Hashable \n</pre>","tags":["measures"]},{"location":"blogposts/2013-01-31-safely-catching-a-list-by-its-tail.lhs/#measuring-the-length-of-a-list","title":"Measuring the Length of a List","text":"<p>To begin, we need some instrument by which to measure the length of a list. To this end, let's introduce a new mechanism called measures which  define auxiliary (or so-called ghost) properties of data values. These properties are useful for specification and verification, but don't actually exist at run-time. That is, measures will appear in specifications but never inside code.</p> <p>Let's reuse this mechanism, this time, providing a definition for the measure</p> <pre>48: measure len :: forall a. [a] -&gt; GHC.Types.Int\n49: len ([])     = 0\n50: len (y:ys)   = 1 + (len ys) \n</pre> <p>The description of <code>len</code> above should be quite easy to follow. Underneath the  covers, LiquidHaskell transforms the above description into refined versions  of the types for the constructors <code>(:)</code> and <code>[]</code>, Something like </p> <pre>57: data [a] where \n58:   []  :: forall a. {v: [a] | (len v) = 0 }\n59:   (:) :: forall a. y:a -&gt; ys:[a] -&gt; {v: [a] | (len v) = 1 + (len ys) } \n</pre> <p>To appreciate this, note that we can now check that</p> <pre>65: {-@ xs :: {v:[String] | (len v) = 1 } @-}\n66: {VV : [[(GHC.Types.Char)]] | (len([VV]) = 1)}xs = {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"dog\" y:{VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\n-&gt; ys:[{VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}]\n-&gt; {VV : [{VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}] | (len([VV]) = (1 + len([ys])))}: {VV : [{VV : [{VV : (GHC.Types.Char) | false}] | false}] | (len([VV]) = 0),\n                                                           (len([VV]) &gt;= 0)}[]\n67: \n68: {-@ ys :: {v:[String] | (len v) = 2 } @-}\n69: {VV : [[(GHC.Types.Char)]] | (len([VV]) = 2)}ys = {VV : [{VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}] | (len([VV]) &gt;= 0)}[{VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"cat\", {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"dog\"]\n70: \n71: {-@ zs :: {v:[String] | (len v) = 3 } @-}\n72: {VV : [[(GHC.Types.Char)]] | (len([VV]) = 3)}zs = {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"hippo\" y:[(GHC.Types.Char)]\n-&gt; ys:[[(GHC.Types.Char)]]\n-&gt; {VV : [[(GHC.Types.Char)]] | (len([VV]) = (1 + len([ys])))}: {VV : [[(GHC.Types.Char)]] | (VV = ys),\n                             (len([VV]) = 2),\n                             (len([VV]) &gt;= 0)}ys\n</pre> <p>Dually, when we de-construct the lists, LiquidHaskell is able to relate the type of the outer list with its constituents. For example,</p> <pre>79: {-@ zs' :: {v:[String] | (len v) = 2 } @-}\n80: {VV : [[(GHC.Types.Char)]] | (len([VV]) = 2)}zs' = case {VV : [[(GHC.Types.Char)]] | (VV = zs),\n                             (len([VV]) = 3),\n                             (len([VV]) &gt;= 0)}zs of \n81:         h : t -&gt; {VV : [[(GHC.Types.Char)]] | (VV = t),(len([VV]) &gt;= 0)}t\n</pre> <p>Here, from the use of the <code>:</code> in the pattern, LiquidHaskell can determine that <code>(len zs) = 1 + (len t)</code>; by combining this fact with the nugget that <code>(len zs) = 3</code> LiquidHaskell concludes that <code>t</code>, and hence, <code>zs'</code> contains two elements.</p>","tags":["measures"]},{"location":"blogposts/2013-01-31-safely-catching-a-list-by-its-tail.lhs/#reasoning-about-lengths","title":"Reasoning about Lengths","text":"<p>Let's flex our new vocabulary by uttering types that describe the behavior of the usual list functions. </p> <p>First up: a version of the standard <code>length</code> function, slightly simplified for exposition.</p> <pre>99: {-@ length :: xs:[a] -&gt; {v: Int | v = (len xs)} @-}\n100: length :: [a] -&gt; Int\n101: xs:[a] -&gt; {VV : (GHC.Types.Int) | (VV = len([xs]))}length []     = x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}0\n102: length (x:xs) = {VV : (GHC.Types.Int) | (VV = (1  :  int))}1 x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x + y))}+ xs:[a] -&gt; {VV : (GHC.Types.Int) | (VV = len([xs]))}length {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs\n</pre> <p>Note: Recall that <code>measure</code> values don't actually exist at run-time. However, functions like <code>length</code> are useful in that they allow us to effectively pull or materialize the ghost values from the refinement world into the actual code world (since the value returned by <code>length</code> is logically equal to the <code>len</code> of the input list.)</p> <p>Similarly, we can speak and have confirmed, the types for the usual list-manipulators like</p> <pre>115: {-@ map      :: (a -&gt; b) -&gt; xs:[a] -&gt; {v:[b] | (len v) = (len xs)} @-}\n116: (a -&gt; b)\n-&gt; x1:[a] -&gt; {VV : [b] | (len([VV]) = len([x1])),(len([VV]) &gt;= 0)}map _ []     = {VV : [{VV : a | false}] | (len([VV]) = 0)}[] \n117: map f (x:xs) = (a -&gt; bf {VV : a | (VV = x)}x) y:a -&gt; ys:[a] -&gt; {VV : [a] | (len([VV]) = (1 + len([ys])))}: ((a -&gt; b)\n-&gt; x1:[a] -&gt; {VV : [b] | (len([VV]) = len([x1])),(len([VV]) &gt;= 0)}map a -&gt; bf {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs)\n</pre> <p>and</p> <pre>123: {-@ filter :: (a -&gt; Bool) -&gt; xs:[a] -&gt; {v:[a] | (len v) &lt;= (len xs)} @-}\n124: (a -&gt; (GHC.Types.Bool))\n-&gt; x1:[a] -&gt; {VV : [a] | (len([VV]) &gt;= 0),(len([VV]) &lt;= len([x1]))}filter _ []     = {VV : [{VV : a | false}] | (len([VV]) = 0)}[]\n125: filter f (x:xs) \n126:   | a -&gt; (GHC.Types.Bool)f {VV : a | (VV = x)}x         = {VV : a | (VV = x)}x y:a -&gt; ys:[a] -&gt; {VV : [a] | (len([VV]) = (1 + len([ys])))}: (a -&gt; (GHC.Types.Bool))\n-&gt; x1:[a] -&gt; {VV : [a] | (len([VV]) &gt;= 0),(len([VV]) &lt;= len([x1]))}filter a -&gt; (GHC.Types.Bool)f {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs\n127:   | otherwise   = (a -&gt; (GHC.Types.Bool))\n-&gt; x1:[a] -&gt; {VV : [a] | (len([VV]) &gt;= 0),(len([VV]) &lt;= len([x1]))}filter a -&gt; (GHC.Types.Bool)f {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs\n</pre> <p>and, since doubtless you are wondering,</p> <pre>133: {-@ append :: xs:[a] -&gt; ys:[a] -&gt; {v:[a] | (len v) = (len xs) + (len ys)} @-}\n134: x4:[a]\n-&gt; x3:[a]\n-&gt; {VV : [a] | (len([VV]) = (len([x4]) + len([x3]))),\n               (len([VV]) = (len([x3]) + len([x4]))),\n               (len([VV]) &gt;= 0)}append [] [a]ys     = {VV : [a] | (VV = ys),(len([VV]) &gt;= 0)}ys \n135: append (x:xs) ys = {VV : a | (VV = x)}x y:a -&gt; ys:[a] -&gt; {VV : [a] | (len([VV]) = (1 + len([ys])))}: x4:[a]\n-&gt; x3:[a]\n-&gt; {VV : [a] | (len([VV]) = (len([x4]) + len([x3]))),\n               (len([VV]) = (len([x3]) + len([x4]))),\n               (len([VV]) &gt;= 0)}append {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs {VV : [a] | (VV = ys),(len([VV]) &gt;= 0)}ys\n</pre> <p>We will return to the above at some later date. Right now, let's look at some interesting programs that LiquidHaskell can prove safe, by reasoning about the size of various lists.</p>","tags":["measures"]},{"location":"blogposts/2013-01-31-safely-catching-a-list-by-its-tail.lhs/#example-1-safely-catching-a-list-by-its-tail-or-head","title":"Example 1: Safely Catching A List by Its Tail (or Head)","text":"<p>Now, let's see how we can use these new incantations to banish, forever, certain irritating kinds of errors.  Recall how we always summon functions like <code>head</code> and <code>tail</code> with a degree of trepidation, unsure whether the arguments are empty, which will awaken certain beasts</p> <pre>150: Prelude&gt; head []\n151: *** Exception: Prelude.head: empty list\n</pre> <p>LiquidHaskell allows us to use these functions with  confidence and surety! First off, let's define a predicate alias that describes non-empty lists:</p> <pre>159: {-@ predicate NonNull X = ((len X) &gt; 0) @-}\n</pre> <p>Now, we can type the potentially dangerous <code>head</code> as:</p> <pre>165: {-@ head   :: {v:[a] | (NonNull v)} -&gt; a @-}\n166: {VV : [a] | (len([VV]) &gt; 0)} -&gt; ahead (x:_) = {VV : a | (VV = x)}x\n167: head []    = {VV : [(GHC.Types.Char)] | false} -&gt; {VV : a | false}liquidError {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"Fear not! 'twill ne'er come to pass\"\n</pre> <p>As with the case of divide-by-zero, LiquidHaskell deduces that the second equation is dead code since the precondition (input) type states that the length of the input is strictly positive, which precludes the case where the parameter is <code>[]</code>.</p> <p>Similarly, we can write</p> <pre>178: {-@ tail :: {v:[a] | (NonNull v)} -&gt; [a] @-}\n179: {VV : [a] | (len([VV]) &gt; 0)} -&gt; [a]tail (_:xs) = {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs\n180: tail []     = {VV : [(GHC.Types.Char)] | false}\n-&gt; {VV : [{VV : a | false}] | false}liquidError {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"Relaxeth! this too shall ne'er be\"\n</pre> <p>Once again, LiquidHaskell will use the precondition to verify that the  <code>liquidError</code> is never invoked. </p> <p>Let's use the above to write a function that eliminates stuttering, that is which converts <code>\"ssstringssss liiiiiike thisss\"</code> to <code>\"strings like this\"</code>.</p> <pre>190: {-@ eliminateStutter :: (Eq a) =&gt; [a] -&gt; [a] @-}\n191: (GHC.Classes.Eq a) -&gt; [a] -&gt; [a]eliminateStutter [a]xs = ({VV : [a] | (len([VV]) &gt; 0)} -&gt; a)\n-&gt; xs:[{VV : [a] | (len([VV]) &gt; 0)}]\n-&gt; {VV : [a] | (len([VV]) = len([xs]))}map {VV : [a] | (len([VV]) &gt; 0)} -&gt; ahead ({VV : [{VV : [a] | (len([VV]) &gt; 0)}] | ((len([xs]) &gt; 0) =&gt; (len([VV]) &gt; 0)),\n                                        (len([VV]) &gt;= 0)}\n -&gt; {VV : [a] | (len([VV]) &gt;= 0)})\n-&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | ((len([xs]) &gt; 0) =&gt; (len([VV]) &gt; 0)),\n                                          (len([VV]) &gt;= 0)}\n-&gt; {VV : [a] | (len([VV]) &gt;= 0)}$ x1:{VV : [a] | (len([VV]) &gt;= 0)}\n-&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | ((len([x1]) &gt; 0) =&gt; (len([VV]) &gt; 0)),\n                                          (len([VV]) &gt;= 0)}groupEq {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs \n</pre> <p>The heavy lifting is done by <code>groupEq</code></p> <pre>197: x1:{VV : [a] | (len([VV]) &gt;= 0)}\n-&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | ((len([x1]) &gt; 0) =&gt; (len([VV]) &gt; 0)),\n                                          (len([VV]) &gt;= 0)}groupEq []     = {VV : [{VV : [{VV : a | false}] | false}] | (len([VV]) = 0)}[]\n198: groupEq (x:xs) = ({VV : a | (VV = x)}xy:a -&gt; ys:[a] -&gt; {VV : [a] | (len([VV]) = (1 + len([ys])))}:{VV : [a] | (VV = ys),\n            (VV = ys),\n            (len([VV]) = len([ys])),\n            (len([VV]) &gt;= 0),\n            (len([VV]) &lt;= len([ys]))}ys) y:{VV : [a] | (len([VV]) &gt; 0)}\n-&gt; ys:[{VV : [a] | (len([VV]) &gt; 0)}]\n-&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) = (1 + len([ys])))}: x1:{VV : [a] | (len([VV]) &gt;= 0)}\n-&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | ((len([x1]) &gt; 0) =&gt; (len([VV]) &gt; 0)),\n                                          (len([VV]) &gt;= 0)}groupEq {VV : [a] | (VV = zs),\n            (VV = zs),\n            (len([VV]) = len([zs])),\n            (len([VV]) &gt;= 0),\n            (len([VV]) &lt;= len([zs]))}zs\n199:                  where ({VV : [a] | (VV = ys),\n            (len([VV]) = len([ys])),\n            (len([VV]) &gt;= 0),\n            (len([VV]) &lt;= len([ys]))}ys,{VV : [a] | (VV = zs),\n            (len([VV]) = len([zs])),\n            (len([VV]) &gt;= 0),\n            (len([VV]) &lt;= len([zs]))}zs) = (a -&gt; (GHC.Types.Bool)) -&gt; [a] -&gt; ([a] , [a])span ({VV : a | (VV = x)}x x:a\n-&gt; y:a -&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x = y))}==) {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs\n</pre> <p>which gathers consecutive equal elements in the list into a single list. By using the fact that each element in the output returned by  <code>groupEq</code> is in fact of the form <code>x:ys</code>, LiquidHaskell infers that <code>groupEq</code> returns a list of non-empty lists.  (Hover over the <code>groupEq</code> identifier in the code above to see this.) Next, by automatically instantiating the type parameter for the <code>map</code>  in <code>eliminateStutter</code> to <code>(len v) &gt; 0</code> LiquidHaskell deduces <code>head</code>  is only called on non-empty lists, thereby verifying the safety of  <code>eliminateStutter</code>. (Hover your mouse over <code>map</code> above to see the instantiated type for it!)</p>","tags":["measures"]},{"location":"blogposts/2013-01-31-safely-catching-a-list-by-its-tail.lhs/#example-2-risers","title":"Example 2: Risers","text":"<p>The above examples of <code>head</code> and <code>tail</code> are simple, but non-empty lists pop up in many places, and it is rather convenient to have the type system track non-emptiness without having to make up special types. Let's look at a more interesting example, popularized by Neil Mitchell which is a key step in an efficient sorting procedure, which we may return to in the future when we discuss sorting algorithms.</p> <pre>224: risers           :: (Ord a) =&gt; [a] -&gt; [[a]]\n225: (GHC.Classes.Ord a)\n-&gt; zs:[a] -&gt; {VV : [[a]] | ((len([zs]) &gt; 0) =&gt; (len([VV]) &gt; 0))}risers []        = {VV : [{VV : [{VV : a | false}] | false}] | (len([VV]) = 0)}[]\n226: risers [x]       = {VV : [{VV : [{VV : a | false}] | false}] | (len([VV]) = 0),\n                                            (len([VV]) &gt;= 0)}[{VV : [{VV : a | (VV = x)}] | (len([VV]) &gt;= 0)}[{VV : a | (VV = x)}x]]\n227: risers (x:y:etc) = {VV : [{VV : a | false}] | (len([VV]) = 0),(len([VV]) &gt;= 0)}if {VV : a | (VV = x)}x x:a\n-&gt; y:a -&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt;= y))}&lt;= {VV : a | (VV = y)}y then ({VV : a | (VV = x)}xy:a -&gt; ys:[a] -&gt; {VV : [a] | (len([VV]) = (1 + len([ys])))}:{VV : [a] | (VV = s),\n            (VV = s),\n            (len([VV]) = len([s])),\n            (len([VV]) &gt;= 0),\n            (len([VV]) &lt;= len([s]))}s)y:[a] -&gt; ys:[[a]] -&gt; {VV : [[a]] | (len([VV]) = (1 + len([ys])))}:{VV : [[a]] | (VV = ss),\n              (VV = ss),\n              (len([VV]) = len([ss])),\n              (len([VV]) &gt;= 0),\n              (len([VV]) &lt;= len([ss]))}ss else {VV : [{VV : a | (VV = x),(VV &gt; y)}] | (len([VV]) &gt;= 0)}[{VV : a | (VV = x)}x]y:[a] -&gt; ys:[[a]] -&gt; {VV : [[a]] | (len([VV]) = (1 + len([ys])))}:({VV : [a] | (VV = s),\n            (VV = s),\n            (len([VV]) = len([s])),\n            (len([VV]) &gt;= 0),\n            (len([VV]) &lt;= len([s]))}sy:[a] -&gt; ys:[[a]] -&gt; {VV : [[a]] | (len([VV]) = (1 + len([ys])))}:{VV : [[a]] | (VV = ss),\n              (VV = ss),\n              (len([VV]) = len([ss])),\n              (len([VV]) &gt;= 0),\n              (len([VV]) &lt;= len([ss]))}ss)\n228:     where \n229:       ({VV : [a] | (VV = s),\n            (len([VV]) = len([s])),\n            (len([VV]) &gt;= 0),\n            (len([VV]) &lt;= len([s]))}s, {VV : [[a]] | (VV = ss),\n              (len([VV]) = len([ss])),\n              (len([VV]) &gt;= 0),\n              (len([VV]) &lt;= len([ss]))}ss)    = {VV : [[a]] | (len([VV]) &gt; 0)}\n-&gt; ([a] , {VV : [[a]] | (len([VV]) &gt;= 0)})safeSplit ({VV : [[a]] | ((len([etc]) &gt; 0) =&gt; (len([VV]) &gt; 0)),\n               (len([VV]) &gt; 0)}\n -&gt; ([a] , {VV : [[a]] | (len([VV]) &gt;= 0)}))\n-&gt; {VV : [[a]] | ((len([etc]) &gt; 0) =&gt; (len([VV]) &gt; 0)),\n                 (len([VV]) &gt; 0)}\n-&gt; ([a] , {VV : [[a]] | (len([VV]) &gt;= 0)})$ zs:[a] -&gt; {VV : [[a]] | ((len([zs]) &gt; 0) =&gt; (len([VV]) &gt; 0))}risers ({VV : a | (VV = y)}yy:a -&gt; ys:[a] -&gt; {VV : [a] | (len([VV]) = (1 + len([ys])))}:{VV : [a] | (VV = etc),(len([VV]) &gt;= 0)}etc)\n</pre> <p>The bit that should cause some worry is <code>safeSplit</code> which  simply returns the <code>head</code> and <code>tail</code> of its input, if they exist, and otherwise, crashes and burns</p> <pre>237: {VV : [a] | (len([VV]) &gt; 0)} -&gt; (a , {VV : [a] | (len([VV]) &gt;= 0)})safeSplit (x:xs)  = x1:a -&gt; b -&gt; (a , b)({VV : a | (VV = x)}x, {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs)\n238: safeSplit _       = {VV : [(GHC.Types.Char)] | false}\n-&gt; {VV : ({VV : a | false} , {VV : [{VV : a | false}] | false}) | false}liquidError {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"don't worry, be happy\"\n</pre> <p>How can we verify that <code>safeSplit</code> will not crash ?</p> <p>The matter is complicated by the fact that since <code>risers</code> does sometimes return an empty list, we cannot blithely  specify that its output type has a <code>NonNull</code> refinement.</p> <p>Once again, logic rides to our rescue!</p> <p>The crucial property upon which the safety of <code>risers</code> rests is that when the input list is non-empty, the output list  returned by risers is also non-empty. It is quite easy to clue  LiquidHaskell in on this, namely through a type specification:</p> <pre>255: {-@ risers :: (Ord a) \n256:            =&gt; zs:[a] \n257:            -&gt; {v: [[a]] | ((NonNull zs) =&gt; (NonNull v)) } @-} \n</pre> <p>Note how we relate the output's non-emptiness to the input's non-emptiness,through the (dependent) refinement type. With this  specification in place, LiquidHaskell is pleased to verify <code>risers</code>  (i.e. the call to <code>safeSplit</code>).</p>","tags":["measures"]},{"location":"blogposts/2013-01-31-safely-catching-a-list-by-its-tail.lhs/#example-3-mapreduce","title":"Example 3: MapReduce","text":"<p>Here's a longer example that illustrates this: a toy map-reduce implementation.</p> <p>First, let's write a function <code>keyMap</code> that expands a list of inputs into a  list of key-value pairs:</p> <pre>274: keyMap :: (a -&gt; [(k, v)]) -&gt; [a] -&gt; [(k, v)]\n275: (a -&gt; {VV : [(b , c)] | (len([VV]) &gt;= 0)}) -&gt; [a] -&gt; [(b , c)]keyMap a -&gt; {VV : [(b , c)] | (len([VV]) &gt;= 0)}f [a]xs = (a -&gt; [(b , c)]) -&gt; [a] -&gt; [(b , c)]concatMap a -&gt; {VV : [(b , c)] | (len([VV]) &gt;= 0)}f {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs\n</pre> <p>Next, let's write a function <code>group</code> that gathers the key-value pairs into a <code>Map</code> from keys to the lists of values with that same key.</p> <pre>282: (GHC.Classes.Eq a)\n-&gt; (Data.Hashable.Class.Hashable a)\n-&gt; [(a , b)]\n-&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})group [(a , b)]kvs = ((a , b)\n -&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})\n -&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)}))\n-&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})\n-&gt; [(a , b)]\n-&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})foldr ((a , b)\n-&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})\n-&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})\\(k, v) (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})m -&gt; a\n-&gt; b\n-&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})\n-&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})inserts {VV : a | (VV = k)}k {VV : a | (VV = v)}v {VV : (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)}) | (VV = m)}m) (Data.HashMap.Base.HashMap {VV : a | false} {VV : [{VV : b | false}] | false})M.empty {VV : [(a , b)] | (VV = kvs),(len([VV]) &gt;= 0)}kvs \n</pre> <p>The function <code>inserts</code> simply adds the new value <code>v</code> to the list of  previously known values <code>lookupDefault [] k m</code> for the key <code>k</code>.</p> <pre>289: (GHC.Classes.Eq a)\n-&gt; (Data.Hashable.Class.Hashable a)\n-&gt; a\n-&gt; b\n-&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})\n-&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})inserts ak av (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})m = a\n-&gt; {VV : [b] | (len([VV]) &gt; 0)}\n-&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})\n-&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})M.insert {VV : a | (VV = k)}k ({VV : a | (VV = v)}v y:a -&gt; ys:[a] -&gt; {VV : [a] | (len([VV]) = (1 + len([ys])))}: {VV : [a] | (VV = vs),(len([VV]) &gt;= 0)}vs) {VV : (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)}) | (VV = m)}m \n290:   where {VV : [a] | (len([VV]) &gt;= 0)}vs    = {VV : [a] | (len([VV]) &gt;= 0)}\n-&gt; b\n-&gt; (Data.HashMap.Base.HashMap b {VV : [a] | (len([VV]) &gt;= 0)})\n-&gt; {VV : [a] | (len([VV]) &gt;= 0)}M.lookupDefault {VV : [{VV : a | false}] | (len([VV]) = 0),(len([VV]) &gt;= 0)}[] {VV : a | (VV = k)}k {VV : (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)}) | (VV = m)}m\n</pre> <p>Finally, a function that reduces the list of values for a given key in the table to a single value:</p> <pre>297: reduce    :: (v -&gt; v -&gt; v) -&gt; M.HashMap k [v] -&gt; M.HashMap k v\n298: (x2:a -&gt; x3:a -&gt; {VV : a | (VV &gt; x2),(VV &gt; x3)})\n-&gt; (Data.HashMap.Base.HashMap b {VV : [a] | (len([VV]) &gt; 0)})\n-&gt; (Data.HashMap.Base.HashMap b a)reduce x1:a -&gt; x2:a -&gt; {VV : a | (VV &gt; x1),(VV &gt; x2)}op = ({VV : [a] | (len([VV]) &gt; 0)} -&gt; a)\n-&gt; (Data.HashMap.Base.HashMap b {VV : [a] | (len([VV]) &gt; 0)})\n-&gt; (Data.HashMap.Base.HashMap b a)M.map ((a -&gt; a -&gt; a) -&gt; {VV : [a] | (len([VV]) &gt; 0)} -&gt; afoldl1 x1:a -&gt; x2:a -&gt; {VV : a | (VV &gt; x1),(VV &gt; x2)}op)\n</pre> <p>where <code>foldl1</code> is a left-fold over non-empty lists</p> <pre>304: {-@ foldl1      :: (a -&gt; a -&gt; a) -&gt; {v:[a] | (NonNull v)} -&gt; a @-}\n305: (a -&gt; a -&gt; a) -&gt; {VV : [a] | (len([VV]) &gt; 0)} -&gt; afoldl1 a -&gt; a -&gt; af (x:xs) =  (a -&gt; a -&gt; a) -&gt; a -&gt; [a] -&gt; afoldl a -&gt; a -&gt; af {VV : a | (VV = x)}x {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs\n306: foldl1 _ []     =  {VV : [(GHC.Types.Char)] | false} -&gt; {VV : a | false}liquidError {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"will. never. happen.\"\n</pre> <p>We can put the whole thing together to write a (very) simple Map-Reduce library</p> <pre>312: mapReduce   :: (Eq k, Hashable k) \n313:             =&gt; (a -&gt; [(k, v)])    -- ^ key-mapper\n314:             -&gt; (v -&gt; v -&gt; v)      -- ^ reduction operator\n315:             -&gt; [a]                -- ^ inputs\n316:             -&gt; [(k, v)]           -- ^ output key-values\n317: \n318: (GHC.Classes.Eq a)\n-&gt; (Data.Hashable.Class.Hashable a)\n-&gt; (b -&gt; {VV : [(a , c)] | (len([VV]) &gt;= 0)})\n-&gt; (x7:c -&gt; x8:c -&gt; {VV : c | (VV &gt; x7),(VV &gt; x8)})\n-&gt; [b]\n-&gt; [(a , c)]mapReduce a -&gt; {VV : [(b , c)] | (len([VV]) &gt;= 0)}f x1:a -&gt; x2:a -&gt; {VV : a | (VV &gt; x1),(VV &gt; x2)}op  = (Data.HashMap.Base.HashMap a b) -&gt; [(a , b)]M.toList \n319:                 ((Data.HashMap.Base.HashMap a b) -&gt; [(a , b)])\n-&gt; ([c] -&gt; (Data.HashMap.Base.HashMap a b)) -&gt; [c] -&gt; [(a , b)]. (x2:a -&gt; x3:a -&gt; {VV : a | (VV &gt; x2),(VV &gt; x3)})\n-&gt; (Data.HashMap.Base.HashMap b {VV : [a] | (len([VV]) &gt; 0)})\n-&gt; (Data.HashMap.Base.HashMap b a)reduce x1:a -&gt; x2:a -&gt; {VV : a | (VV &gt; x1),(VV &gt; x2)}op \n320:                 ((Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})\n -&gt; (Data.HashMap.Base.HashMap a b))\n-&gt; ([c]\n    -&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)}))\n-&gt; [c]\n-&gt; (Data.HashMap.Base.HashMap a b). [(a , b)]\n-&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)})group \n321:                 ([(a , b)]\n -&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)}))\n-&gt; ([c] -&gt; [(a , b)])\n-&gt; [c]\n-&gt; (Data.HashMap.Base.HashMap a {VV : [b] | (len([VV]) &gt; 0)}). (a -&gt; {VV : [(b , c)] | (len([VV]) &gt;= 0)}) -&gt; [a] -&gt; [(b , c)]keyMap a -&gt; {VV : [(b , c)] | (len([VV]) &gt;= 0)}f\n</pre> <p>Now, if we want to compute the frequency of <code>Char</code> in a given list of words, we can write:</p> <pre>327: {-@ charFrequency :: [String] -&gt; [(Char, Int)] @-}\n328: charFrequency     :: [String] -&gt; [(Char, Int)]\n329: [[(GHC.Types.Char)]] -&gt; [((GHC.Types.Char) , (GHC.Types.Int))]charFrequency     = ([(GHC.Types.Char)]\n -&gt; {VV : [((GHC.Types.Char) , {VV : (GHC.Types.Int) | (VV &gt; 0)})] | (len([VV]) &gt;= 0)})\n-&gt; (x8:{VV : (GHC.Types.Int) | (VV &gt; 0)}\n    -&gt; x9:{VV : (GHC.Types.Int) | (VV &gt; 0)}\n    -&gt; {VV : (GHC.Types.Int) | (VV &gt; 0),(VV &gt; x8),(VV &gt; x9)})\n-&gt; [[(GHC.Types.Char)]]\n-&gt; [((GHC.Types.Char) , {VV : (GHC.Types.Int) | (VV &gt; 0)})]mapReduce x1:[(GHC.Types.Char)]\n-&gt; {VV : [((GHC.Types.Char) , {VV : (GHC.Types.Int) | (VV = 1),\n                                                      (VV = len([xs])),\n                                                      (VV &gt; 0)})] | (len([VV]) = len([x1])),\n                                                                    (len([VV]) &gt;= 0)}wordChars x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x + y))}(+)\n330:   where x1:[a]\n-&gt; {VV : [(a , {VV : (GHC.Types.Int) | (VV = 1),\n                                       (VV = len([xs])),\n                                       (VV &gt; 0)})] | (len([VV]) = len([x1])),(len([VV]) &gt;= 0)}wordChars = (a\n -&gt; (a , {VV : (GHC.Types.Int) | (VV = 1),\n                                 (VV = len([xs])),\n                                 (VV &gt; 0)}))\n-&gt; xs:[a]\n-&gt; {VV : [(a , {VV : (GHC.Types.Int) | (VV = 1),\n                                       (VV = len([xs])),\n                                       (VV &gt; 0)})] | (len([VV]) = len([xs]))}map (c:a\n-&gt; ({VV : a | (VV = c)} , {VV : (GHC.Types.Int) | (VV = 1),\n                                                  (VV = len([xs])),\n                                                  (VV &gt; 0)})\\ac -&gt; x1:a -&gt; b -&gt; (a , b)({VV : a | (VV = c)}c, {VV : (GHC.Types.Int) | (VV = (1  :  int))}1)) \n</pre> <p>You can take it out for a spin like so:</p> <pre>336: [((GHC.Types.Char) , (GHC.Types.Int))]f0 = [[(GHC.Types.Char)]] -&gt; [((GHC.Types.Char) , (GHC.Types.Int))]charFrequency [ {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"the\", {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"quick\" , {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"brown\"\n337:                    , {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"fox\", {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"jumped\", {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"over\"\n338:                    , {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"the\", {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"lazy\"  , {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"cow\"   ]\n</pre> <p>Look Ma! No Types: LiquidHaskell will gobble the whole thing up, and verify that none of the undesirable <code>liquidError</code> calls are triggered. By the way, notice that we didn't write down any types for <code>mapReduce</code> and friends.  The main invariant, from which safety follows is that the <code>Map</code> returned by the <code>group</code> function binds each key to a non-empty list of values.  LiquidHaskell deduces this invariant by inferring suitable types for <code>group</code>, <code>inserts</code>, <code>foldl1</code> and <code>reduce</code>, thereby relieving us of that tedium. In short, by riding on the broad and high shoulders of SMT and abstract interpretation, LiquidHaskell makes a little typing go a long way. </p>","tags":["measures"]},{"location":"blogposts/2013-01-31-safely-catching-a-list-by-its-tail.lhs/#conclusions","title":"Conclusions","text":"<p>Well folks, thats all for now. I trust this article gave you a sense of</p> <ol> <li> <p>How we can describe certain structural properties of data types,     such as the length of a list, </p> </li> <li> <p>How we might use refinements over these properties to describe key    invariants and establish, at compile-time, the safety of operations that    might blow up on unexpected values at run-time, and perhaps, most    importantly,</p> </li> <li> <p>How we can achieve the above, whilst just working with good old lists,     without having to make up new types (which have the     unfortunate effect of cluttering programs with their attendant new     functions) in order to enforce special invariants.</p> </li> </ol>","tags":["measures"]},{"location":"blogposts/2013-02-16-kmeans-clustering-I.lhs/","title":"KMeans Clustering I","text":"<p>Last time we introduced a new specification mechanism called a measure and demonstrated how to use it to encode the length of a list. We saw how measures could be used to verify that functions like <code>head</code> and <code>tail</code> were only called with non-empty lists (whose length was strictly positive). As several folks pointed out, once LiquidHaskell can reason about lengths, it can do a lot more than just analyze non-emptiness.</p> <p>Indeed!</p> <p>Over the next two posts, lets see how one might implement a Kmeans algorithm that clusters <code>n</code>-dimensional points groups, and how LiquidHaskell can help us write and enforce various dimensionality invariants along the way.</p> <pre>33: module KMeansHelper where\n34: \n35: import Prelude                          hiding  (zipWith)\n36: import Data.List                                (span)\n37: import Language.Haskell.Liquid.Prelude          (liquidError)\n</pre> <p>Rather than reinvent the wheel, we will modify an existing implementation of K-Means, available on hackage. This may not be the most efficient implementation, but its a nice introduction to the algorithm, and the general invariants will hold for more sophisticated implementations.</p> <p>We have broken this entry into two convenient, bite-sized chunks:</p> <ul> <li> <p>Part I  Introduces the basic types and list operations needed by KMeans,</p> </li> <li> <p>Part II Describes how the operations are used in the KMeans implementation.</p> </li> </ul>","tags":["basic","measures"]},{"location":"blogposts/2013-02-16-kmeans-clustering-I.lhs/#the-game-clustering-points","title":"The Game: Clustering Points","text":"<p>The goal of K-Means clustering is the following. Given</p> <ul> <li> <p>Input : A set of points represented by n-dimensional points   in Euclidian space, return</p> </li> <li> <p>Output : A partitioning of the points, into K clusters, in a manner that   minimizes sum of distances between each point and its cluster center.</p> </li> </ul>","tags":["basic","measures"]},{"location":"blogposts/2013-02-16-kmeans-clustering-I.lhs/#the-players-types","title":"The Players: Types","text":"<p>Lets make matters concrete by creating types for the different elements of the algorithm.</p> <p>1. Fixed-Length Lists  We will represent n-dimensional points using good old Haskell lists, refined with a predicate that describes the dimensionality (i.e. length.) To simplify matters, lets package this into a type alias that denotes lists of a given length <code>N</code>.</p> <pre>75: {-@ type List a N = {v : [a] | (len v) = N} @-}\n</pre> <p>2. Points Next, we can represent an <code>N</code>-dimensional point as list of <code>Double</code> of length <code>N</code>,</p> <pre>81: {-@ type Point N = List Double N @-}\n</pre> <p>3. Clusters A cluster is a non-empty list of points,</p> <pre>87: {-@ type NonEmptyList a = {v : [a] | (len v) &gt; 0} @-}\n</pre> <p>4. Clustering And finally, a clustering is a list of (non-empty) clusters.</p> <pre>93: {-@ type Clustering a  = [(NonEmptyList a)] @-}\n</pre> <p>Notation: When defining refinement type aliases, we use uppercase variables like <code>N</code> to distinguish value- parameters from the lowercase type parameters like <code>a</code>.</p> <p>Aside: By the way, if you are familiar with the index-style length encoding e.g. as found in DML or Agda, then its worth noting that despite appearances, our <code>List</code> and <code>Point</code> definitions are not indexed. We're just using the indices to define abbreviations for the refinement predicates, and we have deliberately chosen the predicates to facilitate SMT based checking and inference.</p>","tags":["basic","measures"]},{"location":"blogposts/2013-02-16-kmeans-clustering-I.lhs/#basic-operations-on-points-and-clusters","title":"Basic Operations on Points and Clusters","text":"<p>Ok, with the types firmly in hand, let us go forth and develop the KMeans clustering implementation. We will use a variety of small helper functions (of the kind found in <code>Data.List</code>.) Lets get started by looking at them through our newly refined eyes.</p>","tags":["basic","measures"]},{"location":"blogposts/2013-02-16-kmeans-clustering-I.lhs/#grouping","title":"Grouping","text":"<p>The first such function is groupBy. We can refine its type so that instead of just producing a <code>[[a]]</code> we know that it produces a <code>Clustering a</code> which is a list of non-empty lists.</p> <pre>124: {-@ groupBy       ::(a -&gt; a -&gt; Bool) -&gt; [a] -&gt; (Clustering a) @-}\n125: (a -&gt; a -&gt; (GHC.Types.Bool))\n-&gt; [a] -&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) &gt;= 0)}groupBy _  []     = {VV : [{VV : [{VV : a | false}] | false}] | (len([VV]) = 0)}[]\n126: groupBy eq (x:xs) = ({VV : a | (VV = x)}xy:a -&gt; ys:[a] -&gt; {VV : [a] | (len([VV]) = (1 + len([ys])))}:{VV : [a] | (VV = ys),\n            (VV = ys),\n            (len([VV]) = len([ys])),\n            (len([VV]) &gt;= 0)}ys) y:{VV : [a] | (len([VV]) &gt; 0)}\n-&gt; ys:[{VV : [a] | (len([VV]) &gt; 0)}]\n-&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) = (1 + len([ys])))}: (a -&gt; a -&gt; (GHC.Types.Bool))\n-&gt; [a] -&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) &gt;= 0)}groupBy a -&gt; a -&gt; (GHC.Types.Bool)eq {VV : [a] | (VV = zs),\n            (VV = zs),\n            (len([VV]) = len([zs])),\n            (len([VV]) &gt;= 0)}zs\n127:   where ({VV : [a] | (VV = ys),(len([VV]) = len([ys])),(len([VV]) &gt;= 0)}ys,{VV : [a] | (VV = zs),(len([VV]) = len([zs])),(len([VV]) &gt;= 0)}zs)   = (a -&gt; (GHC.Types.Bool)) -&gt; [a] -&gt; ([a] , [a])span (a -&gt; a -&gt; (GHC.Types.Bool)eq {VV : a | (VV = x)}x) {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs\n</pre> <p>Intuitively, its pretty easy to see how LiquidHaskell verifies the refined specification:</p> <ul> <li>Each element of the output list is of the form <code>x:ys</code></li> <li>For any list <code>ys</code> the length is non-negative, i.e. <code>(len ys) &gt;= 0</code></li> <li>The <code>len</code> of <code>x:ys</code> is <code>1 + (len ys)</code>, that is, strictly positive.</li> </ul>","tags":["basic","measures"]},{"location":"blogposts/2013-02-16-kmeans-clustering-I.lhs/#partitioning","title":"Partitioning","text":"<p>Next, lets look the function</p> <pre>143: {-@ partition :: size:PosInt -&gt; [a] -&gt; (Clustering a) @-}\n144: {-@ type PosInt = {v: Int | v &gt; 0 } @-}\n</pre> <p>which is given a strictly positive integer argument, a list of <code>a</code> values, and returns a <code>Clustering a</code>, that is, a list of non-empty lists. (Each inner list has a length that is less than <code>size</code>, but we shall elide this for simplicity.)</p> <p>The function is implemented in a straightforward manner, using the library functions <code>take</code> and <code>drop</code></p> <pre>156: {VV : (GHC.Types.Int) | (VV &gt; 0)}\n-&gt; [a] -&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) &gt;= 0)}partition {VV : (GHC.Types.Int) | (VV &gt; 0)}size []       = {VV : [{VV : [{VV : a | false}] | false}] | (len([VV]) = 0)}[]\n157: partition size ys@(_:_) = {VV : [a] | (VV = zs),(len([VV]) &gt;= 0)}zs y:{VV : [a] | (len([VV]) &gt; 0)}\n-&gt; ys:[{VV : [a] | (len([VV]) &gt; 0)}]\n-&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) = (1 + len([ys])))}: {VV : (GHC.Types.Int) | (VV &gt; 0)}\n-&gt; [a] -&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) &gt;= 0)}partition {VV : (GHC.Types.Int) | (VV = size),(VV &gt; 0)}size {VV : [a] | (VV = zs'),(len([VV]) &gt;= 0)}zs'\n158:   where\n159:     [a]zs                  = n:{VV : (GHC.Types.Int) | (VV &gt;= 0)}\n-&gt; xs:[a]\n-&gt; {VV : [a] | (len([VV]) = ((len([xs]) &lt; n) ? len([xs]) : n))}take {VV : (GHC.Types.Int) | (VV = size),(VV &gt; 0)}size {VV : [a] | (len([VV]) &gt;= 0)}ys\n160:     [a]zs'                 = n:{VV : (GHC.Types.Int) | (VV &gt;= 0)}\n-&gt; xs:[a]\n-&gt; {VV : [a] | (len([VV]) = ((len([xs]) &lt; n) ? 0 : (len([xs]) - n)))}drop {VV : (GHC.Types.Int) | (VV = size),(VV &gt; 0)}size {VV : [a] | (len([VV]) &gt;= 0)}ys\n</pre> <p>To verify that a valid <code>Clustering</code> is produced, LiquidHaskell needs only verify that the list <code>zs</code> above is non-empty, by suitably connecting the properties of the inputs <code>size</code> and <code>ys</code> with the output.</p> <p>We have verified elsewhere that</p> <pre>168: take :: n:{v: Int | v &gt;= 0 }\n169:      -&gt; xs:[a]\n170:      -&gt; {v:[a] | (len v) = (if ((len xs) &lt; n) then (len xs) else n) }\n</pre> <p>In other words, the output list's length is the smaller of the input list's length and <code>n</code>.  Thus, since both <code>size</code> and the <code>(len ys)</code> are greater than <code>1</code>, LiquidHaskell deduces that the list returned by <code>take size ys</code> has a length greater than <code>1</code>, i.e., is non-empty.</p>","tags":["basic","measures"]},{"location":"blogposts/2013-02-16-kmeans-clustering-I.lhs/#zipping","title":"Zipping","text":"<p>To compute the Euclidean distance between two points, we will use the <code>zipWith</code> function. We must make sure that it is invoked on points with the same number of dimensions, so we write</p> <pre>186: {-@ zipWith :: (a -&gt; b -&gt; c)\n187:             -&gt; xs:[a] -&gt; (List b (len xs)) -&gt; (List c (len xs)) @-}\n188: (a -&gt; b -&gt; c)\n-&gt; x4:[a]\n-&gt; x2:{VV : [b] | (len([VV]) = len([x4])),(len([VV]) &gt;= 0)}\n-&gt; {VV : [c] | (len([VV]) = len([x4])),\n               (len([VV]) = len([x2])),\n               (len([VV]) &gt;= 0)}zipWith a -&gt; b -&gt; cf (a:as) (b:bs) = a -&gt; b -&gt; cf {VV : a | (VV = a)}a {VV : a | (VV = b)}b y:a -&gt; ys:[a] -&gt; {VV : [a] | (len([VV]) = (1 + len([ys])))}: (a -&gt; b -&gt; c)\n-&gt; x4:[a]\n-&gt; x2:{VV : [b] | (len([VV]) = len([x4])),(len([VV]) &gt;= 0)}\n-&gt; {VV : [c] | (len([VV]) = len([x4])),\n               (len([VV]) = len([x2])),\n               (len([VV]) &gt;= 0)}zipWith a -&gt; b -&gt; cf {VV : [a] | (VV = as),(len([VV]) &gt;= 0)}as {VV : [a] | (VV = bs),(len([VV]) &gt;= 0)}bs\n189: zipWith _ [] []         = {VV : [{VV : a | false}] | (len([VV]) = 0)}[]\n</pre> <p>The type stipulates that the second input list and the output have the same length as the first input. Furthermore, it rules out the case where one list is empty and the other is not, as in that case the former's length is zero while the latter's is not.</p>","tags":["basic","measures"]},{"location":"blogposts/2013-02-16-kmeans-clustering-I.lhs/#transposing","title":"Transposing","text":"<p>The last basic operation that we will require is a means to transpose a <code>Matrix</code>, which itself is just a list of lists:</p> <pre>204: {-@ type Matrix a Rows Cols = (List (List a Cols) Rows) @-}\n</pre> <p>The <code>transpose</code> operation flips the rows and columns. I confess that I can never really understand matrices without concrete examples, and even then, barely.</p> <p>So, lets say we have a matrix</p> <pre>212: m1  :: Matrix Int 4 2\n213: m1  =  [ [1, 2]\n214:        , [3, 4]\n215:        , [5, 6]\n216:        , [7, 8] ]\n</pre> <p>then the matrix <code>m2 = transpose 2 3 m1</code> should be</p> <pre>220: m2 :: Matrix Int 2 4\n221: m2  =  [ [1, 3, 5, 7]\n222:        , [2, 4, 6, 8] ]\n</pre> <p>We will use a <code>Matrix a m n</code> to represent a single cluster of <code>m</code> points each of which has <code>n</code> dimensions. We will transpose the matrix to make it easy to sum and average the points along each dimension, in order to compute the center of the cluster.</p> <p>As you can work out from the above, the code for <code>transpose</code> is quite straightforward: each output row is simply the list of <code>head</code>s of the input rows:</p> <pre>235: transpose       :: Int -&gt; Int -&gt; [[a]] -&gt; [[a]]\n236: \n237: c:(GHC.Types.Int)\n-&gt; r:{VV : (GHC.Types.Int) | (VV &gt; 0)}\n-&gt; {v : [{VV : [a] | (len([VV]) = c)}] | (len([v]) = r)}\n-&gt; {v : [{VV : [a] | (len([VV]) = r)}] | (len([v]) = c)}transpose 0 _ _ = {VV : [{VV : [{VV : a | false}] | false}] | (len([VV]) = 0)}[]\n238: \n239: transpose c r ((col00 : col01s) : row1s)\n240:   = {VV : [a] | (VV = row0'),(len([VV]) &gt;= 0)}row0' y:{VV : [a] | (len([VV]) = len([row0'])),\n              (len([VV]) = len([rest])),\n              (len([VV]) &gt; 0)}\n-&gt; ys:[{VV : [a] | (len([VV]) = len([row0'])),\n                   (len([VV]) = len([rest])),\n                   (len([VV]) &gt; 0)}]\n-&gt; {VV : [{VV : [a] | (len([VV]) = len([row0'])),\n                      (len([VV]) = len([rest])),\n                      (len([VV]) &gt; 0)}] | (len([VV]) = (1 + len([ys])))}: {v : [[a]] | (v = row1s'),(len([v]) &gt;= 0)}row1s'\n241:     where\n242:       [a]row0'  = {VV : a | (VV = col00)}col00  y:a -&gt; ys:[a] -&gt; {VV : [a] | (len([VV]) = (1 + len([ys])))}: {VV : [a] | (len([VV]) = len([row1s])),(len([VV]) &gt;= 0)}[ {VV : a | (VV = col0)}col0  | (col0 : _)  &lt;- {VV : [[a]] | (VV = row1s),(len([VV]) &gt;= 0)}row1s ]\n243:       [{VV : [a] | (len([VV]) = len([col01s])),(len([VV]) &gt;= 0)}]rest   = {VV : [a] | (VV = col01s),(len([VV]) &gt;= 0)}col01s y:{VV : [a] | (len([VV]) = len([col01s])),(len([VV]) &gt;= 0)}\n-&gt; ys:[{VV : [a] | (len([VV]) = len([col01s])),(len([VV]) &gt;= 0)}]\n-&gt; {VV : [{VV : [a] | (len([VV]) = len([col01s])),\n                      (len([VV]) &gt;= 0)}] | (len([VV]) = (1 + len([ys])))}: {VV : [{VV : [a] | (len([VV]) = len([col01s])),\n                   (len([VV]) &gt;= 0)}] | (len([VV]) = len([row1s])),(len([VV]) &gt;= 0)}[ {VV : [a] | (VV = col1s),(len([VV]) &gt;= 0)}col1s | (_ : col1s) &lt;- {VV : [[a]] | (VV = row1s),(len([VV]) &gt;= 0)}row1s ]\n244:       [[a]]row1s' = c:(GHC.Types.Int)\n-&gt; r:{VV : (GHC.Types.Int) | (VV &gt; 0)}\n-&gt; {v : [{VV : [a] | (len([VV]) = c)}] | (len([v]) = r)}\n-&gt; {v : [{VV : [a] | (len([VV]) = r)}] | (len([v]) = c)}transpose ((GHC.Types.Int)cx:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x - y))}-{VV : (GHC.Types.Int) | (VV = (1  :  int))}1) {VV : (GHC.Types.Int) | (VV &gt; 0)}r {VV : [{VV : [a] | (len([VV]) = len([col01s])),\n                   (len([VV]) &gt;= 0)}] | (VV = rest),(len([VV]) &gt;= 0)}rest\n</pre> <p>LiquidHaskell verifies that</p> <pre>250: {-@ transpose :: c:Int -&gt; r:PosInt -&gt; Matrix a r c -&gt; Matrix a c r @-}\n</pre> <p>Try to work it out for yourself on pencil and paper.</p> <p>If you like you can get a hint by seeing how LiquidHaskell figures it out. Lets work backwards.</p> <p>LiquidHaskell verifies the output type by inferring that</p> <pre>259: row0'        :: (List a r)\n260: row1s'       :: List (List a r) (c - 1) -- i.e. Matrix a (c - 1) r\n</pre> <p>and so, by simply using the measure-refined type for <code>:</code></p> <pre>264: (:)          :: x:a -&gt; xs:[a] -&gt; { v : [a] | (len v) = 1 + (len xs) }\n</pre> <p>LiquidHaskell deduces that</p> <pre>268: row0 : rows' :: List (List a r) c\n</pre> <p>That is,</p> <pre>272: row0 : rows' :: Matrix a c r\n</pre> <p>Excellent! Now, lets work backwards. How does it infer the types of <code>row0'</code> and <code>row1s'</code>?</p> <p>The first case is easy: <code>row0'</code> is just the list of heads of each row, hence a <code>List a r</code>.</p> <p>Now, lets look at <code>row1s'</code>. Notice that <code>row1s</code> is the matrix of all except the first row of the input Matrix, and so</p> <pre>280: row1s        :: Matrix a (r-1) c\n</pre> <p>and so, as</p> <pre>284: col01s       :: List a (c-1)\n285: col1s        :: List a (c-1)\n</pre> <p>LiquidHaskell deduces that since <code>rest</code> is the concatenation of <code>r-1</code> tails from <code>row1s</code></p> <pre>289: rest         = col01s : [ col1s | (_ : col1s) &lt;- row1s ]\n</pre> <p>the type of <code>rest</code> is</p> <pre>293: rest         :: List (List a (c - 1)) r\n</pre> <p>which is just</p> <pre>297: rest         :: Matrix a r (c-1)\n</pre> <p>Now, LiquidHaskell deduces <code>row1s' :: Matrix a (c-1) r</code> by inductively plugging in the output type of the recursive call, thereby checking the function's signature.</p> <p>Whew! That was a fair bit of work, wasn't it!</p> <p>Happily, we didn't have to do any of it. Instead, using the SMT solver, LiquidHaskell ploughs through calculations like that and guarantees to us that <code>transpose</code> indeed flips the dimensions of the inner and outer lists.</p> <p>Aside: Comprehensions vs. Map Incidentally, the code above is essentially that of <code>transpose</code> from the Prelude with some extra local variables for exposition. You could instead use a <code>map head</code> and <code>map tail</code> and I encourage you to go ahead and see for yourself.</p>","tags":["basic","measures"]},{"location":"blogposts/2013-02-16-kmeans-clustering-I.lhs/#intermission","title":"Intermission","text":"<p>Time for a break -- go see a cat video! -- or skip it, stretch your legs, and return post-haste for the next installment, in which we will use the types and functions described above, to develop the clustering algorithm.</p>","tags":["basic","measures"]},{"location":"blogposts/2013-02-17-kmeans-clustering-II.lhs/","title":"KMeans Clustering II","text":"<p>The story so far: Previously we saw</p> <ul> <li>how to encode <code>n</code>-dimensional points using plain old Haskell lists,</li> <li>how to encode a matrix with <code>r</code> rows and <code>c</code> columns as a list of lists,</li> <li>some basic operations on points and matrices via list-manipulating functions</li> </ul> <p>More importantly, we saw how easy it was to encode dimensionality with refinements over the <code>len</code> measure, thereby allowing LiquidHaskell to precisely track the dimensions across the various operations.</p> <p>Next, lets use the basic types and operations to develop the actual KMeans clustering algorithm, and, along the way, see how LiquidHaskell lets us write precise module contracts which will ward against various unpleasant lumpenexceptions.</p> <pre>30: {-# LANGUAGE ScopedTypeVariables, TypeSynonymInstances, FlexibleInstances #-}\n31: \n32: module KMeans (kmeans, kmeansGen) where\n33: \n34: import KMeansHelper\n35: import Prelude              hiding      (zipWith)\n36: import Data.List                        (sort, span, minimumBy)\n37: import Data.Function                    (on)\n38: import Data.Ord                         (comparing)\n39: import Language.Haskell.Liquid.Prelude  (liquidAssert, liquidError)\n40: \n41: instance (GHC.Classes.Eq (KMeans.WrapType [GHC.Types.Double] a))Eq (WrapType [Double] a) where\n42:    (==) = x:{VV : [{VV : (GHC.Types.Double) | false}] | false}\n-&gt; y:{VV : [{VV : (GHC.Types.Double) | false}] | false}\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x = y))}(==) ({VV : [{VV : (GHC.Types.Double) | false}] | false}\n -&gt; {VV : [{VV : (GHC.Types.Double) | false}] | false}\n -&gt; {VV : (GHC.Types.Bool) | false})\n-&gt; ({VV : (KMeans.WrapType {VV : [{VV : (GHC.Types.Double) | false}] | false} {VV : a | false}) | false}\n    -&gt; {VV : [{VV : (GHC.Types.Double) | false}] | false})\n-&gt; {VV : (KMeans.WrapType {VV : [{VV : (GHC.Types.Double) | false}] | false} {VV : a | false}) | false}\n-&gt; {VV : (KMeans.WrapType {VV : [{VV : (GHC.Types.Double) | false}] | false} {VV : a | false}) | false}\n-&gt; {VV : (GHC.Types.Bool) | false}`on` (KMeans.WrapType {VV : [{VV : (GHC.Types.Double) | false}] | false} {VV : a | false})\n-&gt; {VV : [{VV : (GHC.Types.Double) | false}] | false}getVect\n43: \n44: instance (GHC.Classes.Ord (KMeans.WrapType [GHC.Types.Double] a))Ord (WrapType [Double] a) where\n45:     compare = (GHC.Classes.Ord [GHC.Types.Double])comparing (KMeans.WrapType {VV : [{VV : (GHC.Types.Double) | false}] | false} {VV : a | false})\n-&gt; {VV : [{VV : (GHC.Types.Double) | false}] | false}getVect\n</pre> <p>Recall that we are using a modified version of an existing KMeans implementation. While not the swiftest implementation, it serves as a nice introduction to the algorithm, and the general invariants carry over to more sophisticated implementations.</p>","tags":["basic","measures"]},{"location":"blogposts/2013-02-17-kmeans-clustering-II.lhs/#a-quick-recap","title":"A Quick Recap","text":"<p>Before embarking on the journey, lets remind ourselves of our destination: the goal of K-Means clustering is</p> <ul> <li> <p>Take as Input : A set of points represented by n-dimensional points in Euclidian space</p> </li> <li> <p>Return as Ouptut : A partitioning of the points, into upto K clusters, in a manner that   minimizes the sum of distances between each point and its cluster center.</p> </li> </ul> <p>Last time, we introduced a variety of refinement type aliases for Haskell lists</p> <p>Fixed Length Lists</p> <pre>66: type List a N = {v : [a] | (len v) = N}\n</pre> <p>Non-empty Lists</p> <pre>70: type NonEmptyList a = {v : [a] | (len v) &gt; 0}\n</pre> <p>N-Dimensional Points</p> <pre>74: type Point N = List Double N\n</pre> <p>Matrices</p> <pre>78: type Matrix a Rows Cols = List (List a Cols) Rows\n</pre> <p>We also saw several basic list operations</p> <pre>82: groupBy   :: (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; (Clustering a)\n83: partition :: PosInt -&gt; [a] -&gt; (Clustering a)\n84: zipWith   :: (a -&gt; b -&gt; c) -&gt; xs:[a] -&gt; (List b (len xs)) -&gt; (List c (len xs))\n85: transpose :: c:Int -&gt; r:PosInt -&gt; Matrix a r c -&gt; Matrix a c r\n</pre> <p>whose types will prove essential in order to verify the invariants of the clustering algorithm. You might open the previous episode in a separate tab to keep those functions handy, but fear not, we will refresh our memory about them when we get around to using them below.</p>","tags":["basic","measures"]},{"location":"blogposts/2013-02-17-kmeans-clustering-II.lhs/#generalized-points","title":"Generalized Points","text":"<p>To be more flexible, we will support arbitrary points as long as they can be projected to Euclidian space. In addition to supporting, say, an image or a cat video as a point, this will allow us to weight different dimensions to different degrees.</p> <p>We represent generalized points with a record</p> <pre>104: data WrapType b a = WrapType {(KMeans.WrapType a b) -&gt; agetVect :: b, (KMeans.WrapType a b) -&gt; bgetVal :: a}\n</pre> <p>and we can define an alias that captures the dimensionality of the point</p> <pre>110: {-@ type GenPoint a N  = WrapType (Point N) a @-}\n</pre> <p>That is, <code>GenPoint a N</code> denotes a general <code>a</code> value that has an <code>N</code>-dimensional projection into Euclidean space.</p>","tags":["basic","measures"]},{"location":"blogposts/2013-02-17-kmeans-clustering-II.lhs/#algorithm-iterative-clustering","title":"Algorithm: Iterative Clustering","text":"<p>Terrific, now that all the pieces are in place lets look at the KMeans algorithm. We have implemented a function <code>kmeans'</code>, which takes as input a dimension <code>n</code>, the maximum number of clusters <code>k</code> (which must be positive), a list of generalized points of dimension <code>n</code>, and returns a <code>Clustering</code> (i.e. a list of non-empty lists) of the generalized points.</p> <p>So much verbiage -- a type is worth a thousand comments!</p> <pre>128: {-@ kmeans' :: n:Int\n129:             -&gt; k:PosInt\n130:             -&gt; points:[(GenPoint a n)]\n131:             -&gt; (Clustering (GenPoint a n)) @-}\n</pre> <p>There! Crisp and to the point. Sorry. Anyhoo, the function implements the above type.</p> <pre>138: n:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (VV &gt; 0)}\n-&gt; [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)]\n-&gt; [{v : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (len([v]) &gt; 0)}]kmeans' (GHC.Types.Int)n {VV : (GHC.Types.Int) | (VV &gt; 0)}k [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)]points    = (GHC.Classes.Eq [[KMeans.WrapType [GHC.Types.Double] a]])fixpoint (n:(GHC.Types.Int)\n-&gt; [{v : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (len([v]) &gt; 0)}]\n-&gt; [{v : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (len([v]) &gt; 0)}]refineCluster {VV : (GHC.Types.Int) | (VV = n)}n) {VV : [{VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                            (len([VV]) = n)} a)] | (len([VV]) &gt; 0)}] | (VV = initialClustering),\n                                                                                                       (len([VV]) &gt;= 0)}initialClustering\n139:   where\n140:     [{VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                      (len([VV]) = n)} a)] | (len([VV]) &gt; 0)}]initialClustering = {VV : (GHC.Types.Int) | (VV &gt; 0)}\n-&gt; [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                  (len([VV]) = n)} a)]\n-&gt; [{VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                         (len([VV]) = n)} a)] | (len([VV]) &gt; 0)}]partition {VV : (GHC.Types.Int) | (VV = clusterSize)}clusterSize {VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (VV = points),\n                                                                            (len([VV]) &gt;= 0)}points\n141:     (GHC.Types.Int)clusterSize       = x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (VV = ((x &gt; y) ? x : y))}max {VV : (GHC.Types.Int) | (VV = (1  :  int))}1 ((GHC.Types.Int)(xs:[(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                  (len([VV]) = n)} a)]\n-&gt; {VV : (GHC.Types.Int) | (VV = len([xs]))}length {VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (VV = points),\n                                                                            (len([VV]) &gt;= 0)}points x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x + y))}+ {VV : (GHC.Types.Int) | (VV = k),(VV &gt; 0)}k x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x - y))}- {VV : (GHC.Types.Int) | (VV = (1  :  int))}1) x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x / y))}`div` {VV : (GHC.Types.Int) | (VV = k),(VV &gt; 0)}k)\n142: \n143:     fixpoint          :: (Eq a) =&gt; (a -&gt; a) -&gt; a -&gt; a\n144:     (GHC.Classes.Eq a) -&gt; (a -&gt; a) -&gt; a -&gt; afixpoint a -&gt; af ax      = if (GHC.Types.Bool)(a -&gt; af {VV : a | (VV = x)}x) x:a\n-&gt; y:a -&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x = y))}== {VV : a | (VV = x)}x then {VV : a | (VV = x)}x else (GHC.Classes.Eq a) -&gt; (a -&gt; a) -&gt; a -&gt; afixpoint a -&gt; af (a -&gt; af {VV : a | (VV = x)}x)\n</pre> <p>That is, <code>kmeans'</code> creates an <code>initialClustering</code> by <code>partition</code>-ing the <code>points</code> into chunks with <code>clusterSize</code> elements. Then, it invokes <code>fixpoint</code> to iteratively refine the initial clustering  with <code>refineCluster</code> until it converges to a stable clustering that cannot be improved upon. This stable clustering is returned as the output.</p> <p>LiquidHaskell verifies that <code>kmeans'</code> adheres to the given signature in two steps.</p> <p>1. Initial Clustering</p> <p>First, LiquidHaskell determines from</p> <pre>159: max       :: (Ord a) =&gt; x:a -&gt; y:a -&gt; {v: a | (v &gt;= x) &amp;&amp; ( v &gt;= y) }\n</pre> <p>that <code>clusterSize</code> is strictly positive, and hence, from</p> <pre>163: partition :: size:PosInt -&gt; [a] -&gt; (Clustering a)\n</pre> <p>which we saw last time, that <code>initialClustering</code> is indeed a valid <code>Clustering</code> of <code>(GenPoint a n)</code>.</p> <p>2. Fixpoint</p> <p>Next, LiquidHaskell infers that at the call <code>fixpoint (refineCluster n) ...</code>, that the type parameter <code>a</code> of <code>fixpoint</code> can be instantiated with <code>Clustering (GenPoint a n)</code>.  This is because <code>initialClustering</code> is a valid clustering, as we saw above, and because <code>refineCluster</code> takes -- and returns -- valid <code>n</code>-dimensional clusterings, as we shall see below. Consequently, the value returned by <code>kmeans'</code> is also <code>Clustering</code> of <code>GenPoint a n</code> as required.</p>","tags":["basic","measures"]},{"location":"blogposts/2013-02-17-kmeans-clustering-II.lhs/#refining-a-clustering","title":"Refining A Clustering","text":"<p>Thus, the real work in KMeans happens inside <code>refineCluster</code>, which takes a clustering and improves it, like so:</p> <pre>186: n:(GHC.Types.Int)\n-&gt; [{v : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (len([v]) &gt; 0)}]\n-&gt; [{v : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (len([v]) &gt; 0)}]refineCluster (GHC.Types.Int)n [{v : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (len([v]) &gt; 0)}]clusters = {VV : [{VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                            (len([VV]) = n),\n                                                            (len([VV]) &gt;= 0)} a)] | (len([VV]) &gt; 0)}] | (VV = clusters'),\n                                                                                                        (len([VV]) = len([centeredGroups])),\n                                                                                                        (len([VV]) &gt;= 0)}clusters'\n187:   where\n188:     -- 1. Compute cluster centers\n189:     {VV : [{VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                    (len([VV]) = n)}] | (len([VV]) = len([clusters]))}centers        = ({VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                      (len([VV]) = n)} a)] | (len([VV]) &gt; 0)}\n -&gt; {VV : [(GHC.Types.Double)] | (n = len([VV])),(len([VV]) = n)})\n-&gt; xs:[{VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                            (len([VV]) = n)} a)] | (len([VV]) &gt; 0)}]\n-&gt; {VV : [{VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                       (len([VV]) = n)}] | (len([VV]) = len([xs]))}map (n:(GHC.Types.Int)\n-&gt; {v : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (len([v]) &gt; 0)}\n-&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = n)}clusterCenter {VV : (GHC.Types.Int) | (VV = n)}n) {VV : [{v : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (len([v]) &gt; 0)}] | (VV = clusters),\n                                                                                                     (len([VV]) &gt;= 0)}clusters\n190: \n191:     -- 2. Map points to their nearest center\n192:     [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                               (len([VV]) = n)} a)]points         = [[(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                (len([VV]) = n)} a)]]\n-&gt; [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                  (len([VV]) = n)} a)]concat {VV : [{v : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (len([v]) &gt; 0)}] | (VV = clusters),\n                                                                                                     (len([VV]) &gt;= 0)}clusters\n193:     [({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                               (len([VV]) = n),\n                               (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                 (len([VV]) = n),\n                                                                                                 (len([VV]) &gt;= 0)} a))]centeredPoints = (GHC.Classes.Ord\n  ([GHC.Types.Double], KMeans.WrapType [GHC.Types.Double] a))sort {VV : [({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                     (len([VV]) = n),\n                                     (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                       (len([VV]) = n),\n                                                                                                       (len([VV]) &gt;= 0)} a))] | (len([VV]) = len([points])),\n                                                                                                                                (len([VV]) &gt;= 0)}[({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                              (len([VV]) = n),\n                              (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                (len([VV]) = n),\n                                                                                                (len([VV]) &gt;= 0)} a))(n:(GHC.Types.Int)\n-&gt; (KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)\n-&gt; [{VV : [(GHC.Types.Double)] | (len([VV]) = n)}]\n-&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = n)}nearestCenter {VV : (GHC.Types.Int) | (VV = n)}n (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                              (len([VV]) = n)} a)p {VV : [{VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                    (len([VV]) = n)}] | (VV = centers),\n                                                        (len([VV]) = len([clusters])),\n                                                        (len([VV]) &gt;= 0)}centers, (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                              (len([VV]) = n)} a)p) | p &lt;- {VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                     (len([VV]) = n)} a)] | (VV = points),\n                                                                            (len([VV]) &gt;= 0)}points]\n194: \n195:     -- 3. Group points by nearest center to get new clusters\n196:     [{VV : [({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                      (len([VV]) = n),\n                                      (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                        (len([VV]) = n),\n                                                                                                        (len([VV]) &gt;= 0)} a))] | (len([VV]) &gt; 0)}]centeredGroups = (({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                               (len([VV]) = n),\n                               (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                 (len([VV]) = n),\n                                                                                                 (len([VV]) &gt;= 0)} a))\n -&gt; ({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                  (len([VV]) = n),\n                                  (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                    (len([VV]) = n),\n                                                                                                    (len([VV]) &gt;= 0)} a))\n -&gt; (GHC.Types.Bool))\n-&gt; [({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                  (len([VV]) = n),\n                                  (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                    (len([VV]) = n),\n                                                                                                    (len([VV]) &gt;= 0)} a))]\n-&gt; [{VV : [({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                         (len([VV]) = n),\n                                         (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                           (len([VV]) = n),\n                                                                                                           (len([VV]) &gt;= 0)} a))] | (len([VV]) &gt; 0)}]groupBy ((GHC.Classes.Eq [GHC.Types.Double])(==) ({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                              (len([VV]) = n),\n                              (len([VV]) &gt;= 0)}\n -&gt; {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                 (len([VV]) = n),\n                                 (len([VV]) &gt;= 0)}\n -&gt; (GHC.Types.Bool))\n-&gt; (({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                  (len([VV]) = n),\n                                  (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                    (len([VV]) = n),\n                                                                                                    (len([VV]) &gt;= 0)} a))\n    -&gt; {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                    (len([VV]) = n),\n                                    (len([VV]) &gt;= 0)})\n-&gt; ({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                 (len([VV]) = n),\n                                 (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                   (len([VV]) = n),\n                                                                                                   (len([VV]) &gt;= 0)} a))\n-&gt; ({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                 (len([VV]) = n),\n                                 (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                   (len([VV]) = n),\n                                                                                                   (len([VV]) &gt;= 0)} a))\n-&gt; (GHC.Types.Bool)`on` ({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                              (len([VV]) = n),\n                              (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                (len([VV]) = n),\n                                                                                                (len([VV]) &gt;= 0)} a))\n-&gt; {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                (len([VV]) = n),\n                                (len([VV]) &gt;= 0)}fst) {VV : [({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                     (len([VV]) = n),\n                                     (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                       (len([VV]) = n),\n                                                                                                       (len([VV]) &gt;= 0)} a))] | (VV = centeredPoints),\n                                                                                                                                (len([VV]) &gt;= 0)}centeredPoints\n197:     {VV : [{VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                            (len([VV]) = n),\n                                                            (len([VV]) &gt;= 0)} a)] | (len([VV]) &gt; 0)}] | (len([VV]) = len([centeredGroups]))}clusters'      = ({VV : [({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                      (len([VV]) = n),\n                                      (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                        (len([VV]) = n),\n                                                                                                        (len([VV]) &gt;= 0)} a))] | (len([VV]) &gt; 0)}\n -&gt; {VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                         (len([VV]) = n),\n                                                         (len([VV]) &gt;= 0)} a)] | (len([VV]) &gt; 0)})\n-&gt; xs:[{VV : [({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                            (len([VV]) = n),\n                                            (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                              (len([VV]) = n),\n                                                                                                              (len([VV]) &gt;= 0)} a))] | (len([VV]) &gt; 0)}]\n-&gt; {VV : [{VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                               (len([VV]) = n),\n                                                               (len([VV]) &gt;= 0)} a)] | (len([VV]) &gt; 0)}] | (len([VV]) = len([xs]))}map ((({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                               (len([VV]) = n),\n                               (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                 (len([VV]) = n),\n                                                                                                 (len([VV]) &gt;= 0)} a))\n -&gt; (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                  (len([VV]) = n),\n                                                  (len([VV]) &gt;= 0)} a))\n-&gt; xs:[({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                     (len([VV]) = n),\n                                     (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                       (len([VV]) = n),\n                                                                                                       (len([VV]) &gt;= 0)} a))]\n-&gt; {VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                        (len([VV]) = n),\n                                                        (len([VV]) &gt;= 0)} a)] | (len([VV]) = len([xs]))}map ({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                              (len([VV]) = n),\n                              (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                (len([VV]) = n),\n                                                                                                (len([VV]) &gt;= 0)} a))\n-&gt; (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                 (len([VV]) = n),\n                                                 (len([VV]) &gt;= 0)} a)snd) {VV : [{VV : [({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                            (len([VV]) = n),\n                                            (len([VV]) &gt;= 0)} , (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                                                                              (len([VV]) = n),\n                                                                                                              (len([VV]) &gt;= 0)} a))] | (len([VV]) &gt; 0)}] | (VV = centeredGroups),\n                                                                                                                                                           (len([VV]) &gt;= 0)}centeredGroups\n</pre> <p>The behavior of <code>refineCluster</code> is pithily captured by its type</p> <pre>203: {-@ refineCluster :: n:Int\n204:                   -&gt; Clustering (GenPoint a n)\n205:                   -&gt; Clustering (GenPoint a n) @-}\n</pre> <p>The refined clustering is computed in three steps.</p> <ol> <li> <p>First, we compute the <code>centers :: [(Point n)]</code> of the current <code>clusters</code>.    This is achieved by using <code>clusterCenter</code>, which maps a list of generalized    <code>n</code>-dimensional points to a single <code>n</code> dimensional point (i.e. <code>Point n</code>).</p> </li> <li> <p>Next, we pair each point <code>p</code> in the list of all <code>points</code> with its <code>nearestCenter</code>.</p> </li> <li> <p>Finally, the pairs in the list of <code>centeredPoints</code> are grouped by the    center, i.e. the first element of the tuple. The resulting groups are    projected back to the original generalized points yielding the new    clustering.</p> </li> </ol> <p>The type of the output follows directly from</p> <pre>222: groupBy :: (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; (Clustering a)\n</pre> <p>from last time. At the call site above, LiquidHaskell infers that <code>a</code> can be instantiated with <code>((Point n), (GenPoint a n))</code> thereby establishing that, after projecting away the first element, the output is a list of non-empty lists of generalized <code>n</code>-dimensional points.</p> <p>That leaves us with the two crucial bits of the algorithm: <code>clusterCenter</code> and <code>nearestCenter</code>.</p>","tags":["basic","measures"]},{"location":"blogposts/2013-02-17-kmeans-clustering-II.lhs/#computing-the-center-of-a-cluster","title":"Computing the Center of a Cluster","text":"<p>The center of an <code>n</code>-dimensional cluster is simply an <code>n</code>-dimensional point whose value in each dimension is equal to the average value of that dimension across all the points in the cluster.</p> <p>For example, consider a cluster of 2-dimensional points,</p> <pre>241: exampleCluster = [ [0,  0]\n242:                  , [1, 10]\n243:                  , [2, 20]\n244:                  , [4, 40]\n245:                  , [5, 50] ]\n</pre> <p>The center of the cluster is</p> <pre>249: exampleCenter = [ (0 + 1  + 2  + 4  + 5 ) / 5\n250:                 , (0 + 10 + 20 + 40 + 50) / 5 ]\n</pre> <p>which is just</p> <pre>254: exampleCenter = [ 3, 30 ]\n</pre> <p>Thus, we can compute a <code>clusterCenter</code> via the following procedure</p> <pre>260: n:(GHC.Types.Int)\n-&gt; {v : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (len([v]) &gt; 0)}\n-&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = n)}clusterCenter (GHC.Types.Int)n {v : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (len([v]) &gt; 0)}xs = ({VV : [(GHC.Types.Double)] | (numPoints = len([VV])),\n                              (len([VV]) = numPoints),\n                              (len([VV]) = len([xs])),\n                              (len([VV]) &gt; 0)}\n -&gt; (GHC.Types.Double))\n-&gt; xs:[{VV : [(GHC.Types.Double)] | (numPoints = len([VV])),\n                                    (len([VV]) = numPoints),\n                                    (len([VV]) = len([xs])),\n                                    (len([VV]) &gt; 0)}]\n-&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = len([xs]))}map {VV : [(GHC.Types.Double)] | (numPoints = len([VV])),\n                             (len([VV]) = numPoints),\n                             (len([VV]) = len([xs])),\n                             (len([VV]) &gt; 0)}\n-&gt; (GHC.Types.Double)average {v : [{VV : [(GHC.Types.Double)] | (len([VV]) = numPoints)}] | (v = xs'),\n                                                               (len([v]) = n),\n                                                               (len([v]) &gt;= 0)}xs'\n261:   where\n262:     {VV : (GHC.Types.Int) | (VV = len([xs]))}numPoints      = xs:[(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                  (len([VV]) = n)} a)]\n-&gt; {VV : (GHC.Types.Int) | (VV = len([xs]))}length {v : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (v = xs),\n                                                                           (len([v]) &gt; 0),\n                                                                           (len([v]) &gt;= 0)}xs\n263:     {v : [{VV : [(GHC.Types.Double)] | (len([VV]) = numPoints)}] | (len([v]) = n)}xs'            = c:(GHC.Types.Int)\n-&gt; r:{VV : (GHC.Types.Int) | (VV &gt; 0)}\n-&gt; {v : [{VV : [(GHC.Types.Double)] | (len([VV]) = c)}] | (len([v]) = r)}\n-&gt; {v : [{VV : [(GHC.Types.Double)] | (len([VV]) = r)}] | (len([v]) = c)}transpose {VV : (GHC.Types.Int) | (VV = n)}n {VV : (GHC.Types.Int) | (VV = numPoints),(VV = len([xs]))}numPoints (((KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                               (len([VV]) = n)} a)\n -&gt; {VV : [(GHC.Types.Double)] | (n = len([VV])),(len([VV]) = n)})\n-&gt; xs:[(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                     (len([VV]) = n)} a)]\n-&gt; {VV : [{VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                       (len([VV]) = n)}] | (len([VV]) = len([xs]))}map (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                              (len([VV]) = n)} a)\n-&gt; {VV : [(GHC.Types.Double)] | (n = len([VV])),(len([VV]) = n)}getVect {v : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (v = xs),\n                                                                           (len([v]) &gt; 0),\n                                                                           (len([v]) &gt;= 0)}xs)\n264: \n265:     average        :: [Double] -&gt; Double\n266:     {VV : [(GHC.Types.Double)] | (numPoints = len([VV])),\n                             (len([VV]) = numPoints),\n                             (len([VV]) = len([xs])),\n                             (len([VV]) &gt; 0)}\n-&gt; (GHC.Types.Double)average        = ((GHC.Types.Double)\n-&gt; {VV : (GHC.Types.Int) | (VV &gt; 0)} -&gt; (GHC.Types.Double)`safeDiv` {VV : (GHC.Types.Int) | (VV = numPoints),(VV = len([xs]))}numPoints) ((GHC.Types.Double) -&gt; (GHC.Types.Double))\n-&gt; ({VV : [(GHC.Types.Double)] | (numPoints = len([VV])),\n                                 (len([VV]) = numPoints),\n                                 (len([VV]) = len([xs])),\n                                 (len([VV]) &gt; 0)}\n    -&gt; (GHC.Types.Double))\n-&gt; {VV : [(GHC.Types.Double)] | (numPoints = len([VV])),\n                                (len([VV]) = numPoints),\n                                (len([VV]) = len([xs])),\n                                (len([VV]) &gt; 0)}\n-&gt; (GHC.Types.Double). [(GHC.Types.Double)] -&gt; (GHC.Types.Double)sum\n</pre> <p>First, we <code>transpose</code> the matrix of points in the cluster. Suppose that <code>xs</code> is the <code>exampleCluster</code> from above (and so <code>n</code> is <code>2</code> and <code>numPoints</code> is <code>5</code>.)</p> <p>In this scenario, <code>xs'</code> is</p> <pre>274: xs' = [ [0,  1,  2,  4,  5]\n275:       , [0, 10, 20, 40, 50] ]\n</pre> <p>and so <code>map average xs'</code> evaluates to <code>exampleCenter</code> from above.</p> <p>We have ensured that the division in the average does not lead to any nasty surprises via a safe division function whose precondition checks that the denominator is non-zero, as illustrated here.</p> <pre>285: {- safeDiv   :: (Fractional a) =&gt; a -&gt; {v:Int | v != 0} -&gt; a -}\n286: safeDiv     :: (Fractional a) =&gt; a -&gt; Int -&gt; a\n287: (GHC.Real.Fractional a)\n-&gt; a -&gt; {VV : (GHC.Types.Int) | (VV &gt; 0)} -&gt; asafeDiv an 0 = {VV : [(GHC.Types.Char)] | false} -&gt; {VV : a | false}liquidError {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"divide by zero\"\n288: safeDiv n d = {VV : a | (VV = n)}n x:a -&gt; y:{VV : a | (VV != 0)} -&gt; {VV : a | (VV = (x / y))}/ ((GHC.Num.Num a)fromIntegral {VV : (GHC.Types.Int) | (VV &gt; 0)}d)\n</pre> <p>LiquidHaskell verifies that the divide-by-zero never occurs, and furthermore, that <code>clusterCenter</code> indeed computes an <code>n</code>-dimensional center by inferring that</p> <pre>295: {-@ clusterCenter :: n:Int -&gt; NonEmptyList (GenPoint a n) -&gt; Point n @-}\n</pre> <p>LiquidHaskell deduces that the input list of points <code>xs</code> is non-empty from the fact that <code>clusterCenter</code> is only invoked on the elements of a <code>Clustering</code> which comprise only non-empty lists. Since <code>xs</code> is non-empty, i.e. <code>(len xs) &gt; 0</code>, LiquidHaskell infers that <code>numPoints</code> is positive (hover over <code>length</code> to understand why), and hence, LiquidHaskell is satisfied that the call to <code>safeDiv</code> will always proceed without any incident.</p> <p>To establish the output type <code>Point n</code> LiquidHaskell leans on the fact that</p> <pre>307: transpose :: n:Int -&gt; m:PosInt -&gt; Matrix a m n -&gt; Matrix a n m\n</pre> <p>to deduce that <code>xs'</code> is of type <code>Matrix Double n numPoints</code>, that is to say, a list of length <code>n</code> containing lists of length <code>numPoints</code>. Since <code>map</code> preserves the length, the value <code>map average xs'</code> is also a list of length <code>n</code>, i.e. <code>Point n</code>.</p>","tags":["basic","measures"]},{"location":"blogposts/2013-02-17-kmeans-clustering-II.lhs/#finding-the-nearest-center","title":"Finding the Nearest Center","text":"<p>The last piece of the puzzle is <code>nearestCenter</code> which maps each (generalized) point to the center that it is nearest. The code is pretty self-explanatory:</p> <pre>324: nearestCenter     :: Int -&gt; WrapType [Double] a -&gt; [[Double]] -&gt; [Double]\n325: n:(GHC.Types.Int)\n-&gt; (KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)\n-&gt; [{VV : [(GHC.Types.Double)] | (len([VV]) = n)}]\n-&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = n)}nearestCenter (GHC.Types.Int)n (KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)x = {VV : [({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                     (len([VV]) = n),\n                                     (len([VV]) &gt;= 0)} , (GHC.Types.Double))] | (len([VV]) &gt;= 0)}\n-&gt; {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                (len([VV]) = n),\n                                (len([VV]) &gt;= 0)}minKey ({VV : [({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                      (len([VV]) = n),\n                                      (len([VV]) &gt;= 0)} , (GHC.Types.Double))] | (len([VV]) &gt;= 0)}\n -&gt; {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                 (len([VV]) = n),\n                                 (len([VV]) &gt;= 0)})\n-&gt; ([{VV : [(GHC.Types.Double)] | (n = len([VV])),(len([VV]) = n)}]\n    -&gt; {VV : [({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                            (len([VV]) = n),\n                                            (len([VV]) &gt;= 0)} , (GHC.Types.Double))] | (len([VV]) &gt;= 0)})\n-&gt; [{VV : [(GHC.Types.Double)] | (n = len([VV])),(len([VV]) = n)}]\n-&gt; {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                (len([VV]) = n),\n                                (len([VV]) &gt;= 0)}. ({VV : [(GHC.Types.Double)] | (n = len([VV])),(len([VV]) = n)}\n -&gt; ({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                  (len([VV]) = n),\n                                  (len([VV]) &gt;= 0)} , (GHC.Types.Double)))\n-&gt; xs:[{VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                    (len([VV]) = n)}]\n-&gt; {VV : [({VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                        (len([VV]) = n),\n                                        (len([VV]) &gt;= 0)} , (GHC.Types.Double))] | (len([VV]) = len([xs]))}map (c:{VV : [(GHC.Types.Double)] | (n = len([VV])),(len([VV]) = n)}\n-&gt; ({VV : [(GHC.Types.Double)] | (VV = c),\n                                 (n = len([VV])),\n                                 (len([VV]) = n),\n                                 (len([VV]) = len([c])),\n                                 (len([VV]) &gt;= 0)} , (GHC.Types.Double))\\{VV : [(GHC.Types.Double)] | (n = len([VV])),(len([VV]) = n)}c -&gt; x1:a -&gt; b -&gt; (a , b)({VV : [(GHC.Types.Double)] | (VV = c),\n                             (n = len([VV])),\n                             (len([VV]) = n),\n                             (len([VV]) &gt;= 0)}c, a:{VV : [(GHC.Types.Double)] | (len([VV]) &gt;= 0)}\n-&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = len([a])),\n                                (len([VV]) &gt;= 0)}\n-&gt; (GHC.Types.Double)distance {VV : [(GHC.Types.Double)] | (VV = c),\n                             (n = len([VV])),\n                             (len([VV]) = n),\n                             (len([VV]) &gt;= 0)}c ((KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                              (len([VV]) = n),\n                                              (len([VV]) = len([c])),\n                                              (len([VV]) &gt;= 0)} a)\n-&gt; {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                (len([VV]) = n),\n                                (len([VV]) = len([c])),\n                                (len([VV]) &gt;= 0)}getVect {VV : (KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a) | (VV = x)}x)))\n</pre> <p>We <code>map</code> the centers to a tuple of center <code>c</code> and the <code>distance</code> between <code>x</code> and <code>c</code>, and then we select the tuple with the smallest distance</p> <pre>332: minKey  :: (Ord v) =&gt; [(k, v)] -&gt; k\n333: (GHC.Classes.Ord a) -&gt; {VV : [(b , a)] | (len([VV]) &gt;= 0)} -&gt; bminKey  = (a , b) -&gt; afst ((a , b) -&gt; a)\n-&gt; ({VV : [(a , b)] | (len([VV]) &gt;= 0)} -&gt; (a , b))\n-&gt; {VV : [(a , b)] | (len([VV]) &gt;= 0)}\n-&gt; a. ((a , b) -&gt; (a , b) -&gt; (GHC.Types.Ordering))\n-&gt; [(a , b)] -&gt; (a , b)minimumBy ((a , b) -&gt; (a , b) -&gt; (GHC.Types.Ordering)\\(a , b)x (a , b)y -&gt; x:a\n-&gt; y:a\n-&gt; {VV : (GHC.Types.Ordering) | ((VV = EQ) &lt;=&gt; (x = y)),\n                                ((VV = GT) &lt;=&gt; (x &gt; y)),\n                                ((VV = LT) &lt;=&gt; (x &lt; y))}compare ((a , b) -&gt; bsnd {VV : (a , b) | (VV = x)}x) ((a , b) -&gt; bsnd {VV : (a , b) | (VV = y)}y))\n</pre> <p>The interesting bit is that the <code>distance</code> function uses <code>zipWith</code> to ensure that the dimensionality of the center and the point match up.</p> <pre>340: distance     :: [Double] -&gt; [Double] -&gt; Double\n341: a:{VV : [(GHC.Types.Double)] | (len([VV]) &gt;= 0)}\n-&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = len([a])),\n                                (len([VV]) &gt;= 0)}\n-&gt; (GHC.Types.Double)distance {VV : [(GHC.Types.Double)] | (len([VV]) &gt;= 0)}a {VV : [(GHC.Types.Double)] | (len([VV]) = len([a])),\n                             (len([VV]) &gt;= 0)}b = (GHC.Types.Double) -&gt; (GHC.Types.Double)sqrt ((GHC.Types.Double) -&gt; (GHC.Types.Double))\n-&gt; ({VV : [(GHC.Types.Double)] | (len([VV]) = len([a])),\n                                 (len([VV]) = len([b])),\n                                 (len([VV]) &gt;= 0)}\n    -&gt; (GHC.Types.Double))\n-&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = len([a])),\n                                (len([VV]) = len([b])),\n                                (len([VV]) &gt;= 0)}\n-&gt; (GHC.Types.Double). [(GHC.Types.Double)] -&gt; (GHC.Types.Double)sum ({VV : [(GHC.Types.Double)] | (len([VV]) = len([a])),\n                              (len([VV]) = len([b])),\n                              (len([VV]) &gt;= 0)}\n -&gt; (GHC.Types.Double))\n-&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = len([a])),\n                                (len([VV]) = len([b])),\n                                (len([VV]) &gt;= 0)}\n-&gt; (GHC.Types.Double)$ ((GHC.Types.Double) -&gt; (GHC.Types.Double) -&gt; (GHC.Types.Double))\n-&gt; xs:[(GHC.Types.Double)]\n-&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = len([xs]))}\n-&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = len([xs]))}zipWith ((GHC.Types.Double) -&gt; (GHC.Types.Double) -&gt; (GHC.Types.Double)\\(GHC.Types.Double)v1 (GHC.Types.Double)v2 -&gt; {VV : (GHC.Integer.Type.Integer) | (VV = 2)}({VV : (GHC.Types.Double) | (VV = v1)}v1 x:(GHC.Types.Double)\n-&gt; y:(GHC.Types.Double)\n-&gt; {VV : (GHC.Types.Double) | (VV = (x - y))}- {VV : (GHC.Types.Double) | (VV = v2)}v2) (GHC.Types.Double)\n-&gt; (GHC.Integer.Type.Integer) -&gt; (GHC.Types.Double)^ 2) {VV : [(GHC.Types.Double)] | (VV = a),(len([VV]) &gt;= 0)}a {VV : [(GHC.Types.Double)] | (VV = b),\n                             (len([VV]) = len([a])),\n                             (len([VV]) &gt;= 0)}b\n</pre> <p>LiquidHaskell verifies <code>distance</code> by inferring that</p> <pre>347: {-@ nearestCenter :: n:Int -&gt; (GenPoint a n) -&gt; [(Point n)] -&gt; (Point n) @-}\n</pre> <p>First, LiquidHaskell deduces that each center in <code>cs</code> is indeed <code>n</code>-dimensional, which follows from the output type of <code>clusterCenter</code>. Since <code>x</code> is a <code>(GenPoint a n)</code> LiquidHaskell infers that both <code>c</code> and <code>getVect x</code> are of an equal length <code>n</code>.</p> <p>Consequently, the call to</p> <pre>355: zipWith :: (a -&gt; b -&gt; c) -&gt; xs:[a] -&gt; (List b (len xs)) -&gt; (List c (len xs))\n</pre> <p>discussed last time is determined to be safe.</p> <p>Finally, the value returned is just one of the input centers and so is a <code>(Point n)</code>.</p>","tags":["basic","measures"]},{"location":"blogposts/2013-02-17-kmeans-clustering-II.lhs/#putting-it-all-together-top-level-api","title":"Putting It All Together: Top-Level API","text":"<p>We can bundle the algorithm into two top-level API functions.</p> <p>First, a version that clusters generalized points. In this case, we require a function that can <code>project</code> an <code>a</code> value to an <code>n</code>-dimensional point. This function just wraps each <code>a</code>, clusters via <code>kmeans'</code> and then unwraps the points.</p> <pre>374: {-@ kmeansGen :: n:Int\n375:               -&gt; (a -&gt; (Point n))\n376:               -&gt; k:PosInt\n377:               -&gt; xs:[a]\n378:               -&gt; (Clustering a)\n379:   @-}\n380: \n381: n:(GHC.Types.Int)\n-&gt; (a -&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = n)})\n-&gt; {VV : (GHC.Types.Int) | (VV &gt; 0)}\n-&gt; [a]\n-&gt; [{VV : [a] | (len([VV]) &gt; 0)}]kmeansGen (GHC.Types.Int)n a -&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = n)}project {VV : (GHC.Types.Int) | (VV &gt; 0)}k = ({VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                      (len([VV]) = n)} a)] | (len([VV]) &gt; 0)}\n -&gt; {VV : [a] | (len([VV]) &gt; 0)})\n-&gt; xs:[{VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                            (len([VV]) = n)} a)] | (len([VV]) &gt; 0)}]\n-&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) = len([xs]))}map (((KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                               (len([VV]) = n)} a)\n -&gt; a)\n-&gt; xs:[(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                     (len([VV]) = n)} a)]\n-&gt; {VV : [a] | (len([VV]) = len([xs]))}map (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                              (len([VV]) = n)} a)\n-&gt; agetVal)\n382:                       ([{VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                       (len([VV]) = n)} a)] | (len([VV]) &gt; 0)}]\n -&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) &gt;= 0)})\n-&gt; ([a]\n    -&gt; [{VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                             (len([VV]) = n)} a)] | (len([VV]) &gt; 0)}])\n-&gt; [a]\n-&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) &gt;= 0)}. n:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (VV &gt; 0)}\n-&gt; [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)]\n-&gt; [{v : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (len([VV]) = n)} a)] | (len([v]) &gt; 0)}]kmeans' {VV : (GHC.Types.Int) | (VV = n)}n {VV : (GHC.Types.Int) | (VV = k),(VV &gt; 0)}k\n383:                       ({VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                      (len([VV]) = n),\n                                                      (len([VV]) &gt;= 0)} a)] | (len([VV]) &gt;= 0)}\n -&gt; [{VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                          (len([VV]) = n)} a)] | (len([VV]) &gt; 0)}])\n-&gt; ([a]\n    -&gt; {VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                            (len([VV]) = n),\n                                                            (len([VV]) &gt;= 0)} a)] | (len([VV]) &gt;= 0)})\n-&gt; [a]\n-&gt; [{VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                         (len([VV]) = n)} a)] | (len([VV]) &gt; 0)}]. (a\n -&gt; (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                  (len([VV]) = n),\n                                                  (len([VV]) &gt;= 0)} a))\n-&gt; xs:[a]\n-&gt; {VV : [(KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                        (len([VV]) = n),\n                                                        (len([VV]) &gt;= 0)} a)] | (len([VV]) = len([xs]))}map (x:a\n-&gt; (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                 (len([VV]) = n),\n                                                 (len([VV]) &gt;= 0)} {VV : a | (VV = x)})\\ax -&gt; {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                             (len([VV]) = n),\n                             (len([VV]) &gt;= 0)}\n-&gt; {VV : a | (VV = x)}\n-&gt; (KMeans.WrapType {VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                                 (len([VV]) = n),\n                                                 (len([VV]) &gt;= 0)} {VV : a | (VV = x)})WrapType (a -&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = n)}project {VV : a | (VV = x)}x) {VV : a | (VV = x)}x)\n</pre> <p>Second, a specialized version that operates directly on <code>n</code>-dimensional points. The specialized version just calls the general version with a trivial <code>id</code> projection.</p> <pre>391: {-@ kmeans :: n:Int\n392:            -&gt; k:PosInt\n393:            -&gt; points:[(Point n)]\n394:            -&gt; (Clustering (Point n))\n395:   @-}\n396: \n397: n:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (VV &gt; 0)}\n-&gt; [{VV : [(GHC.Types.Double)] | (len([VV]) = n)}]\n-&gt; [{v : [{VV : [(GHC.Types.Double)] | (len([VV]) = n)}] | (len([v]) &gt; 0)}]kmeans (GHC.Types.Int)n   = n:(GHC.Types.Int)\n-&gt; ({VV : [(GHC.Types.Double)] | (n = len([VV])),(len([VV]) = n)}\n    -&gt; {VV : [(GHC.Types.Double)] | (len([VV]) = n)})\n-&gt; {VV : (GHC.Types.Int) | (VV &gt; 0)}\n-&gt; [{VV : [(GHC.Types.Double)] | (n = len([VV])),(len([VV]) = n)}]\n-&gt; [{VV : [{VV : [(GHC.Types.Double)] | (n = len([VV])),\n                                        (len([VV]) = n)}] | (len([VV]) &gt; 0)}]kmeansGen {VV : (GHC.Types.Int) | (VV = n)}n x:{VV : [(GHC.Types.Double)] | (n = len([VV])),(len([VV]) = n)}\n-&gt; {VV : [(GHC.Types.Double)] | (VV = x),\n                                (n = len([VV])),\n                                (len([VV]) = n)}id\n</pre>","tags":["basic","measures"]},{"location":"blogposts/2013-02-17-kmeans-clustering-II.lhs/#conclusions","title":"Conclusions","text":"<p>I hope that over the last two posts you have gotten a sense of</p> <ol> <li> <p>What KMeans clustering is all about,</p> </li> <li> <p>How measures and refinements can be used to describe the behavior    of common list operations like <code>map</code>, <code>transpose</code>, <code>groupBy</code>, <code>zipWith</code>, and so on,</p> </li> <li> <p>How LiquidHaskell's automated inference makes it easy to write and    verify invariants of non-trivial programs.</p> </li> </ol> <p>The sharp reader will have noticed that the one major, non syntactic, change to the original code is the addition of the dimension parameter <code>n</code> throughout the code. This is critically required so that we can specify the relevant invariants (which are in terms of <code>n</code>.) The value is actually a ghost, and never ever used. Fortunately, Haskell's laziness means that we don't have to worry about it (or other ghost variables) imposing any run-time overhead at all.</p> <p>Exercise: Incidentally, if you have followed thus far I would encourage you to ponder about how you might modify the types (and implementation) to verify that KMeans indeed produces at most <code>k</code> clusters...</p>","tags":["basic","measures"]},{"location":"blogposts/2013-03-04-bounding-vectors.lhs/","title":"Bounding Vectors","text":"<p>Today, lets look at a classic use-case for refinement types, namely,  the static verification of vector access bounds. Along the way,  we'll see some examples that illustrate how LiquidHaskell reasons  about recursion, higher-order functions, data types, and  polymorphism.</p> <pre>22: module VectorBounds (\n23:     safeLookup \n24:   , unsafeLookup, unsafeLookup'\n25:   , absoluteSum, absoluteSum'\n26:   , dotProduct\n27:   , sparseProduct, sparseProduct'\n28:   ) where\n29: \n30: import Prelude      hiding (length)\n31: import Data.List    (foldl')\n32: import Data.Vector  hiding (foldl') \n</pre>","tags":["basic"]},{"location":"blogposts/2013-03-04-bounding-vectors.lhs/#specifying-bounds-for-vectors","title":"Specifying Bounds for Vectors","text":"<p>One classical use-case for refinement types is to verify the safety of accesses of arrays and vectors and such, by proving that the indices used in such accesses are within the vector bounds.  Lets see how to do this with LiquidHaskell by writing a few short functions that manipulate vectors, in particular, those from the  popular vector library. </p> <p>First things first. Lets specify bounds safety by refining  the types for the key functions exported by the module  <code>Data.Vector</code>. </p> <p>Specifications for <code>Data.Vector</code></p> <pre>50: module spec Data.Vector where\n51: \n52: import GHC.Base\n53: \n54: measure vlen  ::   (Vector a) -&gt; Int \n55: assume length :: x:(Vector a) -&gt; {v:Int | v = (vlen x)}\n56: assume !      :: x:(Vector a) -&gt; {v:Int | 0 &lt;= v &amp;&amp; v &lt; (vlen x)} -&gt; a \n</pre> <p>In particular, we </p> <ul> <li>define a property called <code>vlen</code> which denotes the size of the vector,</li> <li>assume that the <code>length</code> function returns an integer equal to the vector's size, and</li> <li>assume that the lookup function <code>!</code> requires an index between <code>0</code> and the vector's size.</li> </ul> <p>There are several things worth paying close attention to in the above snippet.</p> <p>Measures</p> <p>Recall that measures define auxiliary (or so-called ghost) properties of data values that are useful for specification and verification,  but which don't actually exist at run-time. Thus, they will  only appear in specifications, i.e. inside type refinements, but never  inside code. Often we will use helper functions like <code>length</code> in this case,  which pull or materialize the ghost values from the refinement world  into the actual code world.</p> <p>Assumes</p> <p>We write <code>assume</code> because in this scenario we are not verifying the implementation of <code>Data.Vector</code>, we are simply using the properties of the library to verify client code.  If we wanted to verify the library itself, we would ascribe the above types to the relevant functions in the Haskell source for <code>Data.Vector</code>. </p> <p>Dependent Refinements</p> <p>Notice that in the function type (e.g. for <code>length</code>) we have named the input parameter <code>x</code> so that we can refer to it in the output refinement. </p> <p>In this case, the type </p> <pre>91: assume length   :: x:(Vector a) -&gt; {v : Int | v = (vlen x)}\n</pre> <p>states that the <code>Int</code> output is exactly equal to the size of the input <code>Vector</code> named <code>x</code>.</p> <p>In other words, the output refinement depends on the input value, which crucially allows us to write properties that relate different program values.</p> <p>Verifying a Simple Wrapper</p> <p>Lets try write some simple functions to sanity check the above specifications.  First, consider an unsafe vector lookup function:</p> <pre>105: vec:(Data.Vector.Vector a)\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; vlen([vec])),(0 &lt;= VV)} -&gt; aunsafeLookup (Data.Vector.Vector a)vec {VV : (GHC.Types.Int) | (VV &lt; vlen([vec])),(0 &lt;= VV)}index = {VV : (Data.Vector.Vector a) | (VV = vec),(vlen([VV]) &gt;= 0)}vec x:(Data.Vector.Vector a)\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; a! {VV : (GHC.Types.Int) | (VV = index),(VV &lt; vlen([vec])),(0 &lt;= VV)}index\n</pre> <p>If we run this through LiquidHaskell, it will spit back a type error for the expression <code>x ! i</code> because (happily!) it cannot prove that <code>index</code> is between <code>0</code> and the <code>vlen vec</code>. Of course, we can specify the bounds  requirement in the input type</p> <pre>114: {-@ unsafeLookup :: vec:Vector a \n115:                  -&gt; {v: Int | (0 &lt;= v &amp;&amp; v &lt; (vlen vec))} \n116:                  -&gt; a \n117:   @-}\n</pre> <p>then LiquidHaskell is happy to verify the lookup. Of course, now the burden of ensuring the index is valid is pushed to clients of <code>unsafeLookup</code>.</p> <p>Instead, we might write a safe lookup function that performs the bounds check before looking up the vector:</p> <pre>127: {-@ safeLookup :: Vector a -&gt; Int -&gt; Maybe a @-}\n128: (Data.Vector.Vector a) -&gt; (GHC.Types.Int) -&gt; (Data.Maybe.Maybe a)safeLookup (Data.Vector.Vector a)x (GHC.Types.Int)i \n129:   | {VV : (GHC.Types.Int) | (VV = (0  :  int))}0 x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt;= y))}&lt;= {VV : (GHC.Types.Int) | (VV = i)}i x:(GHC.Types.Bool)\n-&gt; y:(GHC.Types.Bool)\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; &amp;&amp; [(? Prop([x]));\n                                                    (? Prop([y]))])}&amp;&amp; {VV : (GHC.Types.Int) | (VV = i)}i x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt; y))}&lt; x:(Data.Vector.Vector a)\n-&gt; {VV : (GHC.Types.Int) | (VV = vlen([x])),(VV &gt;= 0)}length {VV : (Data.Vector.Vector a) | (VV = x),(vlen([VV]) &gt;= 0)}x = x:a\n-&gt; {VV : (Data.Maybe.Maybe a) | ((? isJust([VV])) &lt;=&gt; true),\n                                (fromJust([VV]) = x)}Just ({VV : (Data.Vector.Vector a) | (VV = x),(vlen([VV]) &gt;= 0)}x x:(Data.Vector.Vector a)\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; a! {VV : (GHC.Types.Int) | (VV = i)}i)\n130:   | otherwise              = {VV : (Data.Maybe.Maybe {VV : a | false}) | ((? isJust([VV])) &lt;=&gt; false)}Nothing \n</pre> <p>Predicate Aliases</p> <p>The type for <code>unsafeLookup</code> above is rather verbose as we have to spell out the upper and lower bounds and conjoin them. Just as we enjoy abstractions when programming, we will find it handy to have abstractions in the specification mechanism. To this end, LiquidHaskell supports  predicate aliases, which are best illustrated by example</p> <pre>142: {-@ predicate Btwn Lo I Hi = (Lo &lt;= I &amp;&amp; I &lt; Hi) @-}\n143: {-@ predicate InBounds I A = (Btwn 0 I (vlen A)) @-}\n</pre> <p>Now, we can simplify the type for the unsafe lookup function to</p> <pre>149: {-@ unsafeLookup' :: x:Vector a -&gt; {v:Int | (InBounds v x)} -&gt; a @-}\n150: unsafeLookup' :: Vector a -&gt; Int -&gt; a\n151: x:(Data.Vector.Vector a)\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; aunsafeLookup' (Data.Vector.Vector a)x {VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)}i = {VV : (Data.Vector.Vector a) | (VV = x),(vlen([VV]) &gt;= 0)}x x:(Data.Vector.Vector a)\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; a! {VV : (GHC.Types.Int) | (VV = i),(VV &lt; vlen([x])),(0 &lt;= VV)}i\n</pre>","tags":["basic"]},{"location":"blogposts/2013-03-04-bounding-vectors.lhs/#our-first-recursive-function","title":"Our First Recursive Function","text":"<p>OK, with the tedious preliminaries out of the way, lets write some code!</p> <p>To start: a vanilla recursive function that adds up the absolute values of the elements of an integer vector.</p> <pre>164: absoluteSum       :: Vector Int -&gt; Int \n165: (Data.Vector.Vector (GHC.Types.Int))\n-&gt; {VV : (GHC.Types.Int) | (0 &lt;= VV)}absoluteSum (Data.Vector.Vector (GHC.Types.Int))vec   = x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}if {VV : (GHC.Types.Int) | (VV = (0  :  int))}0 x:{VV : (GHC.Types.Int) | (VV &gt;= 0),\n                          (0 &lt;= VV),\n                          (VV &lt;= n),\n                          (VV &lt;= vlen([vec]))}\n-&gt; y:{VV : (GHC.Types.Int) | (VV &gt;= 0),\n                             (0 &lt;= VV),\n                             (VV &lt;= n),\n                             (VV &lt;= vlen([vec]))}\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt; y))}&lt; {VV : (GHC.Types.Int) | (VV = n),(VV = vlen([vec])),(VV &gt;= 0)}n then x6:{VV : (GHC.Types.Int) | (VV = 0),\n                           (VV &lt; n),\n                           (VV &lt; vlen([vec])),\n                           (0 &lt;= VV)}\n-&gt; x4:{VV : (GHC.Types.Int) | (VV = 0),\n                              (VV = x6),\n                              (VV &lt; n),\n                              (VV &lt; vlen([vec])),\n                              (0 &lt;= VV),\n                              (x6 &lt;= VV)}\n-&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0),\n                           (VV &gt;= x6),\n                           (VV &gt;= x4),\n                           (0 &lt;= VV),\n                           (x6 &lt;= VV),\n                           (x4 &lt;= VV)}go {VV : (GHC.Types.Int) | (VV = (0  :  int))}0 {VV : (GHC.Types.Int) | (VV = (0  :  int))}0 else x:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV = (x  :  int))}0\n166:   where\n167:     x6:{VV : (GHC.Types.Int) | (VV = 0),\n                           (VV &lt; n),\n                           (VV &lt; vlen([vec])),\n                           (0 &lt;= VV)}\n-&gt; x4:{VV : (GHC.Types.Int) | (VV = 0),\n                              (VV = x6),\n                              (VV &lt; n),\n                              (VV &lt; vlen([vec])),\n                              (0 &lt;= VV),\n                              (x6 &lt;= VV)}\n-&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0),\n                           (VV &gt;= x6),\n                           (VV &gt;= x4),\n                           (0 &lt;= VV),\n                           (x6 &lt;= VV),\n                           (x4 &lt;= VV)}go {VV : (GHC.Types.Int) | (VV &gt;= 0),(0 &lt;= VV)}acc {VV : (GHC.Types.Int) | (VV &gt;= 0),\n                        (0 &lt;= VV),\n                        (VV &lt;= n),\n                        (VV &lt;= vlen([vec]))}i \n168:       | {VV : (GHC.Types.Int) | (VV = i),\n                        (VV &gt;= 0),\n                        (0 &lt;= VV),\n                        (VV &lt;= n),\n                        (VV &lt;= vlen([vec]))}i x:{VV : (GHC.Types.Int) | (VV &gt;= 0),\n                          (VV &gt;= i),\n                          (0 &lt;= VV),\n                          (VV &lt;= n),\n                          (VV &lt;= vlen([vec])),\n                          (i &lt;= VV)}\n-&gt; y:{VV : (GHC.Types.Int) | (VV &gt;= 0),\n                             (VV &gt;= i),\n                             (0 &lt;= VV),\n                             (VV &lt;= n),\n                             (VV &lt;= vlen([vec])),\n                             (i &lt;= VV)}\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x != y))}/= {VV : (GHC.Types.Int) | (VV = n),(VV = vlen([vec])),(VV &gt;= 0)}n    = x6:{VV : (GHC.Types.Int) | (VV = 0),\n                           (VV &lt; n),\n                           (VV &lt; vlen([vec])),\n                           (0 &lt;= VV)}\n-&gt; x4:{VV : (GHC.Types.Int) | (VV = 0),\n                              (VV = x6),\n                              (VV &lt; n),\n                              (VV &lt; vlen([vec])),\n                              (0 &lt;= VV),\n                              (x6 &lt;= VV)}\n-&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0),\n                           (VV &gt;= x6),\n                           (VV &gt;= x4),\n                           (0 &lt;= VV),\n                           (x6 &lt;= VV),\n                           (x4 &lt;= VV)}go ({VV : (GHC.Types.Int) | (VV = acc),(VV &gt;= 0),(0 &lt;= VV)}acc x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x + y))}+ n:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0),(VV &gt;= n)}abz ({VV : (Data.Vector.Vector (GHC.Types.Int)) | (VV = vec),\n                                             (vlen([VV]) &gt;= 0)}vec x:(Data.Vector.Vector (GHC.Types.Int))\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)}\n-&gt; (GHC.Types.Int)! {VV : (GHC.Types.Int) | (VV = i),\n                        (VV &gt;= 0),\n                        (0 &lt;= VV),\n                        (VV &lt;= n),\n                        (VV &lt;= vlen([vec]))}i)) ({VV : (GHC.Types.Int) | (VV = i),\n                        (VV &gt;= 0),\n                        (0 &lt;= VV),\n                        (VV &lt;= n),\n                        (VV &lt;= vlen([vec]))}i x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x + y))}+ {VV : (GHC.Types.Int) | (VV = (1  :  int))}1)\n169:       | otherwise = {VV : (GHC.Types.Int) | (VV = acc),(VV &gt;= 0),(0 &lt;= VV)}acc \n170:     {VV : (GHC.Types.Int) | (VV = vlen([vec])),(VV &gt;= 0)}n             = x:(Data.Vector.Vector (GHC.Types.Int))\n-&gt; {VV : (GHC.Types.Int) | (VV = vlen([x])),(VV &gt;= 0)}length {VV : (Data.Vector.Vector (GHC.Types.Int)) | (VV = vec),\n                                             (vlen([VV]) &gt;= 0)}vec\n</pre> <p>where the function <code>abz</code> is the absolute value function from before.</p> <pre>176: (GHC.Num.Num a)\n-&gt; (GHC.Classes.Ord a) -&gt; n:a -&gt; {VV : a | (VV &gt;= 0),(VV &gt;= n)}abz an = {VV : (GHC.Integer.Type.Integer) | (VV = 0)}if a0 x:a\n-&gt; y:a -&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt;= y))}&lt;= {VV : a | (VV = n)}n then {VV : a | (VV = n)}n else (a0 x:a -&gt; y:a -&gt; {VV : a | (VV = (x - y))}- {VV : a | (VV = n)}n) \n</pre>","tags":["basic"]},{"location":"blogposts/2013-03-04-bounding-vectors.lhs/#digression-introducing-errors","title":"Digression: Introducing Errors","text":"<p>If you are following along in the demo page -- I heartily  recommend that you try the following modifications,  one at a time, and see what happens.</p> <p>What happens if: </p> <ol> <li> <p>You remove the check <code>0 &lt; n</code> (see <code>absoluteSumNT</code> in the demo code)</p> </li> <li> <p>You replace the guard with <code>i &lt;= n</code></p> </li> </ol> <p>In the former case, LiquidHaskell will verify safety, but in the latter case, it will grumble that your program is unsafe. </p> <p>Do you understand why?  (Thanks to smog_alado for pointing this out :))</p>","tags":["basic"]},{"location":"blogposts/2013-03-04-bounding-vectors.lhs/#refinement-type-inference","title":"Refinement Type Inference","text":"<p>LiquidHaskell happily verifies <code>absoluteSum</code> -- or, to be precise,  the safety of the vector accesses <code>vec ! i</code>. The verification works  out because LiquidHaskell is able to automatically infer a suitable  type for <code>go</code>. Shuffle your mouse over the identifier above to see  the inferred type. Observe that the type states that the first  parameter <code>acc</code> (and the output) is <code>0 &lt;= V</code>. That is, the returned value is non-negative.</p> <p>More importantly, the type states that the second parameter <code>i</code> is  <code>0 &lt;= V</code> and <code>V &lt;= n</code> and <code>V &lt;= (vlen vec)</code>. That is, the parameter <code>i</code>  is between <code>0</code> and the vector length (inclusive). LiquidHaskell uses these  and the test that <code>i /= n</code> to establish that <code>i</code> is in fact between <code>0</code>  and <code>(vlen vec)</code> thereby verifing safety. </p> <p>In fact, if we want to use the function externally (i.e. in another module)  we can go ahead and strengthen its type to specify that the output is  non-negative.</p> <pre>221: {-@ absoluteSum :: Vector Int -&gt; {v: Int | 0 &lt;= v}  @-} \n</pre> <p>What happens if: You replace the output type for <code>absoluteSum</code> with <code>{v: Int | 0 &lt; v }</code> ?</p>","tags":["basic"]},{"location":"blogposts/2013-03-04-bounding-vectors.lhs/#bottling-recursion-with-a-higher-order-loop","title":"Bottling Recursion With a Higher-Order <code>loop</code>","text":"<p>Next, lets refactor the above low-level recursive function  into a generic higher-order <code>loop</code>.</p> <pre>233: loop :: Int -&gt; Int -&gt; a -&gt; (Int -&gt; a -&gt; a) -&gt; a \n234: lo:{VV : (GHC.Types.Int) | (0 &lt;= VV)}\n-&gt; hi:{VV : (GHC.Types.Int) | (lo &lt;= VV)}\n-&gt; a\n-&gt; ({VV : (GHC.Types.Int) | (VV &lt; hi),(lo &lt;= VV)} -&gt; a -&gt; a)\n-&gt; aloop {VV : (GHC.Types.Int) | (0 &lt;= VV)}lo {VV : (GHC.Types.Int) | (lo &lt;= VV)}hi abase {VV : (GHC.Types.Int) | (VV &lt; hi),(lo &lt;= VV)} -&gt; a -&gt; af = {VV : a | (VV = base)}\n-&gt; {VV : (GHC.Types.Int) | (VV = lo),\n                           (VV &gt;= 0),\n                           (0 &lt;= VV),\n                           (VV &lt;= hi),\n                           (lo &lt;= VV)}\n-&gt; ago {VV : a | (VV = base)}base {VV : (GHC.Types.Int) | (VV = lo),(0 &lt;= VV)}lo\n235:   where\n236:     {VV : a | (VV = base)}\n-&gt; {VV : (GHC.Types.Int) | (VV = lo),\n                           (VV &gt;= 0),\n                           (0 &lt;= VV),\n                           (VV &lt;= hi),\n                           (lo &lt;= VV)}\n-&gt; ago aacc {VV : (GHC.Types.Int) | (VV &gt;= 0),\n                        (VV &gt;= lo),\n                        (VV &gt;= lo),\n                        (0 &lt;= VV),\n                        (VV &lt;= hi),\n                        (VV &lt;= hi),\n                        (lo &lt;= VV),\n                        (lo &lt;= VV)}i     \n237:       | {VV : (GHC.Types.Int) | (VV = i),\n                        (VV &gt;= 0),\n                        (VV &gt;= lo),\n                        (VV &gt;= lo),\n                        (0 &lt;= VV),\n                        (VV &lt;= hi),\n                        (VV &lt;= hi),\n                        (lo &lt;= VV),\n                        (lo &lt;= VV)}i x:{VV : (GHC.Types.Int) | (VV &gt;= 0),\n                          (VV &gt;= i),\n                          (VV &gt;= lo),\n                          (VV &gt;= lo),\n                          (0 &lt;= VV),\n                          (VV &lt;= hi),\n                          (VV &lt;= hi),\n                          (i &lt;= VV),\n                          (lo &lt;= VV),\n                          (lo &lt;= VV)}\n-&gt; y:{VV : (GHC.Types.Int) | (VV &gt;= 0),\n                             (VV &gt;= i),\n                             (VV &gt;= lo),\n                             (VV &gt;= lo),\n                             (0 &lt;= VV),\n                             (VV &lt;= hi),\n                             (VV &lt;= hi),\n                             (i &lt;= VV),\n                             (lo &lt;= VV),\n                             (lo &lt;= VV)}\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x != y))}/= {VV : (GHC.Types.Int) | (VV = hi),\n                        (VV = hi),\n                        (VV &gt;= 0),\n                        (VV &gt;= lo),\n                        (VV &gt;= lo),\n                        (0 &lt;= VV),\n                        (hi &lt;= VV),\n                        (lo &lt;= VV),\n                        (lo &lt;= VV)}hi   = {VV : a | (VV = base)}\n-&gt; {VV : (GHC.Types.Int) | (VV = lo),\n                           (VV &gt;= 0),\n                           (0 &lt;= VV),\n                           (VV &lt;= hi),\n                           (lo &lt;= VV)}\n-&gt; ago ({VV : (GHC.Types.Int) | (VV &gt;= 0),\n                        (VV &gt;= lo),\n                        (VV &gt;= lo),\n                        (VV &lt; hi),\n                        (VV &lt; hi),\n                        (0 &lt;= VV),\n                        (lo &lt;= VV),\n                        (lo &lt;= VV)}\n-&gt; a -&gt; af {VV : (GHC.Types.Int) | (VV = i),\n                        (VV &gt;= 0),\n                        (VV &gt;= lo),\n                        (VV &gt;= lo),\n                        (0 &lt;= VV),\n                        (VV &lt;= hi),\n                        (VV &lt;= hi),\n                        (lo &lt;= VV),\n                        (lo &lt;= VV)}i {VV : a | (VV = acc)}acc) ({VV : (GHC.Types.Int) | (VV = i),\n                        (VV &gt;= 0),\n                        (VV &gt;= lo),\n                        (VV &gt;= lo),\n                        (0 &lt;= VV),\n                        (VV &lt;= hi),\n                        (VV &lt;= hi),\n                        (lo &lt;= VV),\n                        (lo &lt;= VV)}i x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x + y))}+ {VV : (GHC.Types.Int) | (VV = (1  :  int))}1)\n238:       | otherwise = {VV : a | (VV = acc)}acc\n</pre> <p>Using <code>loop</code> to compute <code>absoluteSum</code></p> <p>We can now use <code>loop</code> to implement <code>absoluteSum</code> like so:</p> <pre>246: (GHC.Num.Num a)\n-&gt; {VV : (Data.Vector.Vector {VV : a | false}) | false}\n-&gt; {VV : a | false}absoluteSum' {VV : (Data.Vector.Vector {VV : a | false}) | false}vec = {VV : (GHC.Integer.Type.Integer) | (VV = 0)}if {VV : (GHC.Types.Int) | (VV = (0  :  int))}0 x:{VV : (GHC.Types.Int) | false}\n-&gt; y:{VV : (GHC.Types.Int) | false}\n-&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt; y))}&lt; {VV : (GHC.Types.Int) | (VV = n),(VV = vlen([vec])),(VV &gt;= 0)}n then lo:{VV : (GHC.Types.Int) | (0 &lt;= VV)}\n-&gt; hi:{VV : (GHC.Types.Int) | (lo &lt;= VV)}\n-&gt; {VV : a | false}\n-&gt; ({VV : (GHC.Types.Int) | (VV &lt; hi),(lo &lt;= VV)}\n    -&gt; {VV : a | false} -&gt; {VV : a | false})\n-&gt; {VV : a | false}loop {VV : (GHC.Types.Int) | (VV = (0  :  int))}0 {VV : (GHC.Types.Int) | (VV = n),(VV = vlen([vec])),(VV &gt;= 0)}n a0 {VV : (GHC.Types.Int) | false}\n-&gt; {VV : a | false} -&gt; {VV : a | false}body else {VV : (GHC.Integer.Type.Integer) | (VV = 0)}0\n247:   where {VV : (GHC.Types.Int) | false}\n-&gt; {VV : a | false} -&gt; {VV : a | false}body     = \\{VV : (GHC.Types.Int) | false}i {VV : a | false}acc -&gt; {VV : a | false}acc x:a -&gt; y:a -&gt; {VV : a | (VV = (x + y))}+ ({VV : (Data.Vector.Vector {VV : a | false}) | false}vec x:(Data.Vector.Vector {VV : a | false})\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)}\n-&gt; {VV : a | false}! {VV : (GHC.Types.Int) | false}i)\n248:         {VV : (GHC.Types.Int) | (VV = vlen([vec])),(VV &gt;= 0)}n        = x:(Data.Vector.Vector {VV : a | false})\n-&gt; {VV : (GHC.Types.Int) | (VV = vlen([x])),(VV &gt;= 0)}length {VV : (Data.Vector.Vector {VV : a | false}) | false}vec\n</pre> <p>LiquidHaskell verifies <code>absoluteSum'</code> without any trouble.</p> <p>It is very instructive to see the type that LiquidHaskell infers  for <code>loop</code> -- it looks something like</p> <pre>257: {-@ loop :: lo: {v: Int | (0 &lt;= v) }  \n258:          -&gt; hi: {v: Int | (lo &lt;= v) } \n259:          -&gt; a \n260:          -&gt; (i: {v: Int | (Btwn lo v hi)} -&gt; a -&gt; a)\n261:          -&gt; a \n262:   @-}\n</pre> <p>In english, the above type states that </p> <ul> <li><code>lo</code> the loop lower bound is a non-negative integer</li> <li><code>hi</code> the loop upper bound is a greater than <code>lo</code>,</li> <li><code>f</code>  the loop body is only called with integers between <code>lo</code> and <code>hi</code>.</li> </ul> <p>Inference is a rather convenient option -- it can be tedious to have to keep  typing things like the above! Of course, if we wanted to make <code>loop</code> a public or exported function, we could use the inferred type to generate  an explicit signature too.</p> <p>At the call </p> <pre>277: loop 0 n 0 body \n</pre> <p>the parameters <code>lo</code> and <code>hi</code> are instantiated with <code>0</code> and <code>n</code> respectively (which, by the way is where the inference engine deduces non-negativity from) and thus LiquidHaskell concludes that <code>body</code> is only called with values of <code>i</code> that are between <code>0</code> and <code>(vlen vec)</code>, which shows the  safety of the call <code>vec ! i</code>.</p> <p>Using <code>loop</code> to compute <code>dotProduct</code></p> <p>Here's another use of <code>loop</code> -- this time to compute the <code>dotProduct</code>  of two vectors. </p> <pre>292: dotProduct     :: Vector Int -&gt; Vector Int -&gt; Int\n293: x:(Data.Vector.Vector (GHC.Types.Int))\n-&gt; {VV : (Data.Vector.Vector (GHC.Types.Int)) | (vlen([VV]) = vlen([x]))}\n-&gt; (GHC.Types.Int)dotProduct (Data.Vector.Vector (GHC.Types.Int))x {VV : (Data.Vector.Vector (GHC.Types.Int)) | (vlen([VV]) = vlen([x]))}y = lo:{VV : (GHC.Types.Int) | (0 &lt;= VV)}\n-&gt; hi:{VV : (GHC.Types.Int) | (lo &lt;= VV)}\n-&gt; (GHC.Types.Int)\n-&gt; ({VV : (GHC.Types.Int) | (VV &lt; hi),(lo &lt;= VV)}\n    -&gt; (GHC.Types.Int) -&gt; (GHC.Types.Int))\n-&gt; (GHC.Types.Int)loop {VV : (GHC.Types.Int) | (VV = (0  :  int))}0 (x:(Data.Vector.Vector (GHC.Types.Int))\n-&gt; {VV : (GHC.Types.Int) | (VV = vlen([x])),(VV &gt;= 0)}length {VV : (Data.Vector.Vector (GHC.Types.Int)) | (VV = x),\n                                             (vlen([VV]) &gt;= 0)}x) {VV : (GHC.Types.Int) | (VV = (0  :  int))}0 ({VV : (GHC.Types.Int) | (VV &gt;= 0),\n                        (VV &lt; vlen([x])),\n                        (VV &lt; vlen([y])),\n                        (0 &lt;= VV)}\n-&gt; (GHC.Types.Int) -&gt; (GHC.Types.Int)\\{VV : (GHC.Types.Int) | (VV &gt;= 0),\n                        (VV &lt; vlen([x])),\n                        (VV &lt; vlen([y])),\n                        (0 &lt;= VV)}i -&gt; (x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x + y))}+ ({VV : (Data.Vector.Vector (GHC.Types.Int)) | (VV = x),\n                                             (vlen([VV]) &gt;= 0)}x x:(Data.Vector.Vector (GHC.Types.Int))\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)}\n-&gt; (GHC.Types.Int)! {VV : (GHC.Types.Int) | (VV = i),\n                        (VV &gt;= 0),\n                        (VV &lt; vlen([x])),\n                        (VV &lt; vlen([y])),\n                        (0 &lt;= VV)}i) x:(GHC.Types.Int)\n-&gt; y:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (&amp;&amp; [(x &gt;= 0); (y &gt;= 0)] =&gt; (VV &gt;= 0))}* ({VV : (Data.Vector.Vector (GHC.Types.Int)) | (VV = y),\n                                             (vlen([VV]) = vlen([x])),\n                                             (vlen([VV]) &gt;= 0)}y x:(Data.Vector.Vector (GHC.Types.Int))\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)}\n-&gt; (GHC.Types.Int)! {VV : (GHC.Types.Int) | (VV = i),\n                        (VV &gt;= 0),\n                        (VV &lt; vlen([x])),\n                        (VV &lt; vlen([y])),\n                        (0 &lt;= VV)}i))) \n</pre> <p>The gimlet-eyed reader will realize that the above is quite unsafe -- what if <code>x</code> is a 10-dimensional vector while <code>y</code> has only 3-dimensions? </p> <p>A nasty</p> <pre>300: *** Exception: ./Data/Vector/Generic.hs:244 ((!)): index out of bounds ...\n</pre> <p>Yech. </p> <p>This is precisely the sort of unwelcome surprise we want to do away with at  compile-time. Refinements to the rescue! We can specify that the vectors  have the same dimensions quite easily</p> <pre>310: {-@ dotProduct :: x:(Vector Int) \n311:                -&gt; y:{v: (Vector Int) | (vlen v) = (vlen x)} \n312:                -&gt; Int \n313:   @-}\n</pre> <p>after which LiquidHaskell will gladly verify that the implementation of <code>dotProduct</code> is indeed safe!</p>","tags":["basic"]},{"location":"blogposts/2013-03-04-bounding-vectors.lhs/#refining-data-types","title":"Refining Data Types","text":"<p>Next, suppose we want to write a sparse dot product, that is,  the dot product of a vector and a sparse vector represented by a list of index-value tuples.</p> <p>Representing Sparse Vectors</p> <p>We can represent the sparse vector with a refinement type alias </p> <pre>331: {-@ type SparseVector a N = [({v: Int | (Btwn 0 v N)}, a)] @-}\n</pre> <p>As with usual types, the alias <code>SparseVector</code> on the left is just a  shorthand for the (longer) type on the right, it does not actually  define a new type. Thus, the above alias is simply a refinement of Haskell's <code>[(Int, a)]</code> type, with a size parameter <code>N</code> that facilitates  easy specification reuse. In this way, refinements let us express  invariants of containers like lists in a straightforward manner. </p> <p>Aside: If you are familiar with the index-style length  encoding e.g. as found in DML or Agda, then note that despite appearances, our <code>SparseVector</code> definition is not  indexed. Instead, we deliberately choose to encode properties  with logical refinement predicates, to facilitate SMT based  checking and inference.</p> <p>Verifying Uses of Sparse Vectors</p> <p>Next, we can write a recursive procedure that computes the sparse product</p> <pre>353: {-@ sparseProduct :: (Num a) =&gt; x:(Vector a) \n354:                              -&gt; SparseVector a (vlen x) \n355:                              -&gt; a \n356:   @-}\n357: (GHC.Num.Num a)\n-&gt; x:(Data.Vector.Vector a)\n-&gt; [({VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} , a)]\n-&gt; asparseProduct (Data.Vector.Vector a)x [({VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} , a)]y  = {VV : a | (VV = 0)}\n-&gt; {VV : [({VV : (GHC.Types.Int) | (VV &gt;= 0),\n                                   (VV &lt; vlen([x])),\n                                   (0 &lt;= VV)} , a)] | (VV = y),\n                                                      (len([VV]) = len([y])),\n                                                      (len([VV]) &gt;= 0)}\n-&gt; ago a0 {VV : [({VV : (GHC.Types.Int) | (VV &lt; vlen([x])),\n                                (0 &lt;= VV)} , a)] | (VV = y),(len([VV]) &gt;= 0)}y\n358:   where \n359:     {VV : a | (VV = 0)}\n-&gt; {VV : [({VV : (GHC.Types.Int) | (VV &gt;= 0),\n                                   (VV &lt; vlen([x])),\n                                   (0 &lt;= VV)} , a)] | (VV = y),\n                                                      (len([VV]) = len([y])),\n                                                      (len([VV]) &gt;= 0)}\n-&gt; ago asum ((i, v) : y') = {VV : a | (VV = 0)}\n-&gt; {VV : [({VV : (GHC.Types.Int) | (VV &gt;= 0),\n                                   (VV &lt; vlen([x])),\n                                   (0 &lt;= VV)} , a)] | (VV = y),\n                                                      (len([VV]) = len([y])),\n                                                      (len([VV]) &gt;= 0)}\n-&gt; ago ({VV : a | (VV = sum)}sum x:a -&gt; y:a -&gt; {VV : a | (VV = (x + y))}+ a({VV : (Data.Vector.Vector a) | (VV = x),\n                               (VV = x),\n                               (vlen([VV]) = vlen([x])),\n                               (vlen([VV]) &gt;= 0)}x x:(Data.Vector.Vector a)\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; a! {VV : (GHC.Types.Int) | (VV = i),\n                        (VV &gt;= 0),\n                        (VV &lt; vlen([x])),\n                        (VV &lt; vlen([x])),\n                        (0 &lt;= VV)}i) x:a -&gt; y:a -&gt; {VV : a | (&amp;&amp; [(x &gt;= 0); (y &gt;= 0)] =&gt; (VV &gt;= 0))}* {VV : a | (VV = v)}v) {VV : [({VV : (GHC.Types.Int) | (VV &gt;= 0),\n                                (VV &lt; vlen([x])),\n                                (VV &lt; vlen([x])),\n                                (0 &lt;= VV)} , a)] | (VV = y'),(len([VV]) &gt;= 0)}y' \n360:     go sum []            = {VV : a | (VV = sum)}sum\n</pre> <p>LiquidHaskell verifies the above by using the specification for <code>y</code> to conclude that for each tuple <code>(i, v)</code> in the list, the value of <code>i</code> is  within the bounds of the vector <code>x</code>, thereby proving the safety of the  access <code>x ! i</code>.</p>","tags":["basic"]},{"location":"blogposts/2013-03-04-bounding-vectors.lhs/#refinements-and-polymorphism","title":"Refinements and Polymorphism","text":"<p>The sharp reader will have undoubtedly noticed that the sparse product  can be more cleanly expressed as a fold. </p> <p>Indeed! Let us recall the type of the <code>foldl</code> operation</p> <pre>375: foldl' :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a\n</pre> <p>Thus, we can simply fold over the sparse vector, accumulating the <code>sum</code> as we go along</p> <pre>382: {-@ sparseProduct' :: (Num a) =&gt; x:(Vector a) \n383:                              -&gt; SparseVector a (vlen x) \n384:                              -&gt; a \n385:   @-}\n386: (GHC.Num.Num a)\n-&gt; x:(Data.Vector.Vector a)\n-&gt; [({VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} , a)]\n-&gt; asparseProduct' (Data.Vector.Vector a)x [({VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} , a)]y  = (a\n -&gt; ({VV : (GHC.Types.Int) | (VV &gt;= 0),\n                             (VV &lt; vlen([x])),\n                             (0 &lt;= VV)} , a)\n -&gt; a)\n-&gt; a\n-&gt; [({VV : (GHC.Types.Int) | (VV &gt;= 0),\n                             (VV &lt; vlen([x])),\n                             (0 &lt;= VV)} , a)]\n-&gt; afoldl' a\n-&gt; ({VV : (GHC.Types.Int) | (VV &gt;= 0),\n                            (VV &lt; vlen([x])),\n                            (0 &lt;= VV)} , a)\n-&gt; abody a0 {VV : [({VV : (GHC.Types.Int) | (VV &lt; vlen([x])),\n                                (0 &lt;= VV)} , a)] | (VV = y),(len([VV]) &gt;= 0)}y   \n387:   where \n388:     a\n-&gt; ({VV : (GHC.Types.Int) | (VV &gt;= 0),\n                            (VV &lt; vlen([x])),\n                            (0 &lt;= VV)} , a)\n-&gt; abody asum (i, v) = {VV : a | (VV = sum)}sum x:a -&gt; y:a -&gt; {VV : a | (VV = (x + y))}+ a({VV : (Data.Vector.Vector a) | (VV = x),(vlen([VV]) &gt;= 0)}x x:(Data.Vector.Vector a)\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; vlen([x])),(0 &lt;= VV)} -&gt; a! {VV : (GHC.Types.Int) | (VV = i),\n                        (VV &gt;= 0),\n                        (VV &lt; vlen([x])),\n                        (0 &lt;= VV)}i) x:a -&gt; y:a -&gt; {VV : a | (&amp;&amp; [(x &gt;= 0); (y &gt;= 0)] =&gt; (VV &gt;= 0))}* {VV : a | (VV = v)}v\n</pre> <p>LiquidHaskell digests this too, without much difficulty. </p> <p>The main trick is in how the polymorphism of <code>foldl'</code> is instantiated. </p> <ol> <li> <p>The GHC type inference engine deduces that at this site, the type variable    <code>b</code> from the signature of <code>foldl'</code> is instantiated to the Haskell type <code>(Int, a)</code>. </p> </li> <li> <p>Correspondingly, LiquidHaskell infers that in fact <code>b</code> can be instantiated    to the refined type <code>({v: Int | (Btwn 0 v (vlen x))}, a)</code>. </p> </li> </ol> <p>Walk the mouse over to <code>i</code> to see this inferred type. (You can also hover over <code>foldl'</code>above to see the rather more verbose fully instantiated type.)</p> <p>Thus, the inference mechanism saves us a fair bit of typing and allows us to reuse existing polymorphic functions over containers and such without ceremony.</p>","tags":["basic"]},{"location":"blogposts/2013-03-04-bounding-vectors.lhs/#conclusion","title":"Conclusion","text":"<p>That's all for now folks! Hopefully the above gives you a reasonable idea of how one can use refinements to verify size related properties, and more generally, to specify and verify properties of recursive, and polymorphic functions operating over datatypes. Next time, we'll look at how we can teach LiquidHaskell to think about properties of recursive structures like lists and trees.</p>","tags":["basic"]},{"location":"blogposts/2013-03-26-talking-about-sets.lhs/","title":"Talking About Sets","text":"<p>In the posts so far, we've seen how LiquidHaskell allows you to use SMT  solvers to specify and verify numeric invariants -- denominators  that are non-zero, integer indices that are within the range of an  array, vectors that have the right number of dimensions and so on.</p> <p>However, SMT solvers are not limited to numbers, and in fact, support rather expressive logics. In the next couple of posts, let's see how LiquidHaskell uses SMT to talk about sets of values, for example,  the contents of a list, and to specify and verify properties about  those sets.</p> <pre>27: module TalkingAboutSets where\n28: \n29: import Data.Set hiding (filter, split)\n30: import Prelude  hiding (reverse, filter)\n31: \n</pre>","tags":["basic","measures","sets"]},{"location":"blogposts/2013-03-26-talking-about-sets.lhs/#talking-about-sets-in-logic","title":"Talking about Sets (In Logic)","text":"<p>First, we need a way to talk about sets in the refinement logic. We could roll our own special Haskell type, but why not just use the <code>Set a</code> type from <code>Data.Set</code>.</p> <p>The <code>import Data.Set</code> , also instructs LiquidHaskell to import in the various  specifications defined for the <code>Data.Set</code> module that we have predefined  in Data/Set.spec </p> <p>Let's look at the specifications.</p> <pre>46: module spec Data.Set where\n47: \n48: embed Set as Set_Set\n</pre> <p>The <code>embed</code> directive tells LiquidHaskell to model the Haskell  type constructor <code>Set</code> with the SMT type constructor <code>Set_Set</code>.</p> <p>First, we define the logical operators (i.e. <code>measure</code>s) </p> <pre>55: measure Set_sng  :: a -&gt; (Set a)                    -- ^ singleton\n56: measure Set_cup  :: (Set a) -&gt; (Set a) -&gt; (Set a)   -- ^ union\n57: measure Set_cap  :: (Set a) -&gt; (Set a) -&gt; (Set a)   -- ^ intersection\n58: measure Set_dif  :: (Set a) -&gt; (Set a) -&gt; (Set a)   -- ^ difference \n</pre> <p>Next, we define predicates on <code>Set</code>s </p> <pre>62: measure Set_emp  :: (Set a) -&gt; Prop                 -- ^ emptiness\n63: measure Set_mem  :: a -&gt; (Set a) -&gt; Prop            -- ^ membership\n64: measure Set_sub  :: (Set a) -&gt; (Set a) -&gt; Prop      -- ^ inclusion \n</pre>","tags":["basic","measures","sets"]},{"location":"blogposts/2013-03-26-talking-about-sets.lhs/#interpreted-operations","title":"Interpreted Operations","text":"<p>The above operators are interpreted by the SMT solver. </p> <p>That is, just like the SMT solver \"knows that\"</p> <pre>74: 2 + 2 == 4\n</pre> <p>the SMT solver also \"knows that\"</p> <pre>78: (Set_sng 1) == (Set_cap (Set_sng 1) (Set_cup (Set_sng 2) (Set_sng 1)))\n</pre> <p>This is because, the above formulas belong to a decidable Theory of Sets which can be reduced to McCarthy's more general Theory of Arrays.  See this recent paper if you want to learn more about how modern SMT  solvers \"know\" the above equality holds...</p>","tags":["basic","measures","sets"]},{"location":"blogposts/2013-03-26-talking-about-sets.lhs/#talking-about-sets-in-code","title":"Talking about Sets (In Code)","text":"<p>Of course, the above operators exist purely in the realm of the  refinement logic, beyond the grasp of the programmer.</p> <p>To bring them down (or up, or left or right) within reach of Haskell code,  we can simply assume that the various public functions in <code>Data.Set</code> do  the Right Thing i.e. produce values that reflect the logical set operations:</p> <p>First, the functions that create <code>Set</code> values</p> <pre>97: empty     :: {v:(Set a) | (Set_emp v)}\n98: singleton :: x:a -&gt; {v:(Set a) | v = (Set_sng x)}\n</pre> <p>Next, the functions that operate on elements and <code>Set</code> values</p> <pre>102: insert :: Ord a =&gt; x:a \n103:                 -&gt; xs:(Set a) \n104:                 -&gt; {v:(Set a) | v = (Set_cup xs (Set_sng x))}\n105: \n106: delete :: Ord a =&gt; x:a \n107:                 -&gt; xs:(Set a) \n108:                 -&gt; {v:(Set a) | v = (Set_dif xs (Set_sng x))}\n</pre> <p>Then, the binary <code>Set</code> operators</p> <pre>112: union        :: Ord a =&gt; xs:(Set a) \n113:                       -&gt; ys:(Set a) \n114:                       -&gt; {v:(Set a) | v = (Set_cup xs ys)}\n115: \n116: intersection :: Ord a =&gt; xs:(Set a) \n117:                       -&gt; ys:(Set a) \n118:                       -&gt; {v:(Set a) | v = (Set_cap xs ys)}\n119: \n120: difference   :: Ord a =&gt; xs:(Set a) \n121:                       -&gt; ys:(Set a) \n122:                       -&gt; {v:(Set a) | v = (Set_dif xs ys)}\n</pre> <p>And finally, the predicates on <code>Set</code> values:</p> <pre>126: isSubsetOf :: Ord a =&gt; xs:(Set a) \n127:                     -&gt; ys:(Set a) \n128:                     -&gt; {v:Bool | (Prop v) &lt;=&gt; (Set_sub xs ys)}\n129: \n130: member     :: Ord a =&gt; x:a \n131:                     -&gt; xs:(Set a) \n132:                     -&gt; {v:Bool | (Prop v) &lt;=&gt; (Set_mem x xs)}\n</pre> <p>Note: Of course we shouldn't and needn't really assume, but should and will guarantee that the functions from <code>Data.Set</code> implement the above types.  But thats a story for another day...</p>","tags":["basic","measures","sets"]},{"location":"blogposts/2013-03-26-talking-about-sets.lhs/#proving-theorems-with-liquidhaskell","title":"Proving Theorems With LiquidHaskell","text":"<p>OK, let's take our refined operators from <code>Data.Set</code> out for a spin! One pleasant consequence of being able to precisely type the operators  from <code>Data.Set</code> is that we have a pleasant interface for using the SMT solver to prove theorems about sets, while remaining firmly rooted in Haskell. </p> <p>First, let's write a simple function that asserts that its input is <code>True</code></p> <pre>151: {-@ boolAssert :: {v: Bool | (Prop v)} -&gt; {v:Bool | (Prop v)} @-}\n152: {VV : (GHC.Types.Bool) | (? Prop([VV]))}\n-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV]))}boolAssert True   = {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV = True)}True\n153: boolAssert False  = [(GHC.Types.Char)] -&gt; {VV : (GHC.Types.Bool) | false}error {VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}\"boolAssert: False? Never!\"\n</pre> <p>Now, we can use <code>boolAssert</code> to write some simple properties. (Yes, these do indeed look like QuickCheck properties -- but here, instead of generating tests and executing the code, the type system is proving to us that the properties will always evaluate to <code>True</code>) </p> <p>Let's check that <code>intersection</code> is commutative ...</p> <pre>164: forall a.\n(GHC.Classes.Ord a) =&gt;\n(Data.Set.Base.Set a) -&gt; (Data.Set.Base.Set a) -&gt; (GHC.Types.Bool)prop_cap_comm (Data.Set.Base.Set a)x (Data.Set.Base.Set a)y \n165:   = {VV : (GHC.Types.Bool) | (? Prop([VV]))}\n-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV]))}boolAssert \n166:   ({VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}\n -&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)})\n-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}\n-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}$ (GHC.Types.Bool)({VV : (Data.Set.Base.Set a) | (VV = x)}x xs:(Data.Set.Base.Set a)\n-&gt; ys:(Data.Set.Base.Set a)\n-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cap([xs; ys]))}`intersection` {VV : (Data.Set.Base.Set a) | (VV = y)}y) GHC.Classes.Eq (Data.Set.Base.Set a)== ({VV : (Data.Set.Base.Set a) | (VV = y)}y xs:(Data.Set.Base.Set a)\n-&gt; ys:(Data.Set.Base.Set a)\n-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cap([xs; ys]))}`intersection` {VV : (Data.Set.Base.Set a) | (VV = x)}x)\n</pre> <p>that <code>union</code> is associative ...</p> <pre>172: forall a.\n(GHC.Classes.Ord a) =&gt;\n(Data.Set.Base.Set a)\n-&gt; (Data.Set.Base.Set a)\n-&gt; (Data.Set.Base.Set a)\n-&gt; (GHC.Types.Bool)prop_cup_assoc (Data.Set.Base.Set a)x (Data.Set.Base.Set a)y (Data.Set.Base.Set a)z \n173:   = {VV : (GHC.Types.Bool) | (? Prop([VV]))}\n-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV]))}boolAssert \n174:   ({VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}\n -&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)})\n-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}\n-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}$ (GHC.Types.Bool)({VV : (Data.Set.Base.Set a) | (VV = x)}x xs:(Data.Set.Base.Set a)\n-&gt; ys:(Data.Set.Base.Set a)\n-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cup([xs; ys]))}`union` ({VV : (Data.Set.Base.Set a) | (VV = y)}y xs:(Data.Set.Base.Set a)\n-&gt; ys:(Data.Set.Base.Set a)\n-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cup([xs; ys]))}`union` {VV : (Data.Set.Base.Set a) | (VV = z)}z)) GHC.Classes.Eq (Data.Set.Base.Set a)== (Data.Set.Base.Set a)({VV : (Data.Set.Base.Set a) | (VV = x)}x xs:(Data.Set.Base.Set a)\n-&gt; ys:(Data.Set.Base.Set a)\n-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cup([xs; ys]))}`union` {VV : (Data.Set.Base.Set a) | (VV = y)}y) xs:(Data.Set.Base.Set a)\n-&gt; ys:(Data.Set.Base.Set a)\n-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cup([xs; ys]))}`union` {VV : (Data.Set.Base.Set a) | (VV = z)}z\n</pre> <p>and that <code>union</code> distributes over <code>intersection</code>.</p> <pre>180: forall a.\n(GHC.Classes.Ord a) =&gt;\n(Data.Set.Base.Set a)\n-&gt; (Data.Set.Base.Set a)\n-&gt; (Data.Set.Base.Set a)\n-&gt; (GHC.Types.Bool)prop_cap_dist (Data.Set.Base.Set a)x (Data.Set.Base.Set a)y (Data.Set.Base.Set a)z \n181:   = {VV : (GHC.Types.Bool) | (? Prop([VV]))}\n-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV]))}boolAssert \n182:   ({VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}\n -&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)})\n-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}\n-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}$  ({VV : (Data.Set.Base.Set a) | (VV = x)}x xs:(Data.Set.Base.Set a)\n-&gt; ys:(Data.Set.Base.Set a)\n-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cap([xs; ys]))}`intersection` ({VV : (Data.Set.Base.Set a) | (VV = y)}y xs:(Data.Set.Base.Set a)\n-&gt; ys:(Data.Set.Base.Set a)\n-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cup([xs; ys]))}`union` {VV : (Data.Set.Base.Set a) | (VV = z)}z)) \n183:   GHC.Classes.Eq (Data.Set.Base.Set a)== (Data.Set.Base.Set a)({VV : (Data.Set.Base.Set a) | (VV = x)}x xs:(Data.Set.Base.Set a)\n-&gt; ys:(Data.Set.Base.Set a)\n-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cap([xs; ys]))}`intersection` {VV : (Data.Set.Base.Set a) | (VV = y)}y) xs:(Data.Set.Base.Set a)\n-&gt; ys:(Data.Set.Base.Set a)\n-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cup([xs; ys]))}`union` ({VV : (Data.Set.Base.Set a) | (VV = x)}x xs:(Data.Set.Base.Set a)\n-&gt; ys:(Data.Set.Base.Set a)\n-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cap([xs; ys]))}`intersection` {VV : (Data.Set.Base.Set a) | (VV = z)}z) \n</pre> <p>Of course, while we're at it, let's make sure LiquidHaskell doesn't prove anything that isn't true ...</p> <pre>190: forall a.\n(GHC.Classes.Ord a) =&gt;\n(Data.Set.Base.Set a) -&gt; (Data.Set.Base.Set a) -&gt; (GHC.Types.Bool)prop_cup_dif_bad (Data.Set.Base.Set a)x (Data.Set.Base.Set a)y\n191:    = {VV : (GHC.Types.Bool) | (? Prop([VV]))}\n-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV]))}boolAssert \n192:    ((GHC.Types.Bool)\n -&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)})\n-&gt; (GHC.Types.Bool)\n-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}$ {VV : (Data.Set.Base.Set a) | (VV = x)}x GHC.Classes.Eq (Data.Set.Base.Set a)== (Data.Set.Base.Set a)({VV : (Data.Set.Base.Set a) | (VV = x)}x xs:(Data.Set.Base.Set a)\n-&gt; ys:(Data.Set.Base.Set a)\n-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cup([xs; ys]))}`union` {VV : (Data.Set.Base.Set a) | (VV = y)}y) xs:(Data.Set.Base.Set a)\n-&gt; ys:(Data.Set.Base.Set a)\n-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_dif([xs; ys]))}`difference` {VV : (Data.Set.Base.Set a) | (VV = y)}y\n</pre> <p>Hmm. You do know why the above doesn't hold, right? It would be nice to get a counterexample wouldn't it? Well, for the moment, there is QuickCheck!</p> <p>Thus, the refined types offer a nice interface for interacting with the SMT solver in order to prove theorems in LiquidHaskell. (BTW, The SBV project describes another approach for using SMT solvers from Haskell, without the  indirection of refinement types.)</p> <p>While the above is a nice warm up exercise to understanding how LiquidHaskell reasons about sets, our overall goal is not to prove  theorems about set operators, but instead to specify and verify  properties of programs. </p>","tags":["basic","measures","sets"]},{"location":"blogposts/2013-03-26-talking-about-sets.lhs/#the-set-of-values-in-a-list","title":"The Set of Values in a List","text":"<p>Let's see how we might reason about sets of values in regular Haskell programs.</p> <p>We'll begin with Lists, the jack-of-all-data-types. Now, instead of just talking about the number of elements in a list, we can write a measure that describes the set of elements in a list:</p> <p>A measure for the elements of a list, from Data/Set.spec</p> <pre>221: \n222: measure listElts :: [a] -&gt; (Set a) \n223: listElts ([])    = {v | (? Set_emp(v))}\n224: listElts (x:xs)  = {v | v = (Set_cup (Set_sng x) (listElts xs)) }\n</pre> <p>That is, <code>(listElts xs)</code> describes the set of elements contained in a list <code>xs</code>.</p> <p>Next, to make the specifications concise, let's define a few predicate aliases:</p> <pre>232: {-@ predicate EqElts  X Y = \n233:       ((listElts X) = (listElts Y))                        @-}\n234: \n235: {-@ predicate SubElts   X Y = \n236:       (Set_sub (listElts X) (listElts Y))                  @-}\n237: \n238: {-@ predicate UnionElts X Y Z = \n239:       ((listElts X) = (Set_cup (listElts Y) (listElts Z))) @-}\n</pre>","tags":["basic","measures","sets"]},{"location":"blogposts/2013-03-26-talking-about-sets.lhs/#a-trivial-identity","title":"A Trivial Identity","text":"<p>OK, now let's write some code to check that the <code>listElts</code> measure is sensible!</p> <pre>248: {-@ listId    :: xs:[a] -&gt; {v:[a] | (EqElts v xs)} @-}\n249: forall a.\nx1:[a]\n-&gt; {VV : [a] | (len([VV]) = len([x1])),\n               (listElts([VV]) = Set_cup([listElts([x1]); listElts([x1])])),\n               (listElts([VV]) = listElts([x1])),\n               (listElts([x1]) = Set_cup([listElts([x1]); listElts([VV])])),\n               (len([VV]) &gt;= 0)}listId []     = forall &lt;p :: a -&gt; a -&gt; Bool&gt;.\n{VV : [{VV : a | false}]&lt;p&gt; | (? Set_emp([listElts([VV])])),\n                              (len([VV]) = 0)}[]\n250: listId (x:xs) = {VV : a | (VV = x)}x forall &lt;p :: a -&gt; a -&gt; Bool&gt;.\ny:a\n-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),\n                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}: forall a.\nx1:[a]\n-&gt; {VV : [a] | (len([VV]) = len([x1])),\n               (listElts([VV]) = Set_cup([listElts([x1]); listElts([x1])])),\n               (listElts([VV]) = listElts([x1])),\n               (listElts([x1]) = Set_cup([listElts([x1]); listElts([VV])])),\n               (len([VV]) &gt;= 0)}listId {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs\n</pre> <p>That is, LiquidHaskell checks that the set of elements of the output list is the same as those in the input.</p>","tags":["basic","measures","sets"]},{"location":"blogposts/2013-03-26-talking-about-sets.lhs/#a-less-trivial-identity","title":"A Less Trivial Identity","text":"<p>Next, let's write a function to <code>reverse</code> a list. Of course, we'd like to verify that <code>reverse</code> doesn't leave any elements behind; that is that the  output has the same set of values as the input list. This is somewhat more  interesting because of the tail recursive helper <code>go</code>. Do you understand  the type that is inferred for it? (Put your mouse over <code>go</code> to see the  inferred type.)</p> <pre>267: {-@ reverse       :: xs:[a] -&gt; {v:[a] | (EqElts v xs)} @-}\n268: forall a. xs:[a] -&gt; {VV : [a] | (listElts([VV]) = listElts([xs]))}reverse           = x1:{VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | (len([VV]) = 0)}\n-&gt; x2:[a]\n-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);\n                                          listElts([x2])])),\n               (listElts([VV]) = Set_cup([listElts([x2]); listElts([x1])])),\n               (len([VV]) &gt;= 0)}go {VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | (? Set_emp([listElts([VV])])),\n                                           (len([VV]) = 0),\n                                           (len([VV]) &gt;= 0)}[] \n269:   where \n270:     acc:{VV : [a] | (len([VV]) &gt;= 0)}\n-&gt; x1:[a]\n-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([acc]);\n                                          listElts([x1])])),\n               (listElts([VV]) = Set_cup([listElts([x1]); listElts([acc])])),\n               (len([VV]) &gt;= 0)}go {VV : [a] | (len([VV]) &gt;= 0)}acc []     = {VV : [a] | (VV = acc),(len([VV]) &gt;= 0)}acc\n271:     go acc (y:ys) = acc:{VV : [a] | (len([VV]) &gt;= 0)}\n-&gt; x1:[a]\n-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([acc]);\n                                          listElts([x1])])),\n               (listElts([VV]) = Set_cup([listElts([x1]); listElts([acc])])),\n               (len([VV]) &gt;= 0)}go ({VV : a | (VV = y)}yforall &lt;p :: a -&gt; a -&gt; Bool&gt;.\ny:a\n-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),\n                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}:{VV : [a] | (VV = acc),(len([VV]) &gt;= 0)}acc) {VV : [a] | (VV = ys),(len([VV]) &gt;= 0)}ys\n</pre>","tags":["basic","measures","sets"]},{"location":"blogposts/2013-03-26-talking-about-sets.lhs/#appending-lists","title":"Appending Lists","text":"<p>Next, here's good old <code>append</code>, but now with a specification that states that the output indeed includes the elements from both the input lists.</p> <pre>281: {-@ append       :: xs:[a] -&gt; ys:[a] -&gt; {v:[a]| (UnionElts v xs ys)} @-}\n282: forall a.\nx1:[a]\n-&gt; ys:[a]\n-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);\n                                          listElts([ys])])),\n               (listElts([VV]) = Set_cup([listElts([ys]); listElts([x1])])),\n               (len([VV]) &gt;= 0)}append []     [a]ys = {VV : [a] | (VV = ys),(len([VV]) &gt;= 0)}ys\n283: append (x:xs) ys = {VV : a | (VV = x)}x forall &lt;p :: a -&gt; a -&gt; Bool&gt;.\ny:a\n-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),\n                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}: forall a.\nx1:[a]\n-&gt; ys:[a]\n-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);\n                                          listElts([ys])])),\n               (listElts([VV]) = Set_cup([listElts([ys]); listElts([x1])])),\n               (len([VV]) &gt;= 0)}append {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs {VV : [a] | (VV = ys),(len([VV]) &gt;= 0)}ys\n</pre>","tags":["basic","measures","sets"]},{"location":"blogposts/2013-03-26-talking-about-sets.lhs/#filtering-lists","title":"Filtering Lists","text":"<p>Let's round off the list trilogy, with <code>filter</code>. Here, we can verify that it returns a subset of the values of the input list.</p> <pre>293: {-@ filter      :: (a -&gt; Bool) -&gt; xs:[a] -&gt; {v:[a]| (SubElts v xs)} @-}\n294: \n295: forall a.\n(a -&gt; (GHC.Types.Bool))\n-&gt; x2:[a]\n-&gt; {VV : [a] | (? Set_sub([listElts([VV]); listElts([x2])])),\n               (listElts([x2]) = Set_cup([listElts([x2]); listElts([VV])])),\n               (len([VV]) &gt;= 0)}filter a -&gt; (GHC.Types.Bool)f []     = forall &lt;p :: a -&gt; a -&gt; Bool&gt;.\n{VV : [{VV : a | false}]&lt;p&gt; | (? Set_emp([listElts([VV])])),\n                              (len([VV]) = 0)}[]\n296: filter f (x:xs) \n297:   | a -&gt; (GHC.Types.Bool)f {VV : a | (VV = x)}x         = {VV : a | (VV = x)}x forall &lt;p :: a -&gt; a -&gt; Bool&gt;.\ny:a\n-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),\n                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}: forall a.\n(a -&gt; (GHC.Types.Bool))\n-&gt; x2:[a]\n-&gt; {VV : [a] | (? Set_sub([listElts([VV]); listElts([x2])])),\n               (listElts([x2]) = Set_cup([listElts([x2]); listElts([VV])])),\n               (len([VV]) &gt;= 0)}filter a -&gt; (GHC.Types.Bool)f {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs \n298:   | otherwise   = forall a.\n(a -&gt; (GHC.Types.Bool))\n-&gt; x2:[a]\n-&gt; {VV : [a] | (? Set_sub([listElts([VV]); listElts([x2])])),\n               (listElts([x2]) = Set_cup([listElts([x2]); listElts([VV])])),\n               (len([VV]) &gt;= 0)}filter a -&gt; (GHC.Types.Bool)f {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs\n</pre>","tags":["basic","measures","sets"]},{"location":"blogposts/2013-03-26-talking-about-sets.lhs/#merge-sort","title":"Merge Sort","text":"<p>Let's conclude this entry with one larger example: <code>mergeSort</code>. We'd like to verify that, well, the list that is returned  contains the same set of elements as the input list. </p> <p>And so we will!</p> <p>But first, let's remind ourselves of how <code>mergeSort</code> works:</p> <ol> <li><code>split</code> the input list into two halves, </li> <li><code>sort</code>  each half, recursively, </li> <li><code>merge</code> the sorted halves to obtain the sorted list.</li> </ol>","tags":["basic","measures","sets"]},{"location":"blogposts/2013-03-26-talking-about-sets.lhs/#split","title":"Split","text":"<p>We can <code>split</code> a list into two, roughly equal parts like so:</p> <pre>323: forall a.\nx1:[a]\n-&gt; ({VV : [a] | (? Set_sub([listElts([VV]); listElts([x1])])),\n                (listElts([x1]) = Set_cup([listElts([x1]); listElts([VV])])),\n                (len([VV]) &gt;= 0)} , {VV : [a] | (? Set_sub([listElts([VV]);\n                                                            listElts([x1])])),\n                                                (listElts([x1]) = Set_cup([listElts([x1]);\n                                                                           listElts([VV])])),\n                                                (len([VV]) &gt;= 0)})&lt;\\x1 VV -&gt; (? Set_sub([listElts([VV]);\n                                                                                         listElts([x1])])),\n                                                                             (listElts([x1]) = Set_cup([listElts([x1]);\n                                                                                                        listElts([VV])])),\n                                                                             (listElts([x1]) = Set_cup([listElts([x1]);\n                                                                                                        listElts([VV])])),\n                                                                             (len([VV]) &gt;= 0)&gt;split []     = forall a b &lt;p2 :: a -&gt; b -&gt; Bool&gt;. x1:a -&gt; b&lt;p2 x1&gt; -&gt; (a , b)&lt;p2&gt;({VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | (? Set_emp([listElts([VV])])),\n                                           (len([VV]) = 0),\n                                           (len([VV]) &gt;= 0)}[], {VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | (? Set_emp([listElts([VV])])),\n                                           (len([VV]) = 0),\n                                           (len([VV]) &gt;= 0)}[])\n324: split (x:xs) = forall a b &lt;p2 :: a -&gt; b -&gt; Bool&gt;. x1:a -&gt; b&lt;p2 x1&gt; -&gt; (a , b)&lt;p2&gt;({VV : a | (VV = x)}xforall &lt;p :: a -&gt; a -&gt; Bool&gt;.\ny:a\n-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),\n                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}:{VV : [a] | (? Set_sub([listElts([VV]); listElts([xs])])),\n            (VV = zs),\n            (VV = zs),\n            (len([VV]) = len([zs])),\n            (listElts([VV]) = Set_cup([listElts([zs]); listElts([zs])])),\n            (listElts([VV]) = listElts([zs])),\n            (listElts([xs]) = Set_cup([listElts([xs]); listElts([VV])])),\n            (listElts([xs]) = Set_cup([listElts([ys]); listElts([VV])])),\n            (listElts([xs]) = Set_cup([listElts([ys]); listElts([VV])])),\n            (listElts([zs]) = Set_cup([listElts([zs]); listElts([VV])])),\n            (len([VV]) &gt;= 0)}zs, {VV : [a] | (? Set_sub([listElts([VV]); listElts([xs])])),\n            (VV = ys),\n            (VV = ys),\n            (len([VV]) = len([ys])),\n            (listElts([VV]) = Set_cup([listElts([ys]); listElts([ys])])),\n            (listElts([VV]) = listElts([ys])),\n            (listElts([xs]) = Set_cup([listElts([xs]); listElts([VV])])),\n            (listElts([xs]) = Set_cup([listElts([zs]); listElts([VV])])),\n            (listElts([ys]) = Set_cup([listElts([ys]); listElts([VV])])),\n            (len([VV]) &gt;= 0)}ys)\n325:   where \n326:     ({VV : [a] | (? Set_sub([listElts([VV]); listElts([xs])])),\n            (VV = ys),\n            (len([VV]) = len([ys])),\n            (listElts([VV]) = Set_cup([listElts([ys]); listElts([ys])])),\n            (listElts([VV]) = listElts([ys])),\n            (listElts([xs]) = Set_cup([listElts([xs]); listElts([VV])])),\n            (listElts([xs]) = Set_cup([listElts([zs]); listElts([VV])])),\n            (listElts([ys]) = Set_cup([listElts([ys]); listElts([VV])])),\n            (len([VV]) &gt;= 0)}ys, {VV : [a] | (? Set_sub([listElts([VV]); listElts([xs])])),\n            (VV = zs),\n            (len([VV]) = len([zs])),\n            (listElts([VV]) = Set_cup([listElts([zs]); listElts([zs])])),\n            (listElts([VV]) = listElts([zs])),\n            (listElts([xs]) = Set_cup([listElts([xs]); listElts([VV])])),\n            (listElts([xs]) = Set_cup([listElts([ys]); listElts([VV])])),\n            (listElts([xs]) = Set_cup([listElts([ys]); listElts([VV])])),\n            (listElts([zs]) = Set_cup([listElts([zs]); listElts([VV])])),\n            (len([VV]) &gt;= 0)}zs) = forall a.\nx1:[a]\n-&gt; ({VV : [a] | (? Set_sub([listElts([VV]); listElts([x1])])),\n                (listElts([x1]) = Set_cup([listElts([x1]); listElts([VV])])),\n                (len([VV]) &gt;= 0)} , {VV : [a] | (? Set_sub([listElts([VV]);\n                                                            listElts([x1])])),\n                                                (listElts([x1]) = Set_cup([listElts([x1]);\n                                                                           listElts([VV])])),\n                                                (len([VV]) &gt;= 0)})&lt;\\x1 VV -&gt; (? Set_sub([listElts([VV]);\n                                                                                         listElts([x1])])),\n                                                                             (listElts([x1]) = Set_cup([listElts([x1]);\n                                                                                                        listElts([VV])])),\n                                                                             (listElts([x1]) = Set_cup([listElts([x1]);\n                                                                                                        listElts([VV])])),\n                                                                             (len([VV]) &gt;= 0)&gt;split {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs\n</pre> <p>LiquidHaskell verifies that the relevant property of split is</p> <pre>332: {-@ split :: xs:[a] -&gt; ([a], [a])&lt;{\\ys zs -&gt; (UnionElts xs ys zs)}&gt; @-}\n</pre> <p>The funny syntax with angle brackets simply says that the output of <code>split</code>  is a pair <code>(ys, zs)</code> whose union is the list of elements of the input <code>xs</code>. (Yes, this is indeed a dependent pair; we will revisit these later to understand whats going on with the odd syntax.)</p>","tags":["basic","measures","sets"]},{"location":"blogposts/2013-03-26-talking-about-sets.lhs/#merge","title":"Merge","text":"<p>Next, we can <code>merge</code> two (sorted) lists like so:</p> <pre>346: forall a.\n(GHC.Classes.Ord a) =&gt;\nxs:[a]\n-&gt; x1:[a]\n-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);\n                                          listElts([xs])])),\n               (listElts([VV]) = Set_cup([listElts([xs]); listElts([x1])])),\n               (len([VV]) &gt;= 0)}merge [a]xs []         = {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs\n347: merge [] ys         = {VV : [a] | (len([VV]) &gt;= 0)}ys\n348: merge (x:xs) (y:ys) \n349:   | {VV : a | (VV = x)}x x:a\n-&gt; y:a -&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt;= y))}&lt;= {VV : a | (VV = y)}y          = {VV : a | (VV = x)}x forall &lt;p :: a -&gt; a -&gt; Bool&gt;.\ny:a\n-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),\n                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}: forall a.\n(GHC.Classes.Ord a) =&gt;\nxs:[a]\n-&gt; x1:[a]\n-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);\n                                          listElts([xs])])),\n               (listElts([VV]) = Set_cup([listElts([xs]); listElts([x1])])),\n               (len([VV]) &gt;= 0)}merge {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs ({VV : a | (VV = y)}y forall &lt;p :: a -&gt; a -&gt; Bool&gt;.\ny:a\n-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),\n                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}: {VV : [a] | (VV = ys),(len([VV]) &gt;= 0)}ys)\n350:   | otherwise       = {VV : a | (VV = y)}y forall &lt;p :: a -&gt; a -&gt; Bool&gt;.\ny:a\n-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),\n                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}: forall a.\n(GHC.Classes.Ord a) =&gt;\nxs:[a]\n-&gt; x1:[a]\n-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);\n                                          listElts([xs])])),\n               (listElts([VV]) = Set_cup([listElts([xs]); listElts([x1])])),\n               (len([VV]) &gt;= 0)}merge ({VV : a | (VV = x)}x forall &lt;p :: a -&gt; a -&gt; Bool&gt;.\ny:a\n-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),\n                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}: {VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}xs) {VV : [a] | (VV = ys),(len([VV]) &gt;= 0)}ys\n</pre> <p>As you might expect, the elements of the returned list are the union of the elements of the input, or as LiquidHaskell might say,</p> <pre>357: {-@ merge :: (Ord a) =&gt; x:[a] -&gt; y:[a] -&gt; {v:[a]| (UnionElts v x y)} @-}\n</pre>","tags":["basic","measures","sets"]},{"location":"blogposts/2013-03-26-talking-about-sets.lhs/#sort","title":"Sort","text":"<p>Finally, we put all the pieces together by</p> <pre>366: {-@ mergeSort :: (Ord a) =&gt; xs:[a] -&gt; {v:[a] | (EqElts v xs)} @-}\n367: forall a.\n(GHC.Classes.Ord a) =&gt;\nx1:[a]\n-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);\n                                          listElts([x1])])),\n               (listElts([VV]) = listElts([x1])),\n               (listElts([x1]) = Set_cup([listElts([x1]); listElts([VV])]))}mergeSort []  = forall &lt;p :: a -&gt; a -&gt; Bool&gt;.\n{VV : [{VV : a | false}]&lt;p&gt; | (? Set_emp([listElts([VV])])),\n                              (len([VV]) = 0)}[]\n368: mergeSort [x] = {VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | (? Set_emp([listElts([VV])])),\n                                           (len([VV]) = 0),\n                                           (len([VV]) &gt;= 0)}[{VV : a | (VV = x)}x]\n369: mergeSort xs  = x:[a]\n-&gt; y:[a]\n-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x]);\n                                          listElts([y])]))}merge (forall a.\n(GHC.Classes.Ord a) =&gt;\nx1:[a]\n-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);\n                                          listElts([x1])])),\n               (listElts([VV]) = listElts([x1])),\n               (listElts([x1]) = Set_cup([listElts([x1]); listElts([VV])]))}mergeSort {VV : [a] | (VV = ys),\n            (VV = ys),\n            (len([VV]) = len([ys])),\n            (listElts([VV]) = Set_cup([listElts([ys]); listElts([ys])])),\n            (listElts([VV]) = listElts([ys])),\n            (listElts([ys]) = Set_cup([listElts([ys]); listElts([VV])])),\n            (len([VV]) &gt;= 0)}ys) (forall a.\n(GHC.Classes.Ord a) =&gt;\nx1:[a]\n-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);\n                                          listElts([x1])])),\n               (listElts([VV]) = listElts([x1])),\n               (listElts([x1]) = Set_cup([listElts([x1]); listElts([VV])]))}mergeSort {VV : [a] | (VV = zs),\n            (VV = zs),\n            (len([VV]) = len([zs])),\n            (listElts([VV]) = Set_cup([listElts([zs]); listElts([zs])])),\n            (listElts([VV]) = listElts([zs])),\n            (listElts([zs]) = Set_cup([listElts([zs]); listElts([VV])])),\n            (len([VV]) &gt;= 0)}zs) \n370:   where \n371:     ({VV : [a] | (VV = ys),\n            (len([VV]) = len([ys])),\n            (listElts([VV]) = Set_cup([listElts([ys]); listElts([ys])])),\n            (listElts([VV]) = listElts([ys])),\n            (listElts([ys]) = Set_cup([listElts([ys]); listElts([VV])])),\n            (len([VV]) &gt;= 0)}ys, {VV : [a] | (VV = zs),\n            (len([VV]) = len([zs])),\n            (listElts([VV]) = Set_cup([listElts([zs]); listElts([zs])])),\n            (listElts([VV]) = listElts([zs])),\n            (listElts([zs]) = Set_cup([listElts([zs]); listElts([VV])])),\n            (len([VV]) &gt;= 0)}zs)  = xs:[a]\n-&gt; ([a] , [a])&lt;\\ys VV -&gt; (listElts([xs]) = Set_cup([listElts([ys]);\n                                                    listElts([VV])]))&gt;split {VV : [a] | (len([VV]) &gt;= 0)}xs\n</pre> <p>The type given to <code>mergeSort</code>guarantees that the set of elements in the  output list is indeed the same as in the input list. Of course, it says  nothing about whether the list is actually sorted. </p> <p>Well, Rome wasn't built in a day...</p>","tags":["basic","measures","sets"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/","title":"Unique Zippers","text":"<p>The story so far: Previously we saw how we can use LiquidHaskell to talk about set of values and specifically the set of values in a list.</p> <p>Often, we want to enforce the invariant that a particular data structure contains no duplicates. For example, we may have a structure that holds a collection of file handles, or other resources, where the presence of duplicates could lead to unpleasant leaks.</p> <p>In this post, we will see how to use LiquidHaskell to talk about the set of duplicate values in data structures, and  hence, let us specify and verify uniqueness, that is, the absence of duplicates.</p> <p>To begin, lets extend our vocabulary to talk about the set of duplicate values in lists.  By constraining this set to be empty, we can specify a list without duplicates, or an unique list.  Once we express uniqueness on lists, it is straightforward to describe uniqueness on other data structures that contain lists.  As an example, we will illustrate the properties of a unique zipper.</p> <pre>37: module UniqueZipper where\n38: \n39: import Prelude  hiding (reverse, (++), filter)\n40: import Data.Set hiding (filter)\n</pre>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/#a-quick-recap","title":"A Quick Recap","text":"<p>In the previous post we used a measure for the elements of a list, from Data/Set.spec</p> <pre>48: measure listElts :: [a] -&gt; (Set a)\n49: listElts ([])    = {v | (? (Set_emp v))}\n50: listElts (x:xs)  = {v | v = (Set_cup (Set_sng x) (listElts xs)) }\n</pre> <p>With this measure we defined predicate aliases  that describe relations between lists:</p> <pre>57: {-@ predicate EqElts  X Y      = \n58:       ((listElts X) = (listElts Y))                        @-}\n59: \n60: {-@ predicate DisjointElts X Y = \n61:       (Set_emp (Set_cap (listElts X) (listElts Y)))        @-}\n62: \n63: {-@ predicate SubElts X Y      = \n64:       (Set_sub (listElts X) (listElts Y))                  @-}\n65: \n66: {-@ predicate UnionElts X Y Z  = \n67:       ((listElts X) = (Set_cup (listElts Y) (listElts Z))) @-}\n68: \n69: {-@ predicate ListElt N X      = \n70:       (Set_mem N (listElts X))                             @-}\n</pre> <p>These predicates were our vocabulary on specifying properties of list functions. Remember, that <code>reverse</code> returns an output list that has the same elements, i.e., <code>EqElts</code>, with the input list. We can extend these predicates and express list uniqueness. So reversing a unique list should again return an output list that has the same elements as the input list, and also it is unique.</p>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/#describing-unique-lists","title":"Describing Unique Lists","text":"<p>To describe unique lists, we follow two steps:</p> <ol> <li>we describe the set of duplicate values of a list; and </li> <li>we demand this set to be empty.</li> </ol> <p>Towards the first step, we define a measure <code>dups</code> that returns the duplicate values of its input list. This measure is recursively defined: The duplicates of an empty list is the empty set. We compute the duplicates of a non-empty list,  namely <code>x:xs</code>, as follows:</p> <ul> <li> <p>If <code>x</code> is an element of <code>xs</code>, then <code>x</code> is a duplicate.   Hence, <code>dups</code> is <code>x</code> plus the (recursively computed)    duplicates in <code>xs</code>.</p> </li> <li> <p>Otherwise, we can ignore <code>x</code> and recursively compute    the duplicates of <code>xs</code>.</p> </li> </ul> <p>The above intuition can be formalized as a measure:</p> <pre>105: {-@\n106:   measure dups :: [a] -&gt; (Set a)\n107:   dups([])   = {v | (? (Set_emp v))}\n108:   dups(x:xs) = {v | v = (if (Set_mem x (listElts xs))\n109:                          then (Set_cup (Set_sng x) (dups xs))\n110:                          else (dups xs)) }\n111:   @-}\n</pre> <p>With <code>dups</code> in hand, it is direct to describe unique lists:</p> <p>A list is unique, if the set of duplicates, as computed by <code>dups</code> is empty.</p> <p>We create a type alias for unique lists and name it <code>UList</code>.</p> <pre>121: {-@ predicate ListUnique X = (Set_emp (dups X)) @-}\n122: \n123: {-@ type UList a = {v:[a] | (ListUnique v)}     @-}\n</pre>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/#functions-on-unique-lists","title":"Functions on Unique Lists","text":"<p>In the previous post, we proved interesting properties about  the list trilogy, i.e., <code>append</code>, <code>reverse</code>, and <code>filter</code>. Now, we will prove that apart from these properties, all these functions preserve list uniqueness.</p>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/#append","title":"Append","text":"<p>To begin with, we proved that the output of append indeed includes the elements from both the input lists. Now, we can also prove that if both input lists are  unique and their elements are disjoint, then the  output list is also unique.</p> <pre>145: infixr 5 ++\n146: {-@ (++) :: xs:(UList a)\n147:          -&gt; ys:{v: UList a | (DisjointElts v xs)}\n148:          -&gt; {v: UList a | (UnionElts v xs ys)}\n149:   @-}\n150: (++)         :: [a] -&gt; [a] -&gt; [a]\n151: [] forall a.\nxs:{VV : [a] | ((Set_emp (dups VV)))}\n-&gt; ys:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts xs)))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts ys)))}++ {VV : [a] | ((Set_emp (dups VV)))}ys     = {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == ys) &amp;&amp; ((len VV) &gt;= 0)}ys\n152: (x:xs) ++ ys = {VV : a | (VV == x)}xforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\ny:a\n-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}:({VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs xs:{VV : [a] | ((Set_emp (dups VV)))}\n-&gt; ys:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts xs)))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts ys)))}++ {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == ys) &amp;&amp; ((len VV) &gt;= 0)}ys)\n</pre>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/#reverse","title":"Reverse","text":"<p>Next, we can prove that if a unique list is reversed,  the output list has the same elements as the input, and also it is unique.</p> <pre>163: {-@ reverse :: xs:(UList a) -&gt; {v: UList a | (EqElts v xs)} @-}\n164: reverse :: [a] -&gt; [a]\n165: forall a.\nxs:{VV : [a] | ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (listElts xs))}reverse = x1:{VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((len VV) == 0)}\n-&gt; x2:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts x1)))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x1) (listElts x2))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x2) (listElts x1))) &amp;&amp; ((len VV) &gt;= 0)}go {VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}[]\n166:   where\n167:     a:{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((len VV) &gt;= 0)}\n-&gt; x1:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts a)))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts a) (listElts x1))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x1) (listElts a))) &amp;&amp; ((len VV) &gt;= 0)}go {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((len VV) &gt;= 0)}a []     = {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == a) &amp;&amp; ((len VV) &gt;= 0)}a\n168:     go a (x:xs) = a:{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((len VV) &gt;= 0)}\n-&gt; x1:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts a)))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts a) (listElts x1))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x1) (listElts a))) &amp;&amp; ((len VV) &gt;= 0)}go ({VV : a | (VV == x)}xforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\ny:a\n-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}:{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == a) &amp;&amp; ((len VV) &gt;= 0)}a) {VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs \n</pre>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/#filter","title":"Filter","text":"<p>Finally, filtering a unique list returns a list with a subset of values of the input list, that once again is unique! </p> <pre>178: {-@ filter :: (a -&gt; Bool) \n179:            -&gt; xs:(UList a) \n180:            -&gt; {v:UList a | (SubElts v xs)} \n181:   @-}\n182: forall a.\n(a -&gt; (GHC.Types.Bool))\n-&gt; x2:{VV : [a] | ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts x2))) &amp;&amp; ((len VV) &gt;= 0)}filter a -&gt; (GHC.Types.Bool)p [] = forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\n{VV : [{VV : a | false}]&lt;p&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0)}[]\n183: filter p (x:xs) \n184:   | a -&gt; (GHC.Types.Bool)p {VV : a | (VV == x)}x       = {VV : a | (VV == x)}x forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\ny:a\n-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}: forall a.\n(a -&gt; (GHC.Types.Bool))\n-&gt; x2:{VV : [a] | ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts x2))) &amp;&amp; ((len VV) &gt;= 0)}filter a -&gt; (GHC.Types.Bool)p {VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs\n185:   | otherwise = forall a.\n(a -&gt; (GHC.Types.Bool))\n-&gt; x2:{VV : [a] | ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts x2))) &amp;&amp; ((len VV) &gt;= 0)}filter a -&gt; (GHC.Types.Bool)p {VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs\n</pre>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/#unique-zipper","title":"Unique Zipper","text":"<p>That was easy enough! Now, lets look at a slightly more interesting structure fashioned from lists.  A zipper is an aggregate data stucture that is used to arbitrary traverse the structure and update its contents.</p> <p>We define a zipper as a data type that contains an element (called <code>focus</code>) that we are currently using, a list of elements (called <code>up</code>) before the current one, and a list of elements (called <code>down</code>) after the current one.</p> <pre>202: data Zipper a = Zipper { forall a. (UniqueZipper.Zipper a) -&gt; afocus :: a       -- focused element in this set\n203:                        , forall a. (UniqueZipper.Zipper a) -&gt; [a]up    :: [a]     -- elements to the left\n204:                        , forall a. (UniqueZipper.Zipper a) -&gt; [a]down  :: [a] }   -- elements to the right\n</pre> <p>One well-known application of zippers is in the XMonad tiling window manager.  The set of windows being managed is stored in a zipper  similar to the above. The <code>focus</code> happily coincides with  the window currently in focus, and the <code>up</code> and <code>down</code>  to the list of windows that come before and after it.</p> <p>One crucial invariant maintained by XMonad is that the zipper structure is unique -- i.e. each window appears at most once inside the zipper.</p> <p>Lets see how we can state and check that all the values in a zipper are unique.</p> <p>To start with, we would like to refine the <code>Zipper</code> data declaration to express that both the lists in the structure are unique and  do not include <code>focus</code> in their values.</p> <p>LiquidHaskell allow us to refine data type declarations, using the liquid comments. So, apart from above definition definition for the <code>Zipper</code>, we add a refined one, stating that the data structure always enjoys the desired properties.</p> <pre>229: {-@ data Zipper a = Zipper { focus :: a\n230:                            , up    :: UListDif a focus\n231:                            , down  :: UListDif a focus}\n232:   @-}\n233: \n234: {-@ type UListDif a N = {v:(UList a) | (not (ListElt N v))} @-}\n</pre> <p>It is worth noting that the above is kind of dependent record in that the types of the <code>up</code> and <code>down</code> fields depend on the value of the <code>focus</code> field.</p> <p>With this annotation any time we use a <code>Zipper</code> in the code LiquidHaskell knows that the <code>up</code> and <code>down</code> components are unique lists that do not include <code>focus</code>. Moreover, when a new <code>Zipper</code> is constructed LiquidHaskell proves that this property holds, otherwise a liquid type  error is reported.</p> <p>Hold on a minute!</p> <p>The awake reader will have noticed that values inside the <code>Zipper</code> as  specified so far, are not unique, as nothing prevents a value from  appearing in both the <code>up</code> and the <code>down</code> components.</p> <p>So, we have to specify that the contents of those two fields are disjoint.</p> <p>One way to achieve this is by defining two measures <code>getUp</code> and <code>getDown</code> that return the relevant parts of the <code>Zipper</code></p> <pre>260: {-@ measure getUp :: forall a. (Zipper a) -&gt; [a] \n261:     getUp (Zipper focus up down) = up\n262:   @-}\n263: \n264: {-@ measure getDown :: forall a. (Zipper a) -&gt; [a] \n265:     getDown (Zipper focus up down) = down\n266:   @-}\n</pre> <p>With these definitions, we create a type alias <code>UZipper</code> that states that the two list components are disjoint, and hence, that we have a unique zipper with no duplicates.</p> <pre>274: {-@ \n275:   type UZipper a = {v:Zipper a | (DisjointElts (getUp v) (getDown v))} \n276:   @-}\n</pre>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/#functions-on-unique-zippers","title":"Functions on Unique Zippers","text":"<p>Now that we have defined a unique zipper, it is straightforward for LiquidHaskell to prove that operations on zippers preserve uniqueness.</p>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/#differentiation","title":"Differentiation","text":"<p>We can prove that a zipper that built from elements from a unique list is indeed unique.</p> <pre>293: {-@ differentiate :: UList a -&gt; Maybe (UZipper a) @-}\n294: forall a.\n{VV : [a] | ((Set_emp (dups VV)))}\n-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})differentiate []     = forall a. {VV : (Data.Maybe.Maybe a) | (((isJust VV)) &lt;=&gt; false)}Nothing\n295: differentiate (x:xs) = x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; {VV : (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}) | (((isJust VV)) &lt;=&gt; true) &amp;&amp; ((fromJust VV) == x)}Just ({VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n -&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}))\n-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})$ focus:a\n-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}Zipper {VV : a | (VV == x)}x {VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}[] {VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs\n</pre>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/#integration","title":"Integration","text":"<p>And vice versa, all elements of a unique zipper yield a unique list.</p> <pre>304: {-@ integrate :: UZipper a -&gt; UList a @-}\n305: forall a.\n{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; {VV : [a] | ((Set_emp (dups VV)))}integrate (Zipper x l r) = xs:{VV : [a] | ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (listElts xs))}reverse {VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == l) &amp;&amp; ((len VV) &gt;= 0)}l xs:{VV : [a] | ((Set_emp (dups VV)))}\n-&gt; ys:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts xs)))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts ys)))}++ {VV : a | (VV == x)}x forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\ny:a\n-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}: {VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == r) &amp;&amp; ((len VV) &gt;= 0)}r\n</pre> <p>Recall the types for <code>++</code> and <code>reverse</code> that we proved earlier -- hover your mouse over the identifiers to refresh your memory. Those types are essential for establishing the type of <code>integrate</code>. </p> <ul> <li> <p>By the definition of <code>UZipper</code> we know that <code>l</code> is a unique list   and that <code>x</code> is not an element of <code>l</code>.</p> </li> <li> <p>Thus via the type of <code>reverse</code> we know that  <code>reverse l</code> is also   unique and disjoint from <code>x</code> and <code>r</code>.</p> </li> <li> <p>Finally, using the previously established type for <code>++</code>    LiquidHaskell can prove that since <code>x : r</code> is a unique    list with elements disjoint from <code>reverse l</code> the concatenation   of the two lists is also a unique list.</p> </li> </ul> <p>With the exact same reasoning, we use the above list operations to create more zipper operations.</p>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/#reverse_1","title":"Reverse","text":"<p>We can reverse a unique zipper</p> <pre>332: {-@ reverseZipper :: UZipper a -&gt; UZipper a @-}\n333: reverseZipper :: Zipper a -&gt; Zipper a\n334: forall a.\n{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}reverseZipper (Zipper t ls rs) = focus:a\n-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}Zipper {VV : a | (VV == t)}t {VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}rs {VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}ls\n</pre>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/#shifting-focus","title":"Shifting Focus","text":"<p>More the focus up or down</p> <pre>343: {-@ focusUp   :: UZipper a -&gt; UZipper a @-}\n344: forall a.\n{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}focusUp (Zipper t [] rs)     = focus:a\n-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}Zipper {VV : a | (VV == x) &amp;&amp; (VV == x)}x {VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == xs) &amp;&amp; (VV == xs) &amp;&amp; ((len VV) == (len xs)) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts xs))) &amp;&amp; ((listElts VV) == (listElts xs)) &amp;&amp; ((len VV) &gt;= 0)}xs {VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}[] \n345:   where \n346:     ({VV : a | (VV == x)}x:{VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == xs) &amp;&amp; ((len VV) == (len xs)) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts xs))) &amp;&amp; ((listElts VV) == (listElts xs)) &amp;&amp; ((len VV) &gt;= 0)}xs)                   = xs:{VV : [a] | ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (listElts xs))}reverse ({VV : a | (VV == t)}tforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\ny:a\n-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}:{VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}rs)\n347: \n348: focusUp (Zipper t (l:ls) rs) = focus:a\n-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}Zipper {VV : a | (VV == l)}l {VV : [a] | (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}ls ({VV : a | (VV == t)}tforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\ny:a\n-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}:{VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}rs)\n349: \n350: {-@ focusDown :: UZipper a -&gt; UZipper a @-}\n351: forall a.\n{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}focusDown = {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}reverseZipper forall &lt;q :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool, p :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool&gt;.\n(x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n -&gt; {VV : (UniqueZipper.Zipper a)&lt;p x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})\n-&gt; (y:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n    -&gt; {VV : (UniqueZipper.Zipper a)&lt;q y&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})\n-&gt; x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; exists [z:{VV : (UniqueZipper.Zipper a)&lt;q x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}].{VV : (UniqueZipper.Zipper a)&lt;p z&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}. {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}focusUp forall &lt;q :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool, p :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool&gt;.\n(x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n -&gt; {VV : (UniqueZipper.Zipper a)&lt;p x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})\n-&gt; (y:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n    -&gt; {VV : (UniqueZipper.Zipper a)&lt;q y&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})\n-&gt; x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; exists [z:{VV : (UniqueZipper.Zipper a)&lt;q x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}].{VV : (UniqueZipper.Zipper a)&lt;p z&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}. {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}reverseZipper\n</pre>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/#filter_1","title":"Filter","text":"<p>Finally, using the filter operation on lists allows LiquidHaskell to prove that filtering a zipper also preserves uniqueness.</p> <pre>361: {-@ filterZipper :: (a -&gt; Bool) -&gt; UZipper a -&gt; Maybe (UZipper a) @-}\n362: forall a.\n(a -&gt; (GHC.Types.Bool))\n-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})filterZipper a -&gt; (GHC.Types.Bool)p (Zipper f ls rs) \n363:   = case (a -&gt; (GHC.Types.Bool))\n-&gt; xs:{VV : [a] | ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts xs)))}filter a -&gt; (GHC.Types.Bool)p ({VV : a | (VV == f)}fforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\ny:a\n-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}:{VV : [a] | (not (((Set_mem f (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}rs) of\n364:       f':rs' -&gt; x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; {VV : (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}) | (((isJust VV)) &lt;=&gt; true) &amp;&amp; ((fromJust VV) == x)}Just ({VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n -&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}))\n-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})$ focus:a\n-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}Zipper {VV : a | (VV == f')}f' ((a -&gt; (GHC.Types.Bool))\n-&gt; xs:{VV : [a] | ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts xs)))}filter a -&gt; (GHC.Types.Bool)p {VV : [a] | (not (((Set_mem f (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}ls) {VV : [a] | (VV == rs') &amp;&amp; ((len VV) &gt;= 0)}rs'\n365:       []     -&gt; case (a -&gt; (GHC.Types.Bool))\n-&gt; xs:{VV : [a] | ((Set_emp (dups VV)))}\n-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts xs)))}filter a -&gt; (GHC.Types.Bool)p {VV : [a] | (not (((Set_mem f (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}ls of                  \n366:                   f':ls' -&gt; x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; {VV : (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}) | (((isJust VV)) &lt;=&gt; true) &amp;&amp; ((fromJust VV) == x)}Just ({VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n -&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}))\n-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}\n-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})$ focus:a\n-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}\n-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}Zipper {VV : a | (VV == f')}f' {VV : [a] | (VV == ls') &amp;&amp; ((len VV) &gt;= 0)}ls' {VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}[]\n367:                   []     -&gt; forall a. {VV : (Data.Maybe.Maybe a) | (((isJust VV)) &lt;=&gt; false)}Nothing\n</pre>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-05-24-unique-zipper.lhs/#conclusion","title":"Conclusion","text":"<p>That's all for now! This post illustrated</p> <ol> <li> <p>How we can use set theory to express properties the values of the list,    such as list uniqueness.</p> </li> <li> <p>How we can use LuquidHaskell to prove that these properties are    preserved through list operations.</p> </li> <li> <p>How we can embed this properties in complicated data structures that use    lists, such as a zipper.</p> </li> </ol> <pre>390: -- TODO: Dummy function to provide qualifier hint.\n391: {-@ q :: x:a -&gt;  {v:[a] |(not (Set_mem x (listElts v)))} @-}\n392: q :: a -&gt; [a]\n393: forall a. x:a -&gt; {VV : [a] | (not (((Set_mem x (listElts VV)))))}q _ = forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\n{VV : [{VV : a | false}]&lt;p&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0)}[]\n</pre>","tags":["basic","measures","sets","uniqueness"]},{"location":"blogposts/2013-06-03-abstracting-over-refinements.lhs/","title":"Abstracting Over Refinements","text":"<p>We've seen all sorts of interesting invariants that can be expressed with refinement predicates. For example, whether a divisor is non-zero,  the dimension of lists, ensuring the safety of  vector indices and reasoning about the set of values in containers and verifying their uniqueness. In each of these cases, we were working with specific refinement predicates that described whatever property was of interest.</p> <p>Today, (drumroll please), I want to unveil a brand new feature of LiquidHaskell, which allows us to abstract over specific properties or invariants, which significantly increases the expressiveness of the  system, whilst still allowing our friend the SMT solver to carry  out verification and inference automatically.</p> <pre>30: \n31: module MickeyMouse where\n32: \n33: import Language.Haskell.Liquid.Prelude (isEven)\n</pre>","tags":["abstract-refinements"]},{"location":"blogposts/2013-06-03-abstracting-over-refinements.lhs/#pin-the-specification-on-the-function","title":"Pin The Specification On the Function","text":"<p>Lets look at some tiny mickey-mouse examples to see why we may want to abstract over refinements in the first place.</p> <p>Consider the following monomorphic <code>max</code> function on <code>Int</code> values:</p> <pre>45: maxInt     :: Int -&gt; Int -&gt; Int \n46: forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.\n{VV : (GHC.Types.Int)&lt;p&gt; | true}\n-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}\n-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}maxInt {VV : (GHC.Types.Int) | ((papp1 p VV))}x {VV : (GHC.Types.Int) | ((papp1 p VV))}y = if {VV : (GHC.Types.Int) | ((papp1 p VV)) &amp;&amp; (VV == x)}x x:{VV : (GHC.Types.Int) | ((papp1 p VV))}\n-&gt; y:{VV : (GHC.Types.Int) | ((papp1 p VV))}\n-&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; (x &lt;= y))}&lt;= {VV : (GHC.Types.Int) | ((papp1 p VV)) &amp;&amp; (VV == y)}y then {VV : (GHC.Types.Int) | ((papp1 p VV)) &amp;&amp; (VV == y)}y else {VV : (GHC.Types.Int) | ((papp1 p VV)) &amp;&amp; (VV == x)}x \n</pre> <p>We could give <code>maxInt</code> many, quite different and incomparable refinement types like</p> <pre>50: maxInt :: {v:Int | v &gt;= 0} -&gt; {v:Int | v &gt;= 0} -&gt; {v:Int | v &gt;= 0}\n</pre> <p>or</p> <pre>54: maxInt :: {v:Int | v &lt; 10} -&gt; {v:Int | v &lt; 10} -&gt; {v:Int | v &lt; 10}\n</pre> <p>or even </p> <pre>58: maxInt :: {v:Int | (Even v)} -&gt; {v:Int | (Even v)} -&gt; {v:Int | (Even v)}\n</pre> <p>All of the above are valid. </p> <p>But which one is the right type? </p> <p>At this point, you might be exasperated for one of two reasons.</p> <p>First, the type enthusiasts among you may cry out -- \"What? Does this funny refinement type system not have principal types?\"</p> <p>No. Or, to be precise, of course not!</p> <p>Principal typing is a lovely feature that is one of the many  reasons why Hindley-Milner is such a delightful sweet spot.  Unfortunately, the moment one wants fancier specifications  one must tearfully kiss principal typing good bye.</p> <p>Oh well.</p> <p>Second, you may very well say, \"Yes yes, does it even matter? Just pick one and get on with it already!\"</p> <p>Unfortunately, it matters quite a bit.</p> <p>Suppose we had a refined type describing valid RGB values:</p> <pre>87: {-@ type RGB = {v: Int | ((0 &lt;= v) &amp;&amp; (v &lt; 256)) } @-}\n</pre> <p>Now, if I wrote a function that selected the larger, that is to say, the more intense, of two RGB values, I would certainly like to check that it  produced an RGB value!</p> <pre>95: {-@ intenser   :: RGB -&gt; RGB -&gt; RGB @-}\n96: {VV : (GHC.Types.Int) | (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}intenser {VV : (GHC.Types.Int) | (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}c1 {VV : (GHC.Types.Int) | (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}c2 = forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.\n{VV : (GHC.Types.Int)&lt;p&gt; | true}\n-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}\n-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}maxInt {VV : (GHC.Types.Int) | (VV == c1) &amp;&amp; (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}c1 {VV : (GHC.Types.Int) | (VV == c2) &amp;&amp; (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}c2\n</pre> <p>Well, guess what. The first type (with <code>v &gt;= 0</code>) one would tell us that  the output was non-negative, losing the upper bound. The second type (with <code>v &lt; 10</code>) would cause LiquidHaskell to bellyache about <code>maxInt</code> being  called with improper arguments -- muttering darkly that an RGB value  is not necesarily less than <code>10</code>. As for the third type ... well, you get the idea.</p> <p>So alas, the choice of type does matter. </p> <p>If we were clairvoyant, we would give <code>maxInt</code> a type like</p> <pre>108: maxInt :: RGB -&gt; RGB -&gt; RGB \n</pre> <p>but of course, that has its own issues. (\"What? I have to write a separate function for picking the larger of two 4 digit numbers?!\")</p>","tags":["abstract-refinements"]},{"location":"blogposts/2013-06-03-abstracting-over-refinements.lhs/#defining-parametric-invariants","title":"Defining Parametric Invariants","text":"<p>Lets take a step back from the types, and turn to a spot of handwaving.</p> <p>What's really going on with <code>maxInt</code>?</p> <p>Well, the function returns one of its two arguments <code>x</code> and <code>y</code>. </p> <p>This means that if both arguments satisfy some property then the output must satisfy that property, regardless of what that property was!</p> <p>To teach LiquidHaskell to understand this notion of \"regardless of property\" we introduce the idea of abstracting over refinements or, if you prefer, parameterizing a type over its refinements.</p> <p>In particular, we type <code>maxInt</code> as</p> <pre>133: {-@ maxInt :: forall &lt;p :: Int -&gt; Prop&gt;. Int&lt;p&gt; -&gt; Int&lt;p&gt; -&gt; Int&lt;p&gt;@-}\n</pre> <p>Here, the definition says explicitly: for any property <code>p</code> that is a property of <code>Int</code>, the function takes two inputs each of which satisfy <code>p</code> and returns an output that satisfies <code>p</code>. That is to say, <code>Int&lt;p&gt;</code> is  just an abbreviation for <code>{v:Int | (p v)}</code></p> <p>Digression: Whither Decidability?  At first glance, it may appear that these abstract <code>p</code> have taken us into the realm of higher-order logics, where we must leave decidable checking and our faithful SMT companion at that door, and instead roll up our  sleeves for interactive proofs (not that there's anything wrong with that!)  Fortunately, that's not the case. We simply encode abstract refinements <code>p</code>  as uninterpreted function symbols in the refinement logic. </p> <p>Uninterpreted functions are special symbols <code>p</code> which satisfy only the congruence axiom.</p> <pre>150: forall X, Y. if (X = Y) then  p(X) = p(Y)\n</pre> <p>Happily, reasoning with such uninterpreted functions is quite decidable (thanks to Ackermann, yes, that Ackermann) and actually rather efficient. Thus, via SMT, LiquidHaskell happily verifies that <code>maxInt</code> indeed behaves as advertised: the input types ensure that both <code>(p x)</code> and <code>(p y)</code> hold  and hence that the returned value in either branch of <code>maxInt</code> satisfies  the refinement  <code>{v:Int | p(v)}</code>, thereby ensuring the output type. </p> <p>By the same reasoning, we can define the <code>maximumInt</code> operator on lists:</p> <pre>163: {-@ maximumInt :: forall &lt;p :: Int -&gt; Prop&gt;. x:[Int &lt;p&gt;] -&gt; Int &lt;p&gt;@-}\n164: forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.\n[{VV : (GHC.Types.Int)&lt;p&gt; | true}]\n-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}maximumInt (x:xs) = ({VV : (GHC.Types.Int) | ((papp1 p VV))}\n -&gt; {VV : (GHC.Types.Int) | ((papp1 p VV))}\n -&gt; {VV : (GHC.Types.Int) | ((papp1 p VV))})\n-&gt; {VV : (GHC.Types.Int) | ((papp1 p VV))}\n-&gt; [{VV : (GHC.Types.Int) | ((papp1 p VV))}]\n-&gt; {VV : (GHC.Types.Int) | ((papp1 p VV))}foldr forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.\n{VV : (GHC.Types.Int)&lt;p&gt; | true}\n-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}\n-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}maxInt {VV : (GHC.Types.Int) | ((papp1 p VV)) &amp;&amp; (VV == x)}x {VV : [{VV : (GHC.Types.Int) | ((papp1 p VV))}] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs\n</pre>","tags":["abstract-refinements"]},{"location":"blogposts/2013-06-03-abstracting-over-refinements.lhs/#using-parametric-invariants","title":"Using Parametric Invariants","text":"<p>Its only useful to parametrize over invariants if there is some easy way  to instantiate the parameters. </p> <p>Concretely, consider the function:</p> <pre>176: {-@ maxEvens1 :: xs:[Int] -&gt; {v:Int | (Even v)} @-}\n177: [(GHC.Types.Int)] -&gt; {VV : (GHC.Types.Int) | ((VV mod 2) == 0)}maxEvens1 [(GHC.Types.Int)]xs = forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.\n[{VV : (GHC.Types.Int)&lt;p&gt; | true}]\n-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}maximumInt {VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\\_ VV -&gt; ((VV mod 2) == 0)&gt; | (VV == xs'') &amp;&amp; ((len VV) == (1 + (len xs'))) &amp;&amp; ((len VV) &gt;= 0)}xs''\n178:   where \n179:     {VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\\_ VV -&gt; ((VV mod 2) == 0)&gt; | ((len VV) &gt;= 0)}xs'      = [ (GHC.Types.Int)x | x &lt;- {VV : [(GHC.Types.Int)] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs, x:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; ((x mod 2) == 0))}isEven (GHC.Types.Int)x]\n180:     {VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\\_ VV -&gt; ((VV mod 2) == 0)&gt; | ((len VV) == (1 + (len xs')))}xs''     = {VV : (GHC.Types.Int) | (VV == (0  :  int))}0 forall &lt;p :: (GHC.Types.Int)-&gt; (GHC.Types.Int)-&gt; Bool&gt;.\ny:{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}\n-&gt; ys:[{VV : (GHC.Types.Int)&lt;p y&gt; | ((VV mod 2) == 0)}]&lt;p&gt;\n-&gt; {VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;p&gt; | ((len VV) == (1 + (len ys)))}: {VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\\_ VV -&gt; ((VV mod 2) == 0)&gt; | (VV == xs') &amp;&amp; ((len VV) &gt;= 0)}xs'\n</pre> <p>where the function <code>isEven</code> is from the Language.Haskell.Liquid.Prelude library:</p> <pre>184: {- isEven :: x:Int -&gt; {v:Bool | (Prop(v) &lt;=&gt; (Even x))} -}\n185: isEven   :: Int -&gt; Bool\n186: isEven x = x `mod` 2 == 0\n</pre> <p>where the predicate <code>Even</code> is defined as</p> <pre>192: {-@ predicate Even X = ((X mod 2) = 0) @-}\n</pre> <p>To verify that <code>maxEvens1</code> returns an even number, LiquidHaskell </p> <ol> <li> <p>infers that the list <code>(0:xs')</code> has type <code>[{v:Int | (Even v)}]</code>,     that is, is a list of even numbers.</p> </li> <li> <p>automatically instantiates the refinement parameter of     <code>maximumInt</code> with the concrete refinement <code>{\\v -&gt; (Even v)}</code> and so</p> </li> <li> <p>concludes that the value returned by <code>maxEvens1</code> is indeed <code>Even</code>.</p> </li> </ol>","tags":["abstract-refinements"]},{"location":"blogposts/2013-06-03-abstracting-over-refinements.lhs/#parametric-invariants-and-type-classes","title":"Parametric Invariants and Type Classes","text":"<p>Ok, lets be honest, the above is clearly quite contrived. After all, wouldn't you write a polymorphic <code>max</code> function? And having done so, we'd just get all the above goodness from old fashioned parametricity.</p> <p>That is to say, if we just wrote:</p> <pre>213: max     :: forall a. a -&gt; a -&gt; a \n214: max x y = if x &gt; y then x else y\n215: \n216: maximum :: forall a. [a] -&gt; a\n217: maximum (x:xs) = foldr max x xs\n</pre> <p>then we could happily instantiate the <code>a</code> with <code>{v:Int | v &gt; 0}</code> or <code>{v:Int | (Even v)}</code> or whatever was needed at the call-site of <code>max</code>. Sigh. Perhaps we are still pining for Hindley-Milner.</p> <p>Well, if this was an ML perhaps we could but in Haskell, the types would be </p> <pre>225: (&gt;)     :: (Ord a) =&gt; a -&gt; a -&gt; Bool\n226: max     :: (Ord a) =&gt; a -&gt; a -&gt; a\n227: maximum :: (Ord a) =&gt; [a] -&gt; a\n</pre> <p>Our first temptation may be to furtively look over our shoulders, and convinced no one was watching, just pretend that funny <code>(Ord a)</code> business was not there, and quietly just treat <code>maximum</code> as <code>[a] -&gt; a</code> and summon parametricity.</p> <p>That would be most unwise. We may get away with it with the harmless <code>Ord</code> but what of, say, <code>Num</code>. </p> <p>Clearly a function </p> <pre>238: numCrunch :: (Num a) =&gt; [a] -&gt; a\n</pre> <p>is not going to necessarily return one of its inputs as an output.  Thus, it is laughable to believe that <code>numCrunch</code> would, if given  a list of  of even (or positive, negative, prime, RGB, ...) integers,  return a even (or positive, negative, prime, RGB, ...) integer, since  the function might add or subtract or multiply or do other unspeakable things to the numbers in order to produce the output value.</p> <p>And yet, typeclasses are everywhere. </p> <p>How could we possibly verify that</p> <pre>253: {-@ maxEvens2 :: xs:[Int] -&gt; {v:Int | (Even v) } @-}\n254: [(GHC.Types.Int)] -&gt; {VV : (GHC.Types.Int) | ((VV mod 2) == 0)}maxEvens2 [(GHC.Types.Int)]xs = [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]\n-&gt; {VV : (GHC.Types.Int) | ((VV mod 2) == 0)}maximumPoly {VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\\_ VV -&gt; ((VV mod 2) == 0)&gt; | (VV == xs'') &amp;&amp; ((len VV) == (1 + (len xs'))) &amp;&amp; ((len VV) &gt;= 0)}xs''\n255:   where \n256:      {VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\\_ VV -&gt; ((VV mod 2) == 0)&gt; | ((len VV) &gt;= 0)}xs'     = [ (GHC.Types.Int)x | x &lt;- {VV : [(GHC.Types.Int)] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs, x:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; ((x mod 2) == 0))}isEven (GHC.Types.Int)x]\n257:      {VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\\_ VV -&gt; ((VV mod 2) == 0)&gt; | ((len VV) == (1 + (len xs')))}xs''    = {VV : (GHC.Types.Int) | (VV == (0  :  int))}0 forall &lt;p :: (GHC.Types.Int)-&gt; (GHC.Types.Int)-&gt; Bool&gt;.\ny:{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}\n-&gt; ys:[{VV : (GHC.Types.Int)&lt;p y&gt; | ((VV mod 2) == 0)}]&lt;p&gt;\n-&gt; {VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;p&gt; | ((len VV) == (1 + (len ys)))}: {VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\\_ VV -&gt; ((VV mod 2) == 0)&gt; | (VV == xs') &amp;&amp; ((len VV) &gt;= 0)}xs'\n</pre> <p>where the helpers were in the usual <code>Ord</code> style?</p> <pre>263: maximumPoly :: (Ord a) =&gt; [a] -&gt; a\n264: forall a &lt;p :: a-&gt; Bool&gt;.\n(GHC.Classes.Ord a) =&gt;\n[{VV : a&lt;p&gt; | true}] -&gt; {VV : a&lt;p&gt; | true}maximumPoly (x:xs) = ({VV : a | ((papp1 p VV))}\n -&gt; {VV : a | ((papp1 p VV))} -&gt; {VV : a | ((papp1 p VV))})\n-&gt; {VV : a | ((papp1 p VV))}\n-&gt; [{VV : a | ((papp1 p VV))}]\n-&gt; {VV : a | ((papp1 p VV))}foldr {VV : a | ((papp1 p VV))}\n-&gt; {VV : a | ((papp1 p VV))} -&gt; {VV : a | ((papp1 p VV))}maxPoly {VV : a | ((papp1 p VV)) &amp;&amp; (VV == x)}x {VV : [{VV : a | ((papp1 p VV))}] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs\n265: \n266: maxPoly     :: (Ord a) =&gt; a -&gt; a -&gt; a \n267: forall a &lt;p :: a-&gt; Bool&gt;.\n(GHC.Classes.Ord a) =&gt;\n{VV : a&lt;p&gt; | true} -&gt; {VV : a&lt;p&gt; | true} -&gt; {VV : a&lt;p&gt; | true}maxPoly {VV : a | ((papp1 p VV))}x {VV : a | ((papp1 p VV))}y = if {VV : a | ((papp1 p VV)) &amp;&amp; (VV == x)}x x:{VV : a | ((papp1 p VV))}\n-&gt; y:{VV : a | ((papp1 p VV))}\n-&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; (x &lt;= y))}&lt;= {VV : a | ((papp1 p VV)) &amp;&amp; (VV == y)}y then {VV : a | ((papp1 p VV)) &amp;&amp; (VV == y)}y else {VV : a | ((papp1 p VV)) &amp;&amp; (VV == x)}x\n</pre> <p>The answer: abstract refinements.</p> <p>First, via the same analysis as the monomorphic <code>Int</code> case, LiquidHaskell establishes that</p> <pre>276: {-@ maxPoly :: forall &lt;p :: a -&gt; Prop&gt;. \n277:                  (Ord a) =&gt; x:a&lt;p&gt; -&gt; y:a&lt;p&gt; -&gt; a&lt;p&gt; @-}\n</pre> <p>and hence, that</p> <pre>283: {-@ maximumPoly :: forall &lt;p :: a -&gt; Prop&gt;. \n284:                      (Ord a) =&gt; x:[a&lt;p&gt;] -&gt; a&lt;p&gt;     @-}\n</pre> <p>Second, at the call-site for <code>maximumPoly</code> in <code>maxEvens2</code> LiquidHaskell  instantiates the type variable <code>a</code> with <code>Int</code>, and the abstract refinement parameter <code>p</code> with <code>{\\v -&gt; (Even v)}</code> after which, the verification proceeds  as described earlier (for the <code>Int</code> case).</p>","tags":["abstract-refinements"]},{"location":"blogposts/2013-06-03-abstracting-over-refinements.lhs/#and-so","title":"And So","text":"<p>If you've courageously slogged through to this point then you've learnt that </p> <ol> <li> <p>Sometimes, choosing the right type can be quite difficult! </p> </li> <li> <p>But fortunately, with abstract refinements we needn't choose, but     can write types that are parameterized over the actual concrete     invariants or refinements, which</p> </li> <li> <p>Can be instantiated at the call-sites i.e. users of the functions.</p> </li> </ol> <p>We started with some really frivolous examples, but buckle your seatbelt  and hold on tight, because we're going to see some rather nifty things that this new technique makes possible, including induction, reasoning about memoizing functions, and ordering and sorting data. Stay tuned.</p>","tags":["abstract-refinements"]},{"location":"blogposts/2013-07-29-putting-things-in-order.lhs/","title":"Putting Things In Order","text":"<p>Hello again! Since we last met, much has happened that we're rather excited about, and which we promise to get to in the fullness of time.</p> <p>Today, however, lets continue with our exploration of abstract refinements. We'll see that this rather innocent  looking mechanism packs quite a punch, by showing how  it can encode various ordering properties of  recursive data structures.</p> <pre>26: module PuttingThingsInOrder where\n27: \n28: import Prelude hiding (break)\n29: \n30: -- Haskell Type Definitions\n31: plusOnes                         :: [(Int, Int)]\n32: insertSort, mergeSort, quickSort :: (Ord a) =&gt; [a] -&gt; [a]\n</pre>","tags":["abstract-refinements"]},{"location":"blogposts/2013-07-29-putting-things-in-order.lhs/#abstract-refinements","title":"Abstract Refinements","text":"<p>Recall that abstract refinements are a mechanism that let us write and check types of the form</p> <pre>36: maxInt :: forall &lt;p :: Int -&gt; Prop&gt;. Int&lt;p&gt; -&gt; Int&lt;p&gt; -&gt; Int&lt;p&gt;\n</pre> <p>which states that the output of <code>maxInt</code> preserves  whatever invariants held for its two inputs as  long as both those inputs also satisfied those  invariants. </p> <p>First, lets see how we can (and why we may want to)  abstractly refine data types. </p>","tags":["abstract-refinements"]},{"location":"blogposts/2013-07-29-putting-things-in-order.lhs/#polymorphic-association-lists","title":"Polymorphic Association Lists","text":"<p>Suppose, we require a type for association lists.  Lets define one that is polymorphic over keys <code>k</code>  and values <code>v</code> </p> <pre>55: data AssocP k v = KVP [(k, v)]\n</pre> <p>Now, in a program, you might have multiple association lists, whose keys satisfy different properties.  For example, we might have a table for mapping digits  to the corresponding English string</p> <pre>64: digitsP :: AssocP Int String\n65: (PuttingThingsInOrder.AssocP {VV : (GHC.Types.Int) | (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)} [(GHC.Types.Char)])digitsP = [({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)}, {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)})]\n-&gt; (PuttingThingsInOrder.AssocP {VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)} {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)})KVP [ ({VV : (GHC.Types.Int) | (VV == 1) &amp;&amp; (VV &gt; 0)}, {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)})&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt;({VV : (GHC.Types.Int) | (VV == (1  :  int))}1, {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"one\")\n66:               , ({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)}, {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)})&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt;({VV : (GHC.Types.Int) | (VV == (2  :  int))}2, {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"two\")\n67:               , ({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)}, {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)})&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt;({VV : (GHC.Types.Int) | (VV == (3  :  int))}3, {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"three\") ]\n</pre> <p>We could have a separate table for sparsely storing  the contents of an array of size <code>1000</code>.</p> <pre>74: sparseVecP :: AssocP Int Double\n75: (PuttingThingsInOrder.AssocP {VV : (GHC.Types.Int) | (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)} (GHC.Types.Double))sparseVecP = [({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)}, (GHC.Types.Double))]\n-&gt; (PuttingThingsInOrder.AssocP {VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)} (GHC.Types.Double))KVP [ ({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)}, (GHC.Types.Double))({VV : (GHC.Types.Int) | (VV == (12  :  int))}12 ,  (GHC.Types.Double)34.1 )\n76:                  , ({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)}, (GHC.Types.Double))({VV : (GHC.Types.Int) | (VV == (92  :  int))}92 , (GHC.Types.Double)902.83)\n77:                  , ({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)}, (GHC.Types.Double))({VV : (GHC.Types.Int) | (VV == (451  :  int))}451,   (GHC.Types.Double)2.95)\n78:                  , ({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)}, (GHC.Types.Double))({VV : (GHC.Types.Int) | (VV == (877  :  int))}877,   (GHC.Types.Double)3.1 )]\n</pre> <p>The keys used in the two tables have rather  different properties, which we may want to track  at compile time.</p> <ul> <li>In <code>digitsP</code> the keys are between <code>0</code> and <code>9</code> </li> <li>In <code>sparseVecP</code> the keys are between <code>0</code> and <code>999</code>. </li> </ul> <p>Well, since we had the foresight to parameterize  the key type in <code>AssocP</code>, we can express the above  properties by appropriately instantiating the type of <code>k</code> with refined versions</p> <pre>94: {-@ digitsP :: AssocP {v:Int | (Btwn 0 v 9)} String @-}\n</pre> <p>and </p> <pre>100: {-@ sparseVecP :: AssocP {v:Int | (Btwn 0 v 1000)} Double @-}\n</pre> <p>where <code>Btwn</code> is just an alias </p> <pre>106: {-@ predicate Btwn Lo V Hi = (Lo &lt;= V &amp;&amp; V &lt;= Hi) @-}\n</pre>","tags":["abstract-refinements"]},{"location":"blogposts/2013-07-29-putting-things-in-order.lhs/#monomorphic-association-lists","title":"Monomorphic Association Lists","text":"<p>Now, suppose that for one reason or another, we want to  specialize our association list so that the keys are of  type <code>Int</code>. </p> <pre>117: data Assoc v = KV [(Int, v)]\n</pre> <p>(We'd probably also want to exploit the <code>Int</code>-ness  in the implementation but thats a tale for another day.)</p> <p>Now, we have our two tables</p> <pre>126: digits    :: Assoc String\n127: (PuttingThingsInOrder.Assoc [(GHC.Types.Char)])digits    = forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.\n[({VV : (GHC.Types.Int)&lt;p&gt; | true}, {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)})]\n-&gt; (PuttingThingsInOrder.Assoc &lt;p&gt; {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)})KV [ ({VV : (GHC.Types.Int) | (VV == 1) &amp;&amp; (VV &gt; 0)}, {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)})&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt;({VV : (GHC.Types.Int) | (VV == (1  :  int))}1, {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"one\")\n128:                , ({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)}, {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)})&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt;({VV : (GHC.Types.Int) | (VV == (2  :  int))}2, {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"two\")\n129:                , ({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)}, {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)})&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt;({VV : (GHC.Types.Int) | (VV == (3  :  int))}3, {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"three\") ]\n130: \n131: sparseVec :: Assoc Double\n132: (PuttingThingsInOrder.Assoc (GHC.Types.Double))sparseVec = forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.\n[({VV : (GHC.Types.Int)&lt;p&gt; | true}, (GHC.Types.Double))]\n-&gt; (PuttingThingsInOrder.Assoc &lt;p&gt; (GHC.Types.Double))KV [ ({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)}, (GHC.Types.Double))({VV : (GHC.Types.Int) | (VV == (12  :  int))}12 ,  (GHC.Types.Double)34.1 )\n133:                , ({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)}, (GHC.Types.Double))({VV : (GHC.Types.Int) | (VV == (92  :  int))}92 , (GHC.Types.Double)902.83)\n134:                , ({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)}, (GHC.Types.Double))({VV : (GHC.Types.Int) | (VV == (451  :  int))}451,   (GHC.Types.Double)2.95)\n135:                , ({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)}, (GHC.Types.Double))({VV : (GHC.Types.Int) | (VV == (877  :  int))}877,   (GHC.Types.Double)3.1 )]\n</pre> <p>but since we didn't make the key type generic, it seems  we have no way to distinguish between the invariants of  the two sets of keys. Bummer!</p>","tags":["abstract-refinements"]},{"location":"blogposts/2013-07-29-putting-things-in-order.lhs/#abstractly-refined-data","title":"Abstractly Refined Data","text":"<p>We could define two separate types of association  lists that capture different invariants, but frankly,  thats rather unfortunate, as we'd then have to  duplicate the code the manipulates the structures.  Of course, we'd like to have (type) systems help  keep an eye on different invariants, but we'd  really rather not have to duplicate code to  achieve that end. Thats the sort of thing that drives a person to JavaScript ;-).</p> <p>Fortunately, all is not lost. </p> <p>If you were paying attention last time  then you'd realize that this is the perfect job for  an abstract refinement, this time applied to a <code>data</code>  definition:</p> <pre>163: {-@ data Assoc v &lt;p :: Int -&gt; Prop&gt; \n164:       = KV (z :: [(Int&lt;p&gt;, v)]) @-} \n</pre> <p>The definition refines the type for <code>Assoc</code> to introduce an abstract refinement <code>p</code> which is, informally speaking, a property of <code>Int</code>. The definition states that each <code>Int</code> in the association list in fact satisfies <code>p</code> as, <code>Int&lt;p&gt;</code> is an abbreviation for <code>{v:Int| (p v)}</code>.</p> <p>Now, we can have our <code>Int</code> keys and refine them too! For example, we can write:</p> <pre>177: {-@ digits :: Assoc (String) &lt;{\\v -&gt; (Btwn 0 v 9)}&gt; @-}\n</pre> <p>to track the invariant for the <code>digits</code> map, and write</p> <pre>183: {-@ sparseVec :: Assoc Double &lt;{\\v -&gt; (Btwn 0 v 1000)}&gt; @-}\n</pre> <p>Thus, we can recover (some of) the benefits of abstracting  over the type of the key by instead parameterizing the type directly over the possible invariants. We will have much  more to say on association lists  (or more generally, finite maps) and abstract refinements,  but lets move on for the moment.</p>","tags":["abstract-refinements"]},{"location":"blogposts/2013-07-29-putting-things-in-order.lhs/#dependent-tuples","title":"Dependent Tuples","text":"<p>It is no accident that we have reused Haskell's function  type syntax to define abstract refinements (<code>p :: Int -&gt; Prop</code>); interesting things start to happen if we use multiple parameters.</p> <p>Consider the function <code>break</code> from the Prelude. </p> <pre>203: break                   :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])\n204: forall a.\n(a -&gt; (GHC.Types.Bool))\n-&gt; x:[a] -&gt; ([a], [a])&lt;\\y VV -&gt; ((len x) == ((len y) + (len VV)))&gt;break _ [a]xs@[]           =  forall a b &lt;p2 :: a-&gt; b-&gt; Bool&gt;.\na:a\n-&gt; b:{VV : b&lt;p2 a&gt; | true}\n-&gt; {VV : (a, b)&lt;p2&gt; | ((fst VV) == a) &amp;&amp; ((snd VV) == b)}({VV : [a] | (((null VV)) &lt;=&gt; true) &amp;&amp; (VV == xs) &amp;&amp; (VV == (GHC.Types.[])) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}xs, {VV : [a] | (((null VV)) &lt;=&gt; true) &amp;&amp; (VV == xs) &amp;&amp; (VV == (GHC.Types.[])) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}xs)\n205: break p xs@(x:xs')\n206:            | a -&gt; (GHC.Types.Bool)p {VV : a | (VV == x)}x        =  forall a b &lt;p2 :: a-&gt; b-&gt; Bool&gt;.\na:a\n-&gt; b:{VV : b&lt;p2 a&gt; | true}\n-&gt; {VV : (a, b)&lt;p2&gt; | ((fst VV) == a) &amp;&amp; ((snd VV) == b)}({VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; true) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}[], {VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs)\n207:            | otherwise  =  let ({VV : [a] | (VV == ys) &amp;&amp; ((len VV) == (len ys)) &amp;&amp; ((len xs') == ((len zs) + (len VV))) &amp;&amp; (VV /= xs) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt; (len xs)) &amp;&amp; ((len VV) &lt;= (len xs'))}ys, {VV : [a] | (VV == zs) &amp;&amp; ((len VV) == (len zs)) &amp;&amp; ((len xs') == ((len ys) + (len VV))) &amp;&amp; ((len xs') == ((len ys) + (len VV))) &amp;&amp; (VV /= xs) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt; (len xs)) &amp;&amp; ((len VV) &lt;= (len xs'))}zs) = (a -&gt; (GHC.Types.Bool))\n-&gt; x:[a] -&gt; ([a], [a])&lt;\\y VV -&gt; ((len x) == ((len y) + (len VV)))&gt;break a -&gt; (GHC.Types.Bool)p {VV : [a] | (VV == xs') &amp;&amp; ((len VV) &gt;= 0)}xs' \n208:                            in forall a b &lt;p2 :: a-&gt; b-&gt; Bool&gt;.\na:a\n-&gt; b:{VV : b&lt;p2 a&gt; | true}\n-&gt; {VV : (a, b)&lt;p2&gt; | ((fst VV) == a) &amp;&amp; ((snd VV) == b)}({VV : a | (VV == x)}xforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:a\n-&gt; xs:[{VV : a&lt;p x&gt; | true}]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}:{VV : [a] | (VV == ys) &amp;&amp; (VV == ys) &amp;&amp; ((len VV) == (len ys)) &amp;&amp; ((len xs') == ((len zs) + (len VV))) &amp;&amp; (VV /= xs) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt; (len xs)) &amp;&amp; ((len VV) &lt;= (len xs'))}ys,{VV : [a] | (VV == zs) &amp;&amp; (VV == zs) &amp;&amp; ((len VV) == (len zs)) &amp;&amp; ((len xs') == ((len ys) + (len VV))) &amp;&amp; ((len xs') == ((len ys) + (len VV))) &amp;&amp; (VV /= xs) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt; (len xs)) &amp;&amp; ((len VV) &lt;= (len xs'))}zs)\n</pre> <p>From the comments in Data.List, <code>break p xs</code>:  \"returns a tuple where the first element is longest prefix (possibly empty) <code>xs</code> of elements that do not satisfy <code>p</code> and second element is the  remainder of the list.\"</p> <p>We could formalize the notion of the second-element-being-the-remainder  using sizes. That is, we'd like to specify that the length of the second  element equals the length of <code>xs</code> minus the length of the first element. That is, we need a way to allow the refinement of the second element to  depend on the value in the first refinement. Again, we could define a special kind of tuple-of-lists-type that  has the above property baked in, but thats just not how we roll.</p> <p>Instead, lets use abstract refinements to give us dependent tuples</p> <pre>225: data (a,b)&lt;p :: a -&gt; b -&gt; Prop&gt; = (x:a, b&lt;p x&gt;) \n</pre> <p>Here, the abstract refinement takes two parameters,  an <code>a</code> and a <code>b</code>. In the body of the tuple, the  first element is named <code>x</code> and we specify that  the second element satisfies the refinement <code>p x</code>,  i.e. a partial application of <code>p</code> with the first element.  In other words, the second element is a value of type <code>{v:b | (p x v)}</code>.</p> <p>As before, we can instantiate the <code>p</code> in different ways.  For example the whimsical</p> <pre>240: {-@ plusOnes :: [(Int, Int)&lt;{\\x1 x2 -&gt; x2 = x1 + 1}&gt;] @-}\n241: [((GHC.Types.Int), (GHC.Types.Int))&lt;\\x1 VV -&gt; (VV == (x1 + 1))&gt;]plusOnes = {VV : [({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)}, {VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)})&lt;\\x3 VV -&gt; (VV == (x3 + 1)) &amp;&amp; (VV &gt; 0) &amp;&amp; (VV &gt; x3) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)&gt;]&lt;\\x1 VV -&gt; (VV /= x1)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[({VV : (GHC.Types.Int) | (VV == 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)}, {VV : (GHC.Types.Int) | (VV == 1) &amp;&amp; (VV &gt; 0)})&lt;\\x2 VV -&gt; (VV == 1) &amp;&amp; (VV == (x2 + 1)) &amp;&amp; (VV &gt; 0) &amp;&amp; (VV &gt; x2)&gt;({VV : (GHC.Types.Int) | (VV == (0  :  int))}0,{VV : (GHC.Types.Int) | (VV == (1  :  int))}1), ({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)}, {VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)})&lt;\\x2 VV -&gt; (VV == (x2 + 1)) &amp;&amp; (VV &gt; 0) &amp;&amp; (VV &gt; x2) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)&gt;({VV : (GHC.Types.Int) | (VV == (5  :  int))}5,{VV : (GHC.Types.Int) | (VV == (6  :  int))}6), ({VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)}, {VV : (GHC.Types.Int) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)})&lt;\\x2 VV -&gt; (VV == (x2 + 1)) &amp;&amp; (VV &gt; 0) &amp;&amp; (VV &gt; x2) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 1000)&gt;({VV : (GHC.Types.Int) | (VV == (999  :  int))}999,{VV : (GHC.Types.Int) | (VV == (1000  :  int))}1000)]\n</pre> <p>and returning to the remainder property for  <code>break</code> </p> <pre>247: {-@ break :: (a -&gt; Bool) -&gt; x:[a] \n248:           -&gt; ([a], [a])&lt;{\\y z -&gt; (Break x y z)}&gt; @-}\n</pre> <p>using the predicate alias</p> <pre>254: {-@ predicate Break X Y Z   = (len X) = (len Y) + (len Z) @-}\n</pre>","tags":["abstract-refinements"]},{"location":"blogposts/2013-07-29-putting-things-in-order.lhs/#abstractly-refined-lists","title":"Abstractly Refined Lists","text":"<p>Right, we've been going on for a bit. Time to put things in order.</p> <p>To recap: we've already seen one way to abstractly refine lists:  to recover a generic means of refining a monomorphic list  (e.g. the list of <code>Int</code> keys.) However, in that case we were  talking about individual keys. Next, we build upon the dependent-tuples technique we just  saw to use abstract refinements to relate different  elements inside containers.</p> <p>In particular, we can use them to specify that every pair  of elements inside the list is related according to some  abstract relation <code>p</code>. By instantiating <code>p</code> appropriately, we will be able to recover various forms of (dis) order. </p> <p>Consider the refined definition of good old Haskell lists:</p> <pre>277: data [a] &lt;p :: a -&gt; a -&gt; Prop&gt; where\n278:   | []  :: [a] &lt;p&gt;\n279:   | (:) :: h:a -&gt; [a&lt;p h&gt;]&lt;p&gt; -&gt; [a]&lt;p&gt;\n</pre> <p>Whoa! Thats a bit of a mouthful. Lets break it down.</p> <ul> <li> <p>The type is parameterized with a refinement <code>p :: a -&gt; a -&gt; Prop</code>    Think of <code>p</code> as a binary relation over the <code>a</code> values comprising   the list.</p> </li> <li> <p>The empty list <code>[]</code> is a <code>[]&lt;p&gt;</code>. Clearly, the empty list has no   elements whatsoever and so every pair is trivially, or rather,    vacuously related by <code>p</code>.</p> </li> <li> <p>The cons constructor <code>(:)</code> takes a head <code>h</code> of type <code>a</code> and a tail   of <code>a&lt;p h&gt;</code> values, each of which is related to <code>h</code> and which    (recursively) are pairwise related <code>[...]&lt;p&gt;</code> and returns a list where    all elements are pairwise related <code>[a]&lt;p&gt;</code>.</p> </li> </ul>","tags":["abstract-refinements"]},{"location":"blogposts/2013-07-29-putting-things-in-order.lhs/#pairwise-related","title":"Pairwise Related","text":"<p>Note that we're being a bit sloppy when we say pairwise related.</p> <p>What we really mean is that if a list</p> <pre>303: [x1,...,xn] :: [a]&lt;p&gt;\n</pre> <p>then for each <code>1 &lt;= i &lt; j &lt;= n</code> we have <code>(p xi xj)</code>.</p> <p>To see why, consider the list</p> <pre>309: [x1, x2, x3, ...] :: [a]&lt;p&gt;\n</pre> <p>This list unfolds into a head and tail </p> <pre>313: x1                :: a\n314: [x2, x3,...]      :: [a&lt;p x1&gt;]&lt;p&gt;\n</pre> <p>The above tail unfolds into</p> <pre>318: x2                :: a&lt;p x1&gt;\n319: [x3, ...]         :: [a&lt;p x1 &amp;&amp; p x2&gt;]&lt;p&gt;\n</pre> <p>And finally into </p> <pre>323: x3                :: a&lt;p x1 &amp;&amp; p x2&gt;\n324: [...]             :: [a&lt;p x1 &amp;&amp; p x2 &amp;&amp; p x3&gt;]&lt;p&gt;\n</pre> <p>That is, each element <code>xj</code> satisfies the refinement  <code>(p xi xj)</code> for each <code>i &lt; j</code>.</p>","tags":["abstract-refinements"]},{"location":"blogposts/2013-07-29-putting-things-in-order.lhs/#using-abstractly-refined-lists","title":"Using Abstractly Refined Lists","text":"<p>Urgh. Math is hard! </p> <p>Lets see how we can program with these funnily refined lists.</p> <p>For starters, we can define a few helpful type aliases.</p> <pre>340: {-@ type IncrList a = [a]&lt;{\\xi xj -&gt; xi &lt;= xj}&gt; @-}      \n341: {-@ type DecrList a = [a]&lt;{\\xi xj -&gt; xi &gt;= xj}&gt; @-}\n342: {-@ type UniqList a = [a]&lt;{\\xi xj -&gt; xi /= xj}&gt; @-}\n</pre> <p>As you might expect, an <code>IncrList</code> is a list of values in increasing order:</p> <pre>348: {-@ whatGosUp :: IncrList Integer @-}\n349: [(GHC.Integer.Type.Integer)]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;whatGosUp = {VV : [{VV : (GHC.Integer.Type.Integer) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)}]&lt;\\x2 VV -&gt; (VV == (x2 + 1)) &amp;&amp; (VV &gt; 0) &amp;&amp; (VV &gt; x2) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[1,2,3]\n</pre> <p>Similarly, a <code>DecrList</code> contains its values in decreasing order:</p> <pre>355: {-@ mustGoDown :: DecrList Integer @-}\n356: [(GHC.Integer.Type.Integer)]&lt;\\xi VV -&gt; (xi &gt;= VV)&gt;mustGoDown = {VV : [{VV : (GHC.Integer.Type.Integer) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)}]&lt;\\x3 VV -&gt; (VV == 1) &amp;&amp; (x3 /= VV) &amp;&amp; (VV &gt; 0) &amp;&amp; (x3 &gt;= VV) &amp;&amp; (VV &lt; x3)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[3,2,1]\n</pre> <p>My personal favorite though, is a <code>UniqList</code> which has no duplicates:</p> <pre>362: {-@ noDuplicates :: UniqList Integer @-}\n363: [(GHC.Integer.Type.Integer)]&lt;\\xi VV -&gt; (xi /= VV)&gt;noDuplicates = {VV : [{VV : (GHC.Integer.Type.Integer) | (VV &gt; 0) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)}]&lt;\\x3 VV -&gt; (x3 /= VV) &amp;&amp; (VV &gt; 0) &amp;&amp; (x3 &gt;= VV) &amp;&amp; (VV &lt; x3) &amp;&amp; (0 &lt;= VV) &amp;&amp; (VV &lt;= 9)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[1,3,2]\n</pre>","tags":["abstract-refinements"]},{"location":"blogposts/2013-07-29-putting-things-in-order.lhs/#sorting-lists","title":"Sorting Lists","text":"<p>Its all very well to specify lists with various kinds of invariants.  The question is, how easy is it to establish these invariants?</p> <p>Lets find out, by turning inevitably to that staple of all forms of formal verification: your usual textbook sorting procedures.</p> <p>Insertion Sort</p> <p>First up: insertion sort. Well, no surprises here:</p> <pre>380: {-@ insertSort    :: (Ord a) =&gt; xs:[a] -&gt; (IncrList a) @-}\n381: forall a. (GHC.Classes.Ord a) =&gt; [a] -&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;insertSort []     = forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\n{VV : [{VV : a | false}]&lt;p&gt; | (((null VV)) &lt;=&gt; true) &amp;&amp; ((len VV) == 0)}[]\n382: insertSort (x:xs) = a -&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt; -&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;insert {VV : a | (VV == x)}x ([a] -&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;insertSort {VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs) \n</pre> <p>The hard work is done by <code>insert</code> which places an  element into the correct position of a sorted list</p> <pre>389: forall a.\n(GHC.Classes.Ord a) =&gt;\na\n-&gt; x1:[a]&lt;\\x2 VV -&gt; (VV &gt;= x2)&gt;\n-&gt; {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV /= x1) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt; (len x1))}insert ay []     = {VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; true) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}[{VV : a | (VV == y)}y]\n390: insert y (x:xs) \n391:   | {VV : a | (VV == y)}y x:a -&gt; y:a -&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; (x &lt;= y))}&lt;= {VV : a | (VV == x)}x      = {VV : a | (VV == y)}y forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:{VV : a | (VV &gt;= y)}\n-&gt; xs:[{VV : a&lt;p x&gt; | (VV &gt;= y)}]&lt;p&gt;\n-&gt; {VV : [{VV : a | (VV &gt;= y)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}: {VV : a | (VV == x)}x forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:{VV : a | (VV &gt;= x) &amp;&amp; (VV &gt;= y)}\n-&gt; xs:[{VV : a&lt;p x&gt; | (VV &gt;= x) &amp;&amp; (VV &gt;= y)}]&lt;p&gt;\n-&gt; {VV : [{VV : a | (VV &gt;= x) &amp;&amp; (VV &gt;= y)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}: {VV : [{VV : a | (VV &gt;= x)}]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs \n392:   | otherwise   = {VV : a | (VV == x)}x forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:{VV : a | (VV &gt;= x)}\n-&gt; xs:[{VV : a&lt;p x&gt; | (VV &gt;= x)}]&lt;p&gt;\n-&gt; {VV : [{VV : a | (VV &gt;= x)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}: forall a.\n(GHC.Classes.Ord a) =&gt;\na\n-&gt; x1:[a]&lt;\\x2 VV -&gt; (VV &gt;= x2)&gt;\n-&gt; {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV /= x1) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt; (len x1))}insert {VV : a | (VV == y)}y {VV : [{VV : a | (VV &gt;= x)}]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs\n</pre> <p>LiquidHaskell infers that if you give <code>insert</code> an element  and a sorted list, it returns a sorted list.</p> <pre>399: {-@ insert :: (Ord a) =&gt; a -&gt; IncrList a -&gt; IncrList a @-}\n</pre> <p>If you prefer the more Haskelly way of writing insertion sort,  i.e. with a <code>foldr</code>, that works too. Can you figure out why?</p> <pre>406: {-@ insertSort' :: (Ord a) =&gt; [a] -&gt; IncrList a @-}\n407: forall a. (GHC.Classes.Ord a) =&gt; [a] -&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;insertSort' [a]xs  = (a -&gt; [a]&lt;\\x4 VV -&gt; (VV &gt;= x4)&gt; -&gt; [a]&lt;\\x4 VV -&gt; (VV &gt;= x4)&gt;)\n-&gt; [a]&lt;\\x4 VV -&gt; (VV &gt;= x4)&gt; -&gt; [a] -&gt; [a]&lt;\\x4 VV -&gt; (VV &gt;= x4)&gt;foldr a -&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt; -&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;insert {VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; true) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}[] {VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs\n</pre> <p>Merge Sort</p> <p>Well, you know the song goes. First, we write a function  that splits the input into two parts:</p> <pre>416: split          :: [a] -&gt; ([a], [a])\n417: forall a.\nx1:{VV : [a] | ((len VV) &gt;= 0)}\n-&gt; ({VV : [a] | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x1))}, {VV : [a] | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x1))})&lt;\\x2 VV -&gt; ((len x1) == ((len x2) + (len VV))) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x1)) &amp;&amp; ((len VV) &lt;= (len x2))&gt;split (x:y:zs) = forall a b &lt;p2 :: a-&gt; b-&gt; Bool&gt;.\na:a\n-&gt; b:{VV : b&lt;p2 a&gt; | true}\n-&gt; {VV : (a, b)&lt;p2&gt; | ((fst VV) == a) &amp;&amp; ((snd VV) == b)}({VV : a | (VV == x)}xforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:a\n-&gt; xs:[{VV : a&lt;p x&gt; | true}]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}:{VV : [a] | (VV == xs) &amp;&amp; (VV == xs) &amp;&amp; ((len VV) == (len xs)) &amp;&amp; ((len zs) == ((len ys) + (len VV))) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &gt;= (len ys)) &amp;&amp; ((len VV) &lt;= (len zs))}xs, {VV : a | (VV == y)}yforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:a\n-&gt; xs:[{VV : a&lt;p x&gt; | true}]&lt;p&gt;\n-&gt; {VV : [a]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}:{VV : [a] | (VV == ys) &amp;&amp; (VV == ys) &amp;&amp; ((len VV) == (len ys)) &amp;&amp; ((len zs) == ((len xs) + (len VV))) &amp;&amp; ((len zs) == ((len xs) + (len VV))) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len xs)) &amp;&amp; ((len VV) &lt;= (len xs)) &amp;&amp; ((len VV) &lt;= (len zs))}ys) \n418:   where \n419:     ({VV : [a] | (VV == xs) &amp;&amp; ((len VV) == (len xs)) &amp;&amp; ((len zs) == ((len ys) + (len VV))) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &gt;= (len ys)) &amp;&amp; ((len VV) &lt;= (len zs))}xs, {VV : [a] | (VV == ys) &amp;&amp; ((len VV) == (len ys)) &amp;&amp; ((len zs) == ((len xs) + (len VV))) &amp;&amp; ((len zs) == ((len xs) + (len VV))) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len xs)) &amp;&amp; ((len VV) &lt;= (len xs)) &amp;&amp; ((len VV) &lt;= (len zs))}ys)   = forall a.\nx1:{VV : [a] | ((len VV) &gt;= 0)}\n-&gt; ({VV : [a] | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x1))}, {VV : [a] | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x1))})&lt;\\x2 VV -&gt; ((len x1) == ((len x2) + (len VV))) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x1)) &amp;&amp; ((len VV) &lt;= (len x2))&gt;split {VV : [a] | (VV == zs) &amp;&amp; ((len VV) &gt;= 0)}zs\n420: split xs       = forall a b &lt;p2 :: a-&gt; b-&gt; Bool&gt;.\na:a\n-&gt; b:{VV : b&lt;p2 a&gt; | true}\n-&gt; {VV : (a, b)&lt;p2&gt; | ((fst VV) == a) &amp;&amp; ((snd VV) == b)}({VV : [a] | ((len VV) &gt;= 0)}xs, {VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; true) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}[])\n</pre> <p>Then we need a function that merges two (sorted) lists</p> <pre>426: forall a.\n(GHC.Classes.Ord a) =&gt;\nxs:[a]&lt;\\x3 VV -&gt; (x3 &lt;= VV)&gt;\n-&gt; x1:[a]&lt;\\x2 VV -&gt; (x2 &lt;= VV)&gt;\n-&gt; {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &gt;= (len x1)) &amp;&amp; ((len VV) &gt;= (len xs))}merge [a]&lt;\\x1 VV -&gt; (x1 &lt;= VV)&gt;xs []         = {VV : [a]&lt;\\x1 VV -&gt; (x1 &lt;= VV)&gt; | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs\n427: merge [] ys         = {VV : [a]&lt;\\x1 VV -&gt; (x1 &lt;= VV)&gt; | ((len VV) &gt;= 0)}ys\n428: merge (x:xs) (y:ys) \n429:   | {VV : a | (VV == x)}x x:a -&gt; y:a -&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; (x &lt;= y))}&lt;= {VV : a | (VV == y)}y          = {VV : a | (VV == x)}x forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:{VV : a | (VV &gt;= x)}\n-&gt; xs:[{VV : a&lt;p x&gt; | (VV &gt;= x)}]&lt;p&gt;\n-&gt; {VV : [{VV : a | (VV &gt;= x)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}: forall a.\n(GHC.Classes.Ord a) =&gt;\nxs:[a]&lt;\\x3 VV -&gt; (x3 &lt;= VV)&gt;\n-&gt; x1:[a]&lt;\\x2 VV -&gt; (x2 &lt;= VV)&gt;\n-&gt; {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &gt;= (len x1)) &amp;&amp; ((len VV) &gt;= (len xs))}merge {VV : [{VV : a | (x &lt;= VV)}]&lt;\\x1 VV -&gt; (x1 &lt;= VV)&gt; | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs ({VV : a | (VV == y)}yforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:{VV : a | (VV &gt;= x) &amp;&amp; (VV &gt;= y)}\n-&gt; xs:[{VV : a&lt;p x&gt; | (VV &gt;= x) &amp;&amp; (VV &gt;= y)}]&lt;p&gt;\n-&gt; {VV : [{VV : a | (VV &gt;= x) &amp;&amp; (VV &gt;= y)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}:{VV : [{VV : a | (y &lt;= VV)}]&lt;\\x1 VV -&gt; (x1 &lt;= VV)&gt; | (VV == ys) &amp;&amp; ((len VV) &gt;= 0)}ys)\n430:   | otherwise       = {VV : a | (VV == y)}y forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:{VV : a | (VV &gt;= y)}\n-&gt; xs:[{VV : a&lt;p x&gt; | (VV &gt;= y)}]&lt;p&gt;\n-&gt; {VV : [{VV : a | (VV &gt;= y)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}: forall a.\n(GHC.Classes.Ord a) =&gt;\nxs:[a]&lt;\\x3 VV -&gt; (x3 &lt;= VV)&gt;\n-&gt; x1:[a]&lt;\\x2 VV -&gt; (x2 &lt;= VV)&gt;\n-&gt; {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &gt;= (len x1)) &amp;&amp; ((len VV) &gt;= (len xs))}merge ({VV : a | (VV == x)}xforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:{VV : a | (VV &gt; y) &amp;&amp; (VV &gt;= x)}\n-&gt; xs:[{VV : a&lt;p x&gt; | (VV &gt; y) &amp;&amp; (VV &gt;= x)}]&lt;p&gt;\n-&gt; {VV : [{VV : a | (VV &gt; y) &amp;&amp; (VV &gt;= x)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}:{VV : [{VV : a | (x &lt;= VV)}]&lt;\\x1 VV -&gt; (x1 &lt;= VV)&gt; | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs) {VV : [{VV : a | (y &lt;= VV)}]&lt;\\x1 VV -&gt; (x1 &lt;= VV)&gt; | (VV == ys) &amp;&amp; ((len VV) &gt;= 0)}ys\n</pre> <p>LiquidHaskell deduces that if both inputs are  ordered, then so is the output.</p> <pre>437: {-@ merge :: (Ord a) =&gt; IncrList a \n438:                      -&gt; IncrList a \n439:                      -&gt; IncrList a \n440:   @-}\n</pre> <p>Finally, using the above functions we write <code>mergeSort</code>:</p> <pre>446: {-@ mergeSort :: (Ord a) =&gt; [a] -&gt; IncrList a @-}\n447: forall a. (GHC.Classes.Ord a) =&gt; [a] -&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;mergeSort []  = forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\n{VV : [{VV : a | false}]&lt;p&gt; | (((null VV)) &lt;=&gt; true) &amp;&amp; ((len VV) == 0)}[]\n448: mergeSort [x] = {VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; true) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}[{VV : a | (VV == x)}x]\n449: mergeSort xs  = [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;\n-&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt; -&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;merge ([a] -&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;mergeSort {VV : [a] | (VV == ys) &amp;&amp; (VV == ys) &amp;&amp; ((len VV) == (len ys)) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &gt;= (len zs))}ys) ([a] -&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;mergeSort {VV : [a] | (VV == zs) &amp;&amp; (VV == zs) &amp;&amp; ((len VV) == (len zs)) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len ys)) &amp;&amp; ((len VV) &lt;= (len ys))}zs) \n450:   where \n451:     ({VV : [a] | (VV == ys) &amp;&amp; ((len VV) == (len ys)) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt;= (len zs))}ys, {VV : [a] | (VV == zs) &amp;&amp; ((len VV) == (len zs)) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len ys)) &amp;&amp; ((len VV) &lt;= (len ys))}zs)  = forall a.\nx1:{VV : [a] | ((len VV) &gt;= 0)}\n-&gt; ({VV : [a] | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x1))}, {VV : [a] | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x1))})&lt;\\x2 VV -&gt; ((len x1) == ((len x2) + (len VV))) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x1)) &amp;&amp; ((len VV) &lt;= (len x2))&gt;split {VV : [a] | ((len VV) &gt;= 0)}xs\n</pre> <p>Lets see how LiquidHaskell proves the output type. </p> <ul> <li> <p>The first two cases are trivial: for an empty    or singleton list, we can vacuously instantiate    the abstract refinement with any concrete    refinement.</p> </li> <li> <p>For the last case, we can inductively assume   <code>mergeSort ys</code> and <code>mergeSort zs</code> are sorted    lists, after which the type inferred for    <code>merge</code> kicks in, allowing LiquidHaskell to conclude   that the output is also sorted.</p> </li> </ul> <p>Quick Sort</p> <p>The previous two were remarkable because they were, well, quite unremarkable.  Pretty much the standard textbook implementations work as is.  Unlike the classical developments  using indexed types we don't have to define any auxiliary  types for increasing lists, or lists whose value is in a  particular range, or any specialized <code>cons</code> operators and  so on.</p> <p>With quick sort we need to do a tiny bit of work.</p> <p>We would like to define <code>quickSort</code> as</p> <pre>481: {-@ quickSort'    :: (Ord a) =&gt; [a] -&gt; IncrList a @-}\n482: quickSort' []     = []\n483: quickSort' (x:xs) = lts ++ (x : gts) \n484:   where \n485:     lts           = quickSort' [y | y &lt;- xs, y &lt; x]\n486:     gts           = quickSort' [z | z &lt;- xs, z &gt;= x]\n</pre> <p>But, if you try it out, you'll see that LiquidHaskell  does not approve. What could possibly be the trouble?</p> <p>The problem lies with append. What type do we give <code>++</code>? </p> <p>We might try something like</p> <pre>495: (++) :: IncrList a -&gt; IncrList a -&gt; IncrList a\n</pre> <p>but of course, this is bogus, as </p> <pre>499: [1,2,4] ++ [3,5,6]\n</pre> <p>is decidedly not an <code>IncrList</code>!</p> <p>Instead, at this particular use of <code>++</code>, there is an extra nugget of information: there is a pivot element <code>x</code> such that every element in the first  argument is less than <code>x</code> and every element in  the second argument is greater than <code>x</code>. </p> <p>There is no way we can give the usual append <code>++</code>  a type that reflects the above as there is no pivot  <code>x</code> to refer to. Thus, with a heavy heart, we must write a specialized pivot-append that uses this fact:</p> <pre>516: forall a.\npiv:a\n-&gt; x1:[{VV : a | (VV &lt; piv)}]&lt;\\x3 VV -&gt; (VV &gt;= x3)&gt;\n-&gt; ys:[{VV : a | (piv &lt;= VV)}]&lt;\\x2 VV -&gt; (x2 &lt;= VV)&gt;\n-&gt; {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV /= x1) &amp;&amp; (VV /= ys) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt; (len x1)) &amp;&amp; ((len VV) &gt; (len ys))}pivApp apiv []     [{VV : a | (piv &lt;= VV)}]&lt;\\x1 VV -&gt; (x1 &lt;= VV)&gt;ys  = {VV : a | (VV == piv)}piv forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:{VV : a | (VV &gt;= piv)}\n-&gt; xs:[{VV : a&lt;p x&gt; | (VV &gt;= piv)}]&lt;p&gt;\n-&gt; {VV : [{VV : a | (VV &gt;= piv)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}: {VV : [{VV : a | (piv &lt;= VV)}]&lt;\\x1 VV -&gt; (x1 &lt;= VV)&gt; | (VV == ys) &amp;&amp; ((len VV) &gt;= 0)}ys\n517: pivApp piv (x:xs) ys  = {VV : a | (VV == x) &amp;&amp; (VV &lt; piv)}x   forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:{VV : a | (VV &gt;= x)}\n-&gt; xs:[{VV : a&lt;p x&gt; | (VV &gt;= x)}]&lt;p&gt;\n-&gt; {VV : [{VV : a | (VV &gt;= x)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}: forall a.\npiv:a\n-&gt; x1:[{VV : a | (VV &lt; piv)}]&lt;\\x3 VV -&gt; (VV &gt;= x3)&gt;\n-&gt; ys:[{VV : a | (piv &lt;= VV)}]&lt;\\x2 VV -&gt; (x2 &lt;= VV)&gt;\n-&gt; {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV /= x1) &amp;&amp; (VV /= ys) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt; (len x1)) &amp;&amp; ((len VV) &gt; (len ys))}pivApp {VV : a | (VV == piv)}piv {VV : [{VV : a | (VV &gt;= x) &amp;&amp; (VV &lt; piv)}]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs {VV : [{VV : a | (piv &lt;= VV)}]&lt;\\x1 VV -&gt; (x1 &lt;= VV)&gt; | (VV == ys) &amp;&amp; ((len VV) &gt;= 0)}ys\n</pre> <p>Now, LiquidHaskell infers that </p> <pre>523: {-@ pivApp :: piv:a \n524:            -&gt; IncrList {v:a | v &lt;  piv} \n525:            -&gt; IncrList {v:a | v &gt;= piv} \n526:            -&gt; IncrList a \n527:   @-}\n</pre> <p>And we can use <code>pivApp</code> to define `quickSort' simply as:</p> <pre>533: {-@ quickSort    :: (Ord a) =&gt; [a] -&gt; IncrList a @-}\n534: forall a. (GHC.Classes.Ord a) =&gt; [a] -&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;quickSort []     = forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\n{VV : [{VV : a | false}]&lt;p&gt; | (((null VV)) &lt;=&gt; true) &amp;&amp; ((len VV) == 0)}[]\n535: quickSort (x:xs) = piv:a\n-&gt; [{VV : a | (VV &lt; piv)}]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;\n-&gt; [{VV : a | (VV &gt;= piv)}]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;\n-&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;pivApp {VV : a | (VV == x)}x {VV : [{VV : a | (VV &lt; x)}]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt; | (VV == lts) &amp;&amp; ((len VV) &gt;= 0)}lts {VV : [{VV : a | (VV &gt;= x)}]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt; | (VV == gts) &amp;&amp; ((len VV) &gt;= 0)}gts \n536:   where \n537:     [{VV : a | (VV &lt; x)}]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;lts          = [{VV : a | (VV &lt; x)}]\n-&gt; [{VV : a | (VV &lt; x)}]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;quickSort {VV : [{VV : a | (VV &lt; x)}]&lt;\\_ VV -&gt; (VV &lt; x)&gt; | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len xs))}[ay | y &lt;- {VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs, ay x:a -&gt; y:a -&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; (x &lt; y))}&lt; {VV : a | (VV == x)}x ]\n538:     [{VV : a | (VV &gt;= x)}]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;gts          = [{VV : a | (VV &gt;= x)}]\n-&gt; [{VV : a | (VV &gt;= x)}]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;quickSort {VV : [{VV : a | (VV &gt;= x)}]&lt;\\_ VV -&gt; (VV &gt;= x)&gt; | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len xs))}[az | z &lt;- {VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs, az x:a -&gt; y:a -&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; (x &gt;= y))}&gt;= {VV : a | (VV == x)}x]\n</pre>","tags":["abstract-refinements"]},{"location":"blogposts/2013-07-29-putting-things-in-order.lhs/#really-sorting-lists","title":"Really Sorting Lists","text":"<p>The convenient thing about our encoding is that the  underlying datatype is plain Haskell lists.  This yields two very concrete benefits.  First, as mentioned before, we can manipulate  sorted lists with the same functions we'd use  for regular lists. Second, by decoupling (or rather, parameterizing) the relation or property or invariant from the actual  data structure we can plug in different invariants,  sometimes in the same program.</p> <p>To see why this is useful, lets look at a real-world  sorting algorithm: the one used inside GHC's  <code>Data.List</code> module.</p> <pre>560: sort :: (Ord a) =&gt; [a] -&gt; [a]\n561: forall a. (GHC.Classes.Ord a) =&gt; [a] -&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;sort = {VV : [{VV : [a]&lt;\\x2 VV -&gt; (VV &gt;= x2)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt; 0)}\n-&gt; {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}mergeAll forall &lt;q :: [a]-&gt; [[a]]-&gt; Bool, p :: [[a]]-&gt; [a]-&gt; Bool&gt;.\n(x:{VV : [{VV : [a]&lt;\\x5 VV -&gt; (VV &gt;= x5)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt; 0)}\n -&gt; {VV : [a]&lt;\\x4 VV -&gt; (VV &gt;= x4)&gt;&lt;p x&gt; | ((len VV) &gt;= 0)})\n-&gt; (y:[a]\n    -&gt; {VV : [{VV : [a]&lt;\\x5 VV -&gt; (VV &gt;= x5)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt;&lt;q y&gt; | ((len VV) &gt; 0)})\n-&gt; x:[a]\n-&gt; exists [z:{VV : [{VV : [a]&lt;\\x5 VV -&gt; (VV &gt;= x5)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt;&lt;q x&gt; | ((len VV) &gt; 0)}].{VV : [a]&lt;\\x4 VV -&gt; (VV &gt;= x4)&gt;&lt;p z&gt; | ((len VV) &gt;= 0)}. [a]\n-&gt; {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt; 0)}sequences\n562:   where\n563:     [a]\n-&gt; {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt; 0)}sequences (a:b:xs)\n564:       | {VV : a | (VV == a)}a x:a\n-&gt; y:a\n-&gt; {VV : (GHC.Types.Ordering) | ((VV == GHC.Types.EQ) &lt;=&gt; (x == y)) &amp;&amp; ((VV == GHC.Types.GT) &lt;=&gt; (x &gt; y)) &amp;&amp; ((VV == GHC.Types.LT) &lt;=&gt; (x &lt; y))}`compare` {VV : a | (VV == b)}b x:(GHC.Types.Ordering)\n-&gt; y:(GHC.Types.Ordering)\n-&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; (x == y))}== {VV : (GHC.Types.Ordering) | (VV == GHC.Types.GT) &amp;&amp; ((cmp VV) == GHC.Types.GT)}GT = a:a\n-&gt; {VV : [{VV : a | (VV &gt; a)}]&lt;\\x2 VV -&gt; (VV &gt; a) &amp;&amp; (VV &gt; x2)&gt; | ((len VV) &gt; 0)}\n-&gt; {VV : [a] | ((len VV) &gt;= 0)}\n-&gt; {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt; 0)}descending {VV : a | (VV == b)}b {VV : [{VV : a | (VV == a) &amp;&amp; (VV &gt; b)}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : a | (VV == a)}a]  {VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs\n565:       | otherwise           = a:a\n-&gt; (x1:{VV : [{VV : a | (VV &gt;= a)}]&lt;\\x3 VV -&gt; (VV &gt;= a) &amp;&amp; (VV &gt;= x3)&gt; | ((len VV) &gt; 0)}\n    -&gt; {VV : [a]&lt;\\x2 VV -&gt; (VV &gt;= x2)&gt; | (VV /= x1) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt; (len x1))})\n-&gt; {VV : [a] | ((len VV) &gt;= 0)}\n-&gt; {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt; 0)}ascending  {VV : a | (VV == b)}b ({VV : a | (VV == a)}aforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:{VV : a | (VV &gt;= a)}\n-&gt; xs:[{VV : a&lt;p x&gt; | (VV &gt;= a)}]&lt;p&gt;\n-&gt; {VV : [{VV : a | (VV &gt;= a)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}:) {VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs\n566:     sequences [x] = {VV : [{VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | false}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; true) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [{VV : a | (VV == a)}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : a | (VV == a)}x]]\n567:     sequences []  = {VV : [{VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | false}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; true) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; true) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}[]]\n568: \n569:     a:a\n-&gt; {VV : [{VV : a | (VV &gt; a)}]&lt;\\x2 VV -&gt; (VV &gt; a) &amp;&amp; (VV &gt; x2)&gt; | ((len VV) &gt; 0)}\n-&gt; {VV : [a] | ((len VV) &gt;= 0)}\n-&gt; {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt; 0)}descending aa {VV : [{VV : a | (VV &gt; a)}]&lt;\\x1 VV -&gt; (VV &gt; a) &amp;&amp; (VV &gt; x1)&gt; | ((len VV) &gt; 0)}as (b:bs)\n570:       | {VV : a | (VV == a)}a x:a\n-&gt; y:a\n-&gt; {VV : (GHC.Types.Ordering) | ((VV == GHC.Types.EQ) &lt;=&gt; (x == y)) &amp;&amp; ((VV == GHC.Types.GT) &lt;=&gt; (x &gt; y)) &amp;&amp; ((VV == GHC.Types.LT) &lt;=&gt; (x &lt; y))}`compare` {VV : a | (VV == b)}b x:(GHC.Types.Ordering)\n-&gt; y:(GHC.Types.Ordering)\n-&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; (x == y))}== {VV : (GHC.Types.Ordering) | (VV == GHC.Types.GT) &amp;&amp; ((cmp VV) == GHC.Types.GT)}GT = a:a\n-&gt; {VV : [{VV : a | (VV &gt; a)}]&lt;\\x2 VV -&gt; (VV &gt; a) &amp;&amp; (VV &gt; x2)&gt; | ((len VV) &gt; 0)}\n-&gt; {VV : [a] | ((len VV) &gt;= 0)}\n-&gt; {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt; 0)}descending {VV : a | (VV == b)}b ({VV : a | (VV == a)}aforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:{VV : a | (VV &gt; b) &amp;&amp; (VV &gt;= a)}\n-&gt; xs:[{VV : a&lt;p x&gt; | (VV &gt; b) &amp;&amp; (VV &gt;= a)}]&lt;p&gt;\n-&gt; {VV : [{VV : a | (VV &gt; b) &amp;&amp; (VV &gt;= a)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}:{VV : [{VV : a | (VV &gt; a)}]&lt;\\x1 VV -&gt; (VV &gt; a) &amp;&amp; (VV &gt; x1)&gt; | (VV == as) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt;= 0)}as) {VV : [a] | (VV == bs) &amp;&amp; ((len VV) &gt;= 0)}bs\n571:     descending a as bs      = ({VV : a | (VV == a)}aforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:{VV : a | (VV &gt;= a)}\n-&gt; xs:[{VV : a&lt;p x&gt; | (VV &gt;= a)}]&lt;p&gt;\n-&gt; {VV : [{VV : a | (VV &gt;= a)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}:{VV : [{VV : a | (VV &gt; a)}]&lt;\\x1 VV -&gt; (VV &gt; a) &amp;&amp; (VV &gt; x1)&gt; | (VV == as) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt;= 0)}as)forall &lt;p :: [a]-&gt; [a]-&gt; Bool&gt;.\nx:{VV : [a]&lt;\\x3 VV -&gt; (VV &gt;= x3)&gt; | ((len VV) &gt;= 0)}\n-&gt; xs:[{VV : [a]&lt;\\x3 VV -&gt; (VV &gt;= x3)&gt;&lt;p x&gt; | ((len VV) &gt;= 0)}]&lt;p&gt;\n-&gt; {VV : [{VV : [a]&lt;\\x3 VV -&gt; (VV &gt;= x3)&gt; | ((len VV) &gt;= 0)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}: [a]\n-&gt; {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt; 0)}sequences {VV : [a] | ((len VV) &gt;= 0)}bs\n572: \n573:     a:a\n-&gt; (x1:{VV : [{VV : a | (VV &gt;= a)}]&lt;\\x3 VV -&gt; (VV &gt;= a) &amp;&amp; (VV &gt;= x3)&gt; | ((len VV) &gt; 0)}\n    -&gt; {VV : [a]&lt;\\x2 VV -&gt; (VV &gt;= x2)&gt; | (VV /= x1) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt; (len x1))})\n-&gt; {VV : [a] | ((len VV) &gt;= 0)}\n-&gt; {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt; 0)}ascending aa x1:{VV : [{VV : a | (VV &gt;= a)}]&lt;\\x2 VV -&gt; (VV &gt;= a) &amp;&amp; (VV &gt;= x2)&gt; | ((len VV) &gt; 0)}\n-&gt; {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV /= x1) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt; (len x1))}as (b:bs)\n574:       | {VV : a | (VV == a)}a x:a\n-&gt; y:a\n-&gt; {VV : (GHC.Types.Ordering) | ((VV == GHC.Types.EQ) &lt;=&gt; (x == y)) &amp;&amp; ((VV == GHC.Types.GT) &lt;=&gt; (x &gt; y)) &amp;&amp; ((VV == GHC.Types.LT) &lt;=&gt; (x &lt; y))}`compare` {VV : a | (VV == b)}b x:(GHC.Types.Ordering)\n-&gt; y:(GHC.Types.Ordering)\n-&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; (x /= y))}/= {VV : (GHC.Types.Ordering) | (VV == GHC.Types.GT) &amp;&amp; ((cmp VV) == GHC.Types.GT)}GT = a:a\n-&gt; (x1:{VV : [{VV : a | (VV &gt;= a)}]&lt;\\x3 VV -&gt; (VV &gt;= a) &amp;&amp; (VV &gt;= x3)&gt; | ((len VV) &gt; 0)}\n    -&gt; {VV : [a]&lt;\\x2 VV -&gt; (VV &gt;= x2)&gt; | (VV /= x1) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt; (len x1))})\n-&gt; {VV : [a] | ((len VV) &gt;= 0)}\n-&gt; {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt; 0)}ascending {VV : a | (VV == b)}b (ys:{VV : [{VV : a | (VV &gt;= a) &amp;&amp; (VV &gt;= b)}]&lt;\\x2 VV -&gt; (VV &gt;= a) &amp;&amp; (VV &gt;= b) &amp;&amp; (VV &gt;= x2)&gt; | ((len VV) &gt; 0)}\n-&gt; {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV /= ys) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt; (len ys))}\\{VV : [{VV : a | (VV &gt;= a) &amp;&amp; (VV &gt;= b)}]&lt;\\x1 VV -&gt; (VV &gt;= a) &amp;&amp; (VV &gt;= b) &amp;&amp; (VV &gt;= x1)&gt; | ((len VV) &gt; 0)}ys -&gt; x1:{VV : [{VV : a | (VV &gt;= a)}]&lt;\\x2 VV -&gt; (VV &gt;= a) &amp;&amp; (VV &gt;= x2)&gt; | ((len VV) &gt; 0)}\n-&gt; {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV /= x1) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt; (len x1))}as ({VV : a | (VV == a)}aforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx:{VV : a | (VV &gt;= a)}\n-&gt; xs:[{VV : a&lt;p x&gt; | (VV &gt;= a)}]&lt;p&gt;\n-&gt; {VV : [{VV : a | (VV &gt;= a)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}:{VV : [{VV : a | (VV &gt;= a) &amp;&amp; (VV &gt;= b)}]&lt;\\x1 VV -&gt; (VV &gt;= a) &amp;&amp; (VV &gt;= b) &amp;&amp; (VV &gt;= x1)&gt; | (VV == ys) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt;= 0)}ys)) {VV : [a] | (VV == bs) &amp;&amp; ((len VV) &gt;= 0)}bs\n575:     ascending a as bs       = x1:{VV : [{VV : a | (VV &gt;= a)}]&lt;\\x2 VV -&gt; (VV &gt;= a) &amp;&amp; (VV &gt;= x2)&gt; | ((len VV) &gt; 0)}\n-&gt; {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV /= x1) &amp;&amp; ((len VV) &gt; 0) &amp;&amp; ((len VV) &gt; (len x1))}as {VV : [{VV : a | (VV == a)}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : a | (VV == a)}a]forall &lt;p :: [a]-&gt; [a]-&gt; Bool&gt;.\nx:{VV : [a]&lt;\\x3 VV -&gt; (VV &gt;= x3)&gt; | ((len VV) &gt;= 0)}\n-&gt; xs:[{VV : [a]&lt;\\x3 VV -&gt; (VV &gt;= x3)&gt;&lt;p x&gt; | ((len VV) &gt;= 0)}]&lt;p&gt;\n-&gt; {VV : [{VV : [a]&lt;\\x3 VV -&gt; (VV &gt;= x3)&gt; | ((len VV) &gt;= 0)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}: [a]\n-&gt; {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt; 0)}sequences {VV : [a] | ((len VV) &gt;= 0)}bs\n576: \n577:     {VV : [{VV : [a]&lt;\\x2 VV -&gt; (VV &gt;= x2)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt;= 0)}\n-&gt; {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}mergeAll [x] = {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV == x) &amp;&amp; ((len VV) &gt;= 0)}x\n578:     mergeAll xs  = {VV : [{VV : [a]&lt;\\x2 VV -&gt; (VV &gt;= x2)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt;= 0)}\n-&gt; {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}mergeAll (x1:{VV : [{VV : [a]&lt;\\x2 VV -&gt; (VV &gt;= x2)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt;= 0)}\n-&gt; {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x1))}mergePairs {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt;= 0)}xs)\n579: \n580:     x1:{VV : [{VV : [a]&lt;\\x2 VV -&gt; (VV &gt;= x2)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt;= 0)}\n-&gt; {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x1))}mergePairs (a:b:xs) = [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;\n-&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt; -&gt; [a]&lt;\\xi VV -&gt; (xi &lt;= VV)&gt;merge {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV == a) &amp;&amp; ((len VV) &gt;= 0)}a {VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV == b) &amp;&amp; ((len VV) &gt;= 0)}bforall &lt;p :: [a]-&gt; [a]-&gt; Bool&gt;.\nx:{VV : [a]&lt;\\x3 VV -&gt; (x3 &lt;= VV)&gt; | ((len VV) &gt;= 0)}\n-&gt; xs:[{VV : [a]&lt;\\x3 VV -&gt; (x3 &lt;= VV)&gt;&lt;p x&gt; | ((len VV) &gt;= 0)}]&lt;p&gt;\n-&gt; {VV : [{VV : [a]&lt;\\x3 VV -&gt; (x3 &lt;= VV)&gt; | ((len VV) &gt;= 0)}]&lt;p&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) == (1 + (len xs)))}: x1:{VV : [{VV : [a]&lt;\\x2 VV -&gt; (VV &gt;= x2)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt;= 0)}\n-&gt; {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x1))}mergePairs {VV : [{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}xs\n581:     mergePairs [x]      = {VV : [{VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | false}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; true) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [a]&lt;\\x1 VV -&gt; (VV &gt;= x1)&gt; | (VV == a) &amp;&amp; ((len VV) &gt;= 0)}x]\n582:     mergePairs []       = forall &lt;p :: [a]-&gt; [a]-&gt; Bool&gt;.\n{VV : [{VV : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | false}]&lt;p&gt; | (((null VV)) &lt;=&gt; true) &amp;&amp; ((len VV) == 0)}[]\n</pre> <p>The interesting thing about the procedure is that it  generates some intermediate lists that are increasing  and others that are decreasing, and then somehow miraculously whips this whirlygig into a single  increasing list.</p> <p>Yet, to check this rather tricky algorithm with  LiquidHaskell we need merely write:</p> <pre>595: {-@ sort :: (Ord a) =&gt; [a] -&gt; IncrList a  @-}\n</pre>","tags":["abstract-refinements"]},{"location":"blogposts/2013-10-10-csv-tables.lhs/","title":"CSV Tables","text":"<p>Most demonstrations for verification techniques involve programs with complicated invariants and properties. However, these methods can often be rather useful for describing simple but important aspects of APIs or programs with more humble goals. I saw a rather nice example of using Scala's <code>Shapeless</code> library for preventing off-by-one errors in CSV processing code. Here's the same, short, example rephrased with LiquidHaskell.</p> <pre>23: module CSV where\n24: \n25: -- | Using LiquidHaskell for CSV lists\n26: -- c.f. http://www.reddit.com/r/scala/comments/1nhzi2/using_shapelesss_sized_type_to_eliminate_real/\n</pre>","tags":["measures"]},{"location":"blogposts/2013-10-10-csv-tables.lhs/#the-type","title":"The Type","text":"<p>Suppose you wanted to represent tables as a list of comma-separated values.</p> <p>For example, here's a table listing the articles and prices at the coffee shop I'm sitting in right now:</p> Item Price Espresso 2.25 Macchiato 2.75 Cappucino 3.35 Americano 2.25 <p>You might represent this with a simple Haskell data type:</p> <pre>64: \n65: data CSV = Csv { (CSV.CSV) -&gt; [[(GHC.Types.Char)]]headers :: [String]\n66:                , (CSV.CSV) -&gt; [[[(GHC.Types.Char)]]]rows    :: [[String]]\n67:                }\n</pre> <p>and now, the above table is just:</p> <pre>73: (CSV.CSV)zumbarMenu = x1:[[(GHC.Types.Char)]]\n-&gt; [{VV : [[(GHC.Types.Char)]] | ((len VV) == (len x1))}]\n-&gt; (CSV.CSV)Csv {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[  {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Item\"     , {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Price\"]\n74:                  [ {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Espresso\" , {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"2.25\" ]  \n75:                  , {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Macchiato\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"2.75\" ]\n76:                  , {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Cappucino\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"3.35\" ]\n77:                  , {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Americano\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"2.25\" ]\n78:                  ]\n</pre>","tags":["measures"]},{"location":"blogposts/2013-10-10-csv-tables.lhs/#the-errors","title":"The Errors","text":"<p>Our <code>CSV</code> type supports tables with an arbitrary number of <code>headers</code> and <code>rows</code> but of course, we'd like to ensure that each <code>row</code> has data for each header, that is, we don't end up with tables like this one</p> <pre>89: -- Eeks, we missed the header name!\n90: \n91: (CSV.CSV)csvBad1 = x1:[[(GHC.Types.Char)]]\n-&gt; [{VV : [[(GHC.Types.Char)]] | ((len VV) == (len x1))}]\n-&gt; (CSV.CSV)Csv {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[  {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Date\" {- ??? -} ] \n92:               [ {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt; 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Mon\", {VV : [(GHC.Types.Char)]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}\"1\"]\n93:               , {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt; 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Tue\", {VV : [(GHC.Types.Char)]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}\"2\"]\n94:               , {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt; 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Wed\", {VV : [(GHC.Types.Char)]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}\"3\"] \n95:               ]\n96: \n</pre> <p>or this one, </p> <pre>102: -- Blergh! we missed a column.\n103: \n104: (CSV.CSV)csvBad2 = x1:[[(GHC.Types.Char)]]\n-&gt; [{VV : [[(GHC.Types.Char)]] | ((len VV) == (len x1))}]\n-&gt; (CSV.CSV)Csv {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[  {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Name\" , {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Age\"  ] \n105:               [ {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Alice\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"32\"   ]\n106:               , {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Bob\"  {- ??? -}]\n107:               , {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Cris\" , {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"29\"   ] \n108:               ]\n</pre> <p>Alas, both the above are valid inhabitants of the Haskell <code>CSV</code> type, and  so, sneak past GHC.</p>","tags":["measures"]},{"location":"blogposts/2013-10-10-csv-tables.lhs/#the-invariant","title":"The Invariant","text":"<p>Thus, we want to refine the <code>CSV</code> type to specify that the number of elements in each row is exactly the same as the   number of headers.</p> <p>To do so, we merely write a refined data type definition:</p> <pre>123: {-@ data CSV = Csv { headers :: [String]\n124:                    , rows    :: [{v:[String] | (len v) = (len headers)}]\n125:                    }\n126:   @-}\n</pre> <p>Here <code>len</code> is a measure denoting the length of a list. Thus, <code>(len headers)</code> is the number of headers in the table, and the refinement on the <code>rows</code> field states that  each <code>row</code> is a list of <code>String</code>s,  with exactly the same number of elements as the number of <code>headers</code>.</p> <p>We can now have our arbitrary-arity tables, but LiquidHaskell will  make sure that we don't miss entries here or there.</p> <pre>138: -- All is well! \n139: \n140: (CSV.CSV)csvGood = x1:[[(GHC.Types.Char)]]\n-&gt; [{VV : [[(GHC.Types.Char)]] | ((len VV) == (len x1))}]\n-&gt; (CSV.CSV)Csv {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Id\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Name\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Days\"]\n141:               [ {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}\"1\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Jan\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"31\"]\n142:               , {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}\"2\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Feb\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"28\"]\n143:               , {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}\"3\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Mar\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"31\"]\n144:               , {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}\"4\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Apr\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"30\"] \n145:               ]\n</pre>","tags":["measures"]},{"location":"blogposts/2013-10-10-csv-tables.lhs/#bonus-points","title":"Bonus Points","text":"<p>How would you modify the specification to prevent table with degenerate entries like this one?</p> <pre>155: (CSV.CSV)deg = x1:[[(GHC.Types.Char)]]\n-&gt; [{VV : [[(GHC.Types.Char)]] | ((len VV) == (len x1))}]\n-&gt; (CSV.CSV)Csv {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[  {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Id\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Name\", {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Days\"]\n156:           [ {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}\"1\" , {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Jan\" , {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"31\"]\n157:           , {VV : [{VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}]&lt;\\_ VV -&gt; ((len VV) &gt;= 0)&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}[{VV : [(GHC.Types.Char)]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; false) &amp;&amp; ((len VV) &gt;= 0)}\"2\" , {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0)}\"Feb\" , {VV : [{VV : (GHC.Types.Char) | false}]&lt;\\_ VV -&gt; false&gt; | (((null VV)) &lt;=&gt; true) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}\"\"]\n158:           ]\n</pre>","tags":["measures"]},{"location":"blogposts/2013-11-23-telling_lies.lhs/","title":"LiquidHaskell Caught Telling Lies!","text":"<p>One crucial goal of a type system is to provide the guarantee,  memorably phrased by Milner as well-typed programs don't go wrong.  The whole point of LiquidHaskell (and related systems) is to provide the above guarantee for expanded notions of \"going wrong\".  All this time, we've claimed (and believed) that LiquidHaskell  provided such a guarantee.</p> <p>We were wrong. </p> <p>LiquidHaskell tells lies.</p> <pre>27: {-@ LIQUID \"--no-termination\" @-}\n28: \n29: module TellingLies where\n30: \n31: import Language.Haskell.Liquid.Prelude (liquidError)\n32: \n33: divide  :: Int -&gt; Int -&gt; Int\n34: foo     :: Int -&gt; Int\n35: explode :: Int\n</pre> <p>To catch LiquidHaskell red-handed, we require</p> <ol> <li>a notion of going wrong,</li> <li>a program that clearly goes wrong, and the smoking gun,</li> <li>a lie from LiquidHaskell that the program is safe.</li> </ol>","tags":["termination"]},{"location":"blogposts/2013-11-23-telling_lies.lhs/#the-going-wrong","title":"The Going Wrong","text":"<p>Lets keep things simple with an old fashioned <code>div</code>-ision operator. A division by zero would be, clearly going wrong.</p> <p>To alert LiquidHaskell to this possibility, we encode \"not going wrong\" with the precondition that the denominator be  non-zero.</p> <pre>54: {-@ divide :: n:Int -&gt; d:{v:Int | v /= 0} -&gt; Int @-}\n55: (GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (VV /= 0)} -&gt; (GHC.Types.Int)divide (GHC.Types.Int)n 0 = {VV : [(GHC.Types.Char)] | false} -&gt; {VV : (GHC.Types.Int) | false}liquidError {VV : [(GHC.Types.Char)] | ((len VV) &gt;= 0) &amp;&amp; ((sumLens VV) &gt;= 0)}\"no you didn't!\"\n56: divide n d = {VV : (GHC.Types.Int) | (VV == n)}n x1:(GHC.Types.Int)\n-&gt; x2:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (((x1 &gt;= 0) &amp;&amp; (x2 &gt;= 0)) =&gt; (VV &gt;= 0)) &amp;&amp; (((x1 &gt;= 0) &amp;&amp; (x2 &gt;= 1)) =&gt; (VV &lt;= x1)) &amp;&amp; (VV == (x1 / x2))}`div` {VV : (GHC.Types.Int) | (VV /= 0)}d\n</pre>","tags":["termination"]},{"location":"blogposts/2013-11-23-telling_lies.lhs/#the-program","title":"The Program","text":"<p>Now, consider the function <code>foo</code>.</p> <pre>65: {-@ foo :: n:Int -&gt; {v:Nat | v &lt; n} @-}\n66: n:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; n)}foo (GHC.Types.Int)n | {VV : (GHC.Types.Int) | (VV == n)}n x1:(GHC.Types.Int)\n-&gt; x2:(GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; (x1 &gt; x2))}&gt; {VV : (GHC.Types.Int) | (VV == (0  :  int))}0     = {VV : (GHC.Types.Int) | (VV == n)}n x1:(GHC.Types.Int)\n-&gt; x2:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV == (x1 - x2))}- {VV : (GHC.Types.Int) | (VV == (1  :  int))}1\n67:       | otherwise = n:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; n)}foo {VV : (GHC.Types.Int) | (VV == n)}n\n</pre> <p>Now, <code>foo</code> should only be called with strictly positive values.  In which case, the function returns a <code>Nat</code> that is strictly  smaller than the input.  The function diverges when called with <code>0</code> or negative inputs. </p> <p>Note that the signature of <code>foo</code> is slightly different, but  nevertheless, legitimate, as when the function returns an  output, the output is indeed a <code>Nat</code> that is strictly less than  the input parameter <code>n</code>. Hence, LiquidHaskell happily checks  that <code>foo</code> does indeed satisfy its given type.</p> <p>So far, nothing has gone wrong either in the program, or  with LiquidHaskell, but consider this innocent little  function:</p> <pre>86: (GHC.Types.Int)explode = let {VV : (GHC.Types.Int) | (VV == (0  :  int))}z = {VV : (GHC.Types.Int) | (VV == (0  :  int))}0\n87:           in  (x:{VV : (GHC.Types.Int) | (VV == 0) &amp;&amp; (VV == 1) &amp;&amp; (VV == TellingLies.explode) &amp;&amp; (VV == z) &amp;&amp; (VV &gt; 0) &amp;&amp; (VV &gt; TellingLies.explode) &amp;&amp; (VV &gt; z) &amp;&amp; (VV &lt; 0) &amp;&amp; (VV &lt; TellingLies.explode) &amp;&amp; (VV &lt; z)}\n-&gt; {VV : (GHC.Types.Int) | (VV == 0) &amp;&amp; (VV == 1) &amp;&amp; (VV == TellingLies.explode) &amp;&amp; (VV == x) &amp;&amp; (VV == z) &amp;&amp; (VV &gt; 0) &amp;&amp; (VV &gt; TellingLies.explode) &amp;&amp; (VV &gt; x) &amp;&amp; (VV &gt; z) &amp;&amp; (VV &lt; 0) &amp;&amp; (VV &lt; TellingLies.explode) &amp;&amp; (VV &lt; x) &amp;&amp; (VV &lt; z)}\\{VV : (GHC.Types.Int) | (VV == 0) &amp;&amp; (VV == 1) &amp;&amp; (VV == TellingLies.explode) &amp;&amp; (VV == z) &amp;&amp; (VV &gt; 0) &amp;&amp; (VV &gt; TellingLies.explode) &amp;&amp; (VV &gt; z) &amp;&amp; (VV &lt; 0) &amp;&amp; (VV &lt; TellingLies.explode) &amp;&amp; (VV &lt; z)}x -&gt; ({VV : (GHC.Types.Int) | (VV == (2013  :  int))}2013 (GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (VV /= 0)} -&gt; (GHC.Types.Int)`divide` {VV : (GHC.Types.Int) | (VV == z) &amp;&amp; (VV == (0  :  int))}z)) (n:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; n)}foo {VV : (GHC.Types.Int) | (VV == z) &amp;&amp; (VV == (0  :  int))}z)\n</pre> <p>Thanks to lazy evaluation, the call to <code>foo</code> is ignored, so evaluating <code>explode</code> leads to a crash! Ugh!</p>","tags":["termination"]},{"location":"blogposts/2013-11-23-telling_lies.lhs/#the-lie","title":"The Lie","text":"<p>However, LiquidHaskell produces a polyannish prognosis and  cheerfully declares the program safe. </p> <p>Huh?</p> <p>Well, LiquidHaskell deduces that</p> <ul> <li><code>z == 0</code>  from the binding,</li> <li><code>x : Nat</code> from the output type for <code>foo</code></li> <li><code>x &lt;  z</code>  from the output type for <code>foo</code></li> </ul> <p>Of course, no such <code>x</code> exists! Or, rather, the SMT solver reasons</p> <pre>108:     z == 0 &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; z  =&gt; z /= 0\n</pre> <p>as the hypotheses are inconsistent. In other words, LiquidHaskell  deduces that the call to <code>divide</code> happens in an impossible environment, i.e. is dead code, and hence, the program is safe.</p> <p>In our defence, the above, sunny prognosis is not totally misguided.  Indeed, if Haskell was like ML and had strict evaluation then  indeed the program would be safe in that we would not go wrong  i.e. would not crash with a divide-by-zero.  </p> <p>But of course, thats a pretty lame excuse, since Haskell doesn't have  strict semantics. So looks like LiquidHaskell (and hence, we)  have been caught red-handed.</p> <p>Well then, is there a way to prevent LiquidHaskell from telling lies? That is, can we get Milner's well-typed programs don't go wrong  guarantee under lazy evaluation? </p> <p>Thankfully, there is.</p>","tags":["termination"]},{"location":"blogposts/2013-12-02-getting-to-the-bottom.lhs/","title":"Getting To the Bottom","text":"<p>Previously, we caught LiquidHaskell telling a lie. Today, lets try to get to the bottom of this mendacity, in order to understand how we can ensure that it always tells the truth.</p> <pre>20: module GettingToTheBottom where\n</pre>","tags":["termination"]},{"location":"blogposts/2013-12-02-getting-to-the-bottom.lhs/#the-truth-lies-at-the-bottom","title":"The Truth Lies At the Bottom","text":"<p>To figure out how we might prevent falsehoods, lets try to understand  whats really going on. We need to go back to the beginning.</p> <p>Recall that the refinement type:</p> <pre>30: {v:Int | 0 &lt;= v}\n</pre> <p>is supposed to denote the set of <code>Int</code> values that are greater than <code>0</code>.</p> <p>Consider a function:</p> <pre>36: fib :: {n:Int | 0 &lt;= n} -&gt; {v:Int | 0 &lt;= v}\n37: fib n = e\n</pre> <p>Intuitively, the type signature states that when checking the body <code>e</code>  we can assume that <code>0 &lt;= n</code>. </p> <p>This is indeed the case with strict evaluation, as we are guaranteed  that <code>n</code> will be evaluated before <code>e</code>. Thus, either:</p> <ol> <li><code>n</code> diverges and so we don't care about <code>e</code> as we won't evaluate it, or,</li> <li><code>n</code> is a non-negative value.</li> </ol> <p>Thus, either way, <code>e</code> is only evaluated in a context where <code>0 &lt;= n</code>.</p> <p>But this is not the case with lazy evaluation, as we may  well start evaluating <code>e</code> without evaluating <code>n</code>. Indeed, we may finish evaluating <code>e</code> without evaluating <code>n</code>. </p> <p>Of course, if <code>n</code> is evaluated, it will yield a non-negative value,  but if it is not (or does not) evaluate to a value, we cannot assume  that the rest of the computation is dead (as with eager evaluation). </p> <p>That is, with lazy evaluation, the refinement type <code>{n:Int | 0 &lt;= n}</code> actually means:</p> <pre>60: (n = _|_) || (0 &lt;= n)\n</pre>","tags":["termination"]},{"location":"blogposts/2013-12-02-getting-to-the-bottom.lhs/#keeping-liquidhaskell-honest","title":"Keeping LiquidHaskell Honest","text":"<p>One approach to forcing LiquidHaskell to telling the truth is to force  it to always split cases and reason about <code>_|_</code>.</p> <p>Lets revisit <code>explode</code></p> <pre>70: explode = let z = 0\n71:           in  (\\x -&gt; 2013 `divide` z) (foo z)\n</pre> <p>The case splitting prevents the cheerful but bogus prognosis that <code>explode</code> above was safe, because the SMT solver cannot prove that at the call to <code>divide</code> </p> <pre>75:     z == 0 &amp;&amp; (x = _|_ || (x &gt;= 0 &amp;&amp; x &lt; z))  =&gt; z /= 0\n</pre> <p>But alas, this cure is worse than the disease.  It would end up lobotomizing LiquidHaskell making it unable to prove even trivial things like:</p> <p>_</p> <pre>82: {-@ trivial    :: x:Int -&gt; y:Int -&gt; {pf: () | x &lt; y} -&gt; Int @-}\n83: trivial x y pf = liquidAssert (x &lt; y) 10\n</pre> <p>as the corresponding SMT query</p> <pre>87:     (pf = _|_ || x &lt; y) =&gt; (x &lt; y)\n</pre> <p>is, thanks to the pesky <code>_|_</code>, not valid. </p>","tags":["termination"]},{"location":"blogposts/2013-12-02-getting-to-the-bottom.lhs/#terminating-the-bottom","title":"Terminating The Bottom","text":"<p>Thus, to make LiquidHaskell tell the truth while also not just pessimistically  rejecting perfectly good programs, we need a way to get rid of the <code>_|_</code>. That  is, we require a means of teaching LiquidHaskell to determine when a value is definitely not bottom. </p> <p>In other words, we need to teach LiquidHaskell how to prove that a computation  definitely terminates.</p>","tags":["termination"]},{"location":"blogposts/2013-12-09-checking-termination.lhs/","title":"Checking Termination","text":"<p>As explained in the last two posts, we need a termination checker to ensure that LiquidHaskell is not tricked by divergent, lazy computations into telling lies. Happily, it turns out that with very  little retrofitting, and a bit of jiu jitsu, we can use refinements  themselves to prove termination!</p> <p></p> <p>         How do you prove this fellow will stop falling?         </p> <pre>38: module Termination where\n39: \n40: import Prelude     hiding (sum)\n41: import Data.Vector hiding (sum)\n</pre> <p>Lets first see how LiquidHaskell proves termination on simple  recursive functions, and then later, we'll see how to look at  fancier cases.</p>","tags":["termination"]},{"location":"blogposts/2013-12-09-checking-termination.lhs/#looping-over-vectors","title":"Looping Over Vectors","text":"<p>Lets write a bunch of little functions that operate on 1-dimensional vectors</p> <pre>54: type Val = Int\n55: type Vec = Vector Val\n</pre> <p>Next, lets write a simple recursive function that loops over to add up the first <code>n</code> elements of a vector:</p> <pre>62: sum     :: Vec -&gt; Int -&gt; Val\n63: x1:(Data.Vector.Vector (GHC.Types.Int))\n-&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; (vlen x1))}\n-&gt; (GHC.Types.Int)sum (Data.Vector.Vector (GHC.Types.Int))a 0 = x1:(GHC.Prim.Int#) -&gt; {VV : (GHC.Types.Int) | (VV == (x1  :  int))}0\n64: sum a n = ({VV : (Data.Vector.Vector (GHC.Types.Int)) | (VV == a) &amp;&amp; ((vlen VV) &gt;= 0)}a x1:(Data.Vector.Vector (GHC.Types.Int))\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; (vlen x1)) &amp;&amp; (0 &lt;= VV)}\n-&gt; (GHC.Types.Int)! ({VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; (vlen a))}nx1:(GHC.Types.Int)\n-&gt; x2:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV == (x1 - x2))}-{VV : (GHC.Types.Int) | (VV == (1  :  int))}1)) x1:(GHC.Types.Int)\n-&gt; x2:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV == (x1 + x2))}+ x1:(Data.Vector.Vector (GHC.Types.Int))\n-&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; (vlen x1))}\n-&gt; (GHC.Types.Int)sum {VV : (Data.Vector.Vector (GHC.Types.Int)) | (VV == a) &amp;&amp; ((vlen VV) &gt;= 0)}a ({VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; (vlen a))}nx1:(GHC.Types.Int)\n-&gt; x2:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV == (x1 - x2))}-{VV : (GHC.Types.Int) | (VV == (1  :  int))}1)\n</pre>","tags":["termination"]},{"location":"blogposts/2013-12-09-checking-termination.lhs/#proving-termination-by-handwaving","title":"Proving Termination By Hand(waving)","text":"<p>Does <code>sum</code> terminate? </p> <p>First off, it is apparent that if we call <code>sum</code> with a negative <code>n</code> then it will not terminate.  Thus, we should only call <code>sum</code> with non-negative integers.</p> <p>Fine, lets assume <code>n</code> is non-negative. Why then does it terminate?</p> <p>Intuitively,</p> <ol> <li> <p>If <code>n</code> is <code>0</code> then it trivially returns with the value <code>0</code>.</p> </li> <li> <p>If <code>n</code> is non-zero, then we recurse but with a strictly smaller <code>n</code> ...</p> </li> <li> <p>... but ultimately hit <code>0</code> at which point it terminates.</p> </li> </ol> <p>Thus we can, somewhat more formally, prove termination by induction on <code>n</code>. </p> <p>Base Case <code>n == 0</code> The function clearly terminates for the base case input of <code>0</code>.</p> <p>Inductive Hypothesis Lets assume that <code>sum</code> terminates on all <code>0 &lt;= k &lt; n</code>.</p> <p>Inductive Step Prove that <code>sum n</code> only recursively invokes <code>sum</code> with values that satisfy the inductive hypothesis and hence, which terminate.</p> <p>This reasoning suffices to convince ourselves that <code>sum i</code> terminates for  every natural number <code>i</code>. That is, we have shown that <code>sum</code> terminates  because a well-founded metric (i.e., the natural number <code>i</code>) is decreasing  at each recursive call.</p>","tags":["termination"]},{"location":"blogposts/2013-12-09-checking-termination.lhs/#proving-termination-by-types","title":"Proving Termination By Types","text":"<p>We can teach LiquidHaskell to prove termination by applying the same reasoning  as above, by rephrasing it in terms of refinement types.</p> <p>First, we specify that the input is restricted to the set of <code>Nat</code>ural numbers</p> <pre>109: {-@ sum :: a:Vec -&gt; {v:Nat | v &lt; (vlen a)} -&gt; Val @-}\n</pre> <p>where recall that <code>Nat</code> is just the refinement type <code>{v:Int | v &gt;= 0}</code>.</p> <p>Second, we typecheck the body of <code>sum</code> under an environment that restricts <code>sum</code> to only be called on inputs less than <code>n</code>, i.e. using an environment:</p> <ul> <li><code>a   :: Vec</code></li> <li><code>n   :: Nat</code></li> <li><code>sum :: Vec -&gt; n':{v:Nat | v &lt; n} -&gt; Val</code></li> </ul> <p>This ensures that any (recursive) call in the body only calls <code>sum</code>  with inputs smaller than the current parameter <code>n</code>. Since its body  typechecks in this environment, i.e. <code>sum</code> is called with <code>n-1</code> which  is smaller than <code>n</code> and, in this case, a <code>Nat</code>, LiquidHaskell proves  that sum terminates for all <code>n</code>.</p> <p>For those keeping track at home, this is the technique of  sized types,  , expressed using refinements. Sized types themselves are an instance of  the classical method of proving termination via well founded metrics that  goes back, at least, to Turing.</p>","tags":["termination"]},{"location":"blogposts/2013-12-09-checking-termination.lhs/#choosing-the-correct-argument","title":"Choosing the Correct Argument","text":"<p>The example above is quite straightforward, and you might well wonder if this method works well for ``real-world\" programs. With a few generalizations and extensions, and by judiciously using the wealth of information captured in refinement types, the answer is an emphatic, yes!</p> <p>Lets see one extension today.</p> <p>We saw that liquidHaskell can happily check that some Natural number is decreasing at each iteration, but it uses a na\u00efve heuristic to choose which one -- for now, assume that it always chooses the first <code>Int</code> parameter.</p> <p>As you might imagine, this is quite simpleminded. </p> <p>Consider, a tail-recursive implementation of <code>sum</code>:</p> <pre>153: {-@ sum' :: a:Vec -&gt; Val -&gt; {v:Nat| v &lt; (vlen a)} -&gt; Val @-}\n154: sum' :: Vec -&gt; Val -&gt; Int -&gt; Val\n155: x1:(Data.Vector.Vector (GHC.Types.Int))\n-&gt; (GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; (vlen x1))}\n-&gt; (GHC.Types.Int)sum' (Data.Vector.Vector (GHC.Types.Int))a (GHC.Types.Int)acc 0 = {VV : (GHC.Types.Int) | (VV == acc)}acc x1:(GHC.Types.Int)\n-&gt; x2:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV == (x1 + x2))}+ {VV : (Data.Vector.Vector (GHC.Types.Int)) | (VV == a) &amp;&amp; ((vlen VV) &gt;= 0)}ax1:(Data.Vector.Vector (GHC.Types.Int))\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; (vlen x1)) &amp;&amp; (0 &lt;= VV)}\n-&gt; (GHC.Types.Int)!{VV : (GHC.Types.Int) | (VV == (0  :  int))}0 \n156: sum' a acc n = x1:(Data.Vector.Vector (GHC.Types.Int))\n-&gt; (GHC.Types.Int)\n-&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; (vlen x1))}\n-&gt; (GHC.Types.Int)sum' {VV : (Data.Vector.Vector (GHC.Types.Int)) | (VV == a) &amp;&amp; ((vlen VV) &gt;= 0)}a ({VV : (GHC.Types.Int) | (VV == acc)}acc x1:(GHC.Types.Int)\n-&gt; x2:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV == (x1 + x2))}+ {VV : (Data.Vector.Vector (GHC.Types.Int)) | (VV == a) &amp;&amp; ((vlen VV) &gt;= 0)}ax1:(Data.Vector.Vector (GHC.Types.Int))\n-&gt; {VV : (GHC.Types.Int) | (VV &lt; (vlen x1)) &amp;&amp; (0 &lt;= VV)}\n-&gt; (GHC.Types.Int)!{VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; (vlen a))}n) ({VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; (vlen a))}nx1:(GHC.Types.Int)\n-&gt; x2:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV == (x1 - x2))}-{VV : (GHC.Types.Int) | (VV == (1  :  int))}1)\n</pre> <p>Clearly, the proof fails as liquidHaskell wants to prove that the <code>acc</code>umulator  is a <code>Nat</code>ural number that decreases at each iteration, neither of which may be true.</p> <p>The remedy is easy. We can point liquidHaskell to the correct argument <code>n</code> using a <code>Decrease</code> annotation: </p> <pre>164: {-@ Decrease sum' 3 @-}\n</pre> <p>which directs liquidHaskell to verify that the third argument (i.e., <code>n</code>) is decreasing.  With this hint, liquidHaskell will happily verify that <code>sum'</code> is indeed a terminating function.</p> <p>Thats all for now, next time we'll see how the basic technique can be extended to a variety of real-world settings.</p>","tags":["termination"]},{"location":"blogposts/2013-12-14-gcd.lhs/","title":"Termination Requires Refinements","text":"<p>We've seen how, in the presence of lazy evaluation, refinements require termination. Next, we saw how  LiquidHaskell can be used to prove termination. </p> <p>Today, lets see how termination requires refinements. </p> <p>That is, a crucial feature of LiquidHaskell's termination prover is that it is  not syntactically driven, i.e. is not limited to say, structural recursion.  Instead, it uses the wealth of information captured by refinements that are at our disposal, in order to prove termination. </p> <p>This turns out to be crucial in practice. As a quick toy example -- motivated by a question by Elias --  lets see how, unlike purely syntax-directed (structural) approaches,  LiquidHaskell proves that recursive functions, such as Euclid's GCD  algorithm, terminates.</p> <p> </p>         With LiquidHaskell, Euclid wouldn't have had to wave his hands.         <pre>51: module GCD where\n52: \n53: import Prelude hiding (gcd, mod)\n54: \n55: mod :: Int -&gt; Int -&gt; Int\n56: gcd :: Int -&gt; Int -&gt; Int\n</pre> <p>The Euclidean algorithm is one of the oldest numerical algorithms  still in common use and calculates the the greatest common divisor (GCD) of two  natural numbers <code>a</code> and <code>b</code>.</p> <p>Assume that <code>a &gt; b</code> and consider the following implementation of <code>gcd</code></p> <pre>66: {-@ gcd :: a:Nat -&gt; b:{v:Nat | v &lt; a} -&gt; Int @-}\n67: x1:{VV : (GHC.Types.Int) | (VV &gt;= 0)}\n-&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; x1)}\n-&gt; (GHC.Types.Int)gcd {VV : (GHC.Types.Int) | (VV &gt;= 0)}a 0 = {VV : (GHC.Types.Int) | (VV == a) &amp;&amp; (VV &gt;= 0)}a\n68: gcd a b = x1:{VV : (GHC.Types.Int) | (VV &gt;= 0)}\n-&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; x1)}\n-&gt; (GHC.Types.Int)gcd {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; a)}b ({VV : (GHC.Types.Int) | (VV == a) &amp;&amp; (VV &gt;= 0)}a {VV : (GHC.Types.Int) | (VV &gt;= 0)}\n-&gt; x2:{VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (0 &lt; VV)}\n-&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; x2)}`mod` {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; a)}b)\n</pre> <p>From our previous post, to prove that <code>gcd</code> is terminating, it suffices to prove that the first argument decreases as each recursive call.</p> <p>By <code>gcd</code>'s type signature, <code>a &lt; b</code> holds at each iteration, thus liquidHaskell  will happily discharge the terminating condition.</p> <p>The only condition left to prove is that <code>gcd</code>'s second argument, ie., <code>a</code>mod<code>b</code> is less that <code>b</code>. </p> <p>This property follows from the behavior of the <code>mod</code> operator.</p> <p>So, to prove <code>gcd</code> terminating, liquidHaskell needs a refined signature for  <code>mod</code> that captures this behavior, i.e., that for any <code>a</code> and <code>b</code> the value  <code>mod a b</code> is less than <code>b</code>. Fortunately, we can stipulate this via a refined type:</p> <pre>88: {-@ mod :: a:Nat -&gt; b:{v:Nat| 0 &lt; v} -&gt; {v:Nat | v &lt; b} @-}\n89: {VV : (GHC.Types.Int) | (VV &gt;= 0)}\n-&gt; x2:{VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (0 &lt; VV)}\n-&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; x2)}mod {VV : (GHC.Types.Int) | (VV &gt;= 0)}a {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (0 &lt; VV)}b\n90:   | {VV : (GHC.Types.Int) | (VV == a) &amp;&amp; (VV &gt;= 0)}a x1:{VV : (GHC.Types.Int) | (VV &gt;= 0)}\n-&gt; x2:{VV : (GHC.Types.Int) | (VV &gt;= 0)}\n-&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; (x1 &lt; x2))}&lt; {VV : (GHC.Types.Int) | (VV == b) &amp;&amp; (VV &gt;= 0) &amp;&amp; (0 &lt; VV)}b = {VV : (GHC.Types.Int) | (VV == a) &amp;&amp; (VV &gt;= 0)}a\n91:   | otherwise = {VV : (GHC.Types.Int) | (VV &gt;= 0)}\n-&gt; x2:{VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (0 &lt; VV)}\n-&gt; {VV : (GHC.Types.Int) | (VV &gt;= 0) &amp;&amp; (VV &lt; x2)}mod ({VV : (GHC.Types.Int) | (VV == a) &amp;&amp; (VV &gt;= 0)}a x1:(GHC.Types.Int)\n-&gt; x2:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV == (x1 - x2))}- {VV : (GHC.Types.Int) | (VV == b) &amp;&amp; (VV &gt;= 0) &amp;&amp; (0 &lt; VV)}b) {VV : (GHC.Types.Int) | (VV == b) &amp;&amp; (VV &gt;= 0) &amp;&amp; (0 &lt; VV)}b\n</pre> <p>Euclid's original version of <code>gcd</code> is different</p> <pre>95: gcd' :: Int -&gt; Int -&gt; Int\n96: gcd' a b | a == b = a\n97:          | a &gt;  b = gcd' (a - b) b \n98:          | a &lt;  b = gcd' a (b - a) \n</pre> <p>Though this version is simpler, turns out that LiquidHaskell needs  a more sophisticated mechanism, called lexicographic ordering, to  prove it terminates. Stay tuned!</p>","tags":["termination"]},{"location":"blogposts/2014-02-11-the-advantage-of-measures.lhs/","title":"The Advantage of Measures","text":"<p>Yesterday someone asked on Reddit how one might define GHC's OrdList  in a way that statically enforces its three key invariants. The accepted solution required rewriting <code>OrdList</code> as a <code>GADT</code> indexed by a proof of emptiness (which is essentially created by a run-time check), and used the new Closed Type Families extension in GHC 7.8 to define a type-level  join of the Emptiness index.</p> <p>Today, let's see a somewhat more direct way of tackling this problem in  LiquidHaskell, in which we need not change a single line of code  (well.. maybe one), and need not perform any dynamic checks. </p> <pre>27: module OrdList(\n28:     OrdList, \n29:         nilOL, isNilOL, unitOL, appOL, consOL, snocOL, concatOL,\n30:         mapOL, fromOL, toOL, foldrOL, foldlOL, foldr', concatOL'\n31: ) where\n32: \n33: infixl 5  `appOL`\n34: infixl 5  `snocOL`\n35: infixr 5  `consOL`\n36: -- UGH parsing issues...\n37: {-@\n38: data OrdList [olen] a = None\n39:                       | One  (x  :: a)\n40:                       | Many (xs :: ListNE a)\n41:                       | Cons (x  :: a)           (xs :: OrdList a)\n42:                       | Snoc (xs :: OrdList a)   (x  :: a)\n43:                       | Two  (x  :: OrdListNE a) (y  :: OrdListNE a)\n44: @-}\n</pre>","tags":["basic","measures"]},{"location":"blogposts/2014-02-11-the-advantage-of-measures.lhs/#the-ordlist-type","title":"The OrdList Type","text":"<p>The <code>OrdList</code> type is defined as follows:</p> <pre>54: data OrdList a\n55:   = None\n56:   | One a\n57:   | Many [a]        -- Invariant: non-empty\n58:   | Cons a (OrdList a)\n59:   | Snoc (OrdList a) a\n60:   | Two (OrdList a) -- Invariant: non-empty\n61:         (OrdList a) -- Invariant: non-empty\n</pre> <p>As indicated by the comments the key invariants are that:</p> <ul> <li><code>Many</code> should take a non-empty list,</li> <li><code>Two</code> takes two non-empty <code>OrdList</code>s. </li> </ul>","tags":["basic","measures"]},{"location":"blogposts/2014-02-11-the-advantage-of-measures.lhs/#what-is-a-non-empty-ordlist","title":"What is a Non-Empty OrdList?","text":"<p>To proceed, we must tell LiquidHaskell what non-empty means. We do this with a measure that describes the number of elements in a structure. When this number is strictly positive, the structure is non-empty.</p> <p>We've previously seen how to measure the size of a list.</p> <pre>77: measure len :: [a] -&gt; Int\n78: len ([])   = 0\n79: len (x:xs) = 1 + (len xs)\n</pre> <p>We can use the same technique to measure the size of an <code>OrdList</code>.</p> <pre>85: {-@ measure olen :: OrdList a -&gt; Int\n86:     olen (None)      = 0\n87:     olen (One x)     = 1\n88:     olen (Many xs)   = (len xs)\n89:     olen (Cons x xs) = 1 + (olen xs)\n90:     olen (Snoc xs x) = 1 + (olen xs)\n91:     olen (Two x y)   = (olen x) + (olen y)\n92:   @-}\n93: \n94: {-@ invariant {v:OrdList a | (olen v) &gt;= 0} @-}\n</pre> <p>Now, we can use the measures to define aliases for non-empty lists and <code>OrdList</code>s.</p> <pre>100: {-@ type ListNE    a = {v:[a]       | (len v)  &gt; 0} @-}\n101: {-@ type OrdListNE a = {v:OrdList a | (olen v) &gt; 0} @-}\n</pre>","tags":["basic","measures"]},{"location":"blogposts/2014-02-11-the-advantage-of-measures.lhs/#capturing-the-invariants-in-a-refined-type","title":"Capturing the Invariants In a Refined Type","text":"<p>Let's return to the original type, and refine it with the above non-empty variants to specify the invariants as  part of the data declaration</p> <pre>110: {-@ data OrdList [olen] a\n111:       = None\n112:       | One  (x  :: a)\n113:       | Many (xs :: ListNE a)\n114:       | Cons (x  :: a)           (xs :: OrdList a)\n115:       | Snoc (xs :: OrdList a)   (x  :: a)\n116:       | Two  (x  :: OrdListNE a) (y  :: OrdListNE a)\n117:   @-}\n</pre> <p>Notice immediately that LiquidHaskell can use the refined definition to warn us  about malformed <code>OrdList</code> values.</p> <pre>124: (OrdList.OrdList {VV : (GHC.Integer.Type.Integer) | (VV &gt; 0)})ok     = x1:{x6 : [{x9 : (GHC.Integer.Type.Integer) | (x9 &gt; 0)}] | ((len x6) &gt; 0)}\n-&gt; {x2 : (OrdList.OrdList {x9 : (GHC.Integer.Type.Integer) | (x9 &gt; 0)}) | ((olen x2) == (len x1))}Many {x5 : [{x11 : (GHC.Integer.Type.Integer) | (x11 &gt; 0)}]&lt;\\x9 VV -&gt; (x8 &gt; 0) &amp;&amp; (x8 &gt; x9)&gt; | (((null x5)) &lt;=&gt; false) &amp;&amp; ((len x5) &gt;= 0) &amp;&amp; ((olens x5) &gt;= 0) &amp;&amp; ((sumLens x5) &gt;= 0)}[1,2,3]\n125: forall a.\n{VV : (OrdList.OrdList {VV : a | false}) | ((olen VV) == 0)}bad    = x1:{x4 : [{VV : a | false}] | ((len x4) &gt; 0)}\n-&gt; {x2 : (OrdList.OrdList {VV : a | false}) | ((olen x2) == (len x1))}Many {x8 : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | (((null x8)) &lt;=&gt; true) &amp;&amp; ((len x8) == 0) &amp;&amp; ((olens x8) == 0) &amp;&amp; ((sumLens x8) == 0) &amp;&amp; ((len x8) &gt;= 0) &amp;&amp; ((olens x8) &gt;= 0) &amp;&amp; ((sumLens x8) &gt;= 0)}[]\n126: {VV : (OrdList.OrdList {VV : (GHC.Integer.Type.Integer) | (VV &gt; 0)}) | ((olen VV) == (olen OrdList.ok))}badder = x1:{x10 : (OrdList.OrdList {x12 : (GHC.Integer.Type.Integer) | (x12 &gt; 0)}) | ((olen x10) &gt; 0)}\n-&gt; x2:{x6 : (OrdList.OrdList {x12 : (GHC.Integer.Type.Integer) | (x12 &gt; 0)}) | ((olen x6) &gt; 0)}\n-&gt; {x2 : (OrdList.OrdList {x12 : (GHC.Integer.Type.Integer) | (x12 &gt; 0)}) | ((olen x2) == ((olen x1) + (olen x2)))}Two {x3 : (OrdList.OrdList {x4 : (GHC.Integer.Type.Integer) | false}) | ((olen x3) == 0) &amp;&amp; ((olen x3) &gt;= 0)}None {x3 : (OrdList.OrdList {x5 : (GHC.Integer.Type.Integer) | (x5 &gt; 0)}) | (x3 == OrdList.ok) &amp;&amp; ((olen x3) &gt;= 0)}ok\n</pre> <p>All of the above are accepted by GHC, but only the first one is actually a valid <code>OrdList</code>. Happily, LiquidHaskell will reject the latter two, as they violate the invariants.</p>","tags":["basic","measures"]},{"location":"blogposts/2014-02-11-the-advantage-of-measures.lhs/#basic-functions","title":"Basic Functions","text":"<p>Now let's look at some of the functions!</p> <p>First, we'll define a handy alias for <code>OrdList</code>s of a given size:</p> <pre>142: {-@ type OrdListN a N = {v:OrdList a | (olen v) = N} @-}\n</pre> <p>Now, the <code>nilOL</code> constructor returns an empty <code>OrdList</code>:</p> <pre>148: {-@ nilOL :: OrdListN a {0} @-}\n149: forall a. {v : (OrdList.OrdList a) | ((olen v) == 0)}nilOL = forall a. {x2 : (OrdList.OrdList a) | ((olen x2) == 0)}None\n</pre> <p>the <code>unitOL</code> constructor returns an <code>OrdList</code> with one element:</p> <pre>155: {-@ unitOL :: a -&gt; OrdListN a {1} @-}\n156: forall a. a -&gt; {v : (OrdList.OrdList a) | ((olen v) == 1)}unitOL aas = {VV : a | (VV == as)}\n-&gt; {x2 : (OrdList.OrdList {VV : a | (VV == as)}) | ((olen x2) == 1)}One {VV : a | (VV == as)}as\n</pre> <p>and <code>snocOL</code> and <code>consOL</code> return outputs with precisely one more element:</p> <pre>162: {-@ snocOL :: xs:OrdList a -&gt; a -&gt; OrdListN a {1 + (olen xs)} @-}\n163: forall a.\nxs:(OrdList.OrdList a)\n-&gt; a -&gt; {v : (OrdList.OrdList a) | ((olen v) == (1 + (olen xs)))}snocOL (OrdList.OrdList a)as ab = x1:(OrdList.OrdList a)\n-&gt; a -&gt; {x2 : (OrdList.OrdList a) | ((olen x2) == (1 + (olen x1)))}Snoc {x3 : (OrdList.OrdList a) | (x3 == as) &amp;&amp; ((olen x3) &gt;= 0)}as {VV : a | (VV == b)}b\n164: \n165: {-@ consOL :: a -&gt; xs:OrdList a -&gt; OrdListN a {1 + (olen xs)} @-}\n166: forall a.\na\n-&gt; xs:(OrdList.OrdList a)\n-&gt; {v : (OrdList.OrdList a) | ((olen v) == (1 + (olen xs)))}consOL aa (OrdList.OrdList a)bs = a\n-&gt; x2:(OrdList.OrdList a)\n-&gt; {x2 : (OrdList.OrdList a) | ((olen x2) == (1 + (olen x2)))}Cons {VV : a | (VV == a)}a {x3 : (OrdList.OrdList a) | (x3 == bs) &amp;&amp; ((olen x3) &gt;= 0)}bs\n</pre> <p>Note: The <code>OrdListN a {e}</code> syntax just lets us use LiquidHaskell  expressions <code>e</code> as a parameter to the type alias <code>OrdListN</code>.</p> <pre>175: {-@ isNilOL :: xs:OrdList a -&gt; {v:Bool | ((Prop v) &lt;=&gt; ((olen xs) = 0))} @-}\n176: forall a.\nxs:(OrdList.OrdList a)\n-&gt; {v : (GHC.Types.Bool) | (((Prop v)) &lt;=&gt; ((olen xs) == 0))}isNilOL None = {x3 : (GHC.Types.Bool) | ((Prop x3)) &amp;&amp; (x3 == GHC.Types.True)}True\n177: isNilOL _    = {x3 : (GHC.Types.Bool) | (not (((Prop x3)))) &amp;&amp; (x3 == GHC.Types.False)}False\n</pre>","tags":["basic","measures"]},{"location":"blogposts/2014-02-11-the-advantage-of-measures.lhs/#appending-ordlists","title":"Appending <code>OrdList</code>s","text":"<p>The above functions really aren't terribly interesting, however, since their  types fall right out of the definition of <code>olen</code>. </p> <p>So how about something that takes a little thinking?</p> <pre>190: {-@ appOL :: xs:OrdList a -&gt; ys:OrdList a\n191:           -&gt; OrdListN a {(olen xs) + (olen ys)}\n192:   @-}\n193: None  forall a.\nxs:(OrdList.OrdList a)\n-&gt; ys:(OrdList.OrdList a)\n-&gt; {v : (OrdList.OrdList a) | ((olen v) == ((olen xs) + (olen ys)))}`appOL` (OrdList.OrdList a)b     = {x3 : (OrdList.OrdList a) | (x3 == b) &amp;&amp; ((olen x3) &gt;= 0)}b\n194: a     `appOL` None  = {x2 : (OrdList.OrdList a) | ((olen x2) &gt;= 0)}a\n195: One a `appOL` b     = {VV : a | (VV == a) &amp;&amp; (VV &gt; a) &amp;&amp; (VV &lt; a)}\n-&gt; x2:(OrdList.OrdList {VV : a | (VV == a) &amp;&amp; (VV &gt; a) &amp;&amp; (VV &lt; a)})\n-&gt; {x2 : (OrdList.OrdList {VV : a | (VV == a) &amp;&amp; (VV &gt; a) &amp;&amp; (VV &lt; a)}) | ((olen x2) == (1 + (olen x2)))}Cons {VV : a | (VV == a)}a {x3 : (OrdList.OrdList a) | (x3 == b) &amp;&amp; ((olen x3) &gt;= 0)}b\n196: a     `appOL` One b = x1:(OrdList.OrdList {VV : a | (VV == b) &amp;&amp; (VV &gt; b) &amp;&amp; (VV &lt; b)})\n-&gt; {VV : a | (VV == b) &amp;&amp; (VV &gt; b) &amp;&amp; (VV &lt; b)}\n-&gt; {x2 : (OrdList.OrdList {VV : a | (VV == b) &amp;&amp; (VV &gt; b) &amp;&amp; (VV &lt; b)}) | ((olen x2) == (1 + (olen x1)))}Snoc {x2 : (OrdList.OrdList a) | ((olen x2) &gt;= 0)}a {VV : a | (VV == b)}b\n197: a     `appOL` b     = x1:{x6 : (OrdList.OrdList a) | ((olen x6) &gt; 0)}\n-&gt; x2:{x4 : (OrdList.OrdList a) | ((olen x4) &gt; 0)}\n-&gt; {x2 : (OrdList.OrdList a) | ((olen x2) == ((olen x1) + (olen x2)))}Two {x2 : (OrdList.OrdList a) | ((olen x2) &gt;= 0)}a {x3 : (OrdList.OrdList a) | (x3 == b) &amp;&amp; ((olen x3) &gt;= 0)}b\n</pre> <p><code>appOL</code> takes two <code>OrdList</code>s and returns a list whose length is the sum of  the two input lists. The most important thing to notice here is that we haven't  had to insert any extra checks in <code>appOL</code>, unlike the GADT solution. </p> <p>LiquidHaskell uses the definition of <code>olen</code> to infer that in the last case of  <code>appOL</code>, <code>a</code> and <code>b</code> must be non-empty, so they are valid arguments to <code>Two</code>.</p> <p>We can prove other things about <code>OrdList</code>s as well, like the fact that converting an <code>OrdList</code> to a Haskell list preserves length</p> <pre>211: {-@ toOL :: xs:[a] -&gt; OrdListN a {(len xs)} @-}\n212: forall a.\nxs:[a] -&gt; {v : (OrdList.OrdList a) | ((olen v) == (len xs))}toOL [] = forall a. {x2 : (OrdList.OrdList a) | ((olen x2) == 0)}None\n213: toOL xs = x1:{x4 : [a] | ((len x4) &gt; 0)}\n-&gt; {x2 : (OrdList.OrdList a) | ((olen x2) == (len x1))}Many {x4 : [a] | ((len x4) &gt;= 0) &amp;&amp; ((olens x4) &gt;= 0) &amp;&amp; ((sumLens x4) &gt;= 0)}xs\n</pre> <p>as does mapping over an <code>OrdList</code></p> <pre>219: {-@ mapOL :: (a -&gt; b) -&gt; xs:OrdList a -&gt; OrdListN b {(olen xs)} @-}\n220: forall a b.\n(b -&gt; a)\n-&gt; x3:(OrdList.OrdList b)\n-&gt; {VV : (OrdList.OrdList a) | ((olen VV) == (olen x3))}mapOL _ None        = forall a. {x2 : (OrdList.OrdList a) | ((olen x2) == 0)}None\n221: mapOL f (One x)     = a -&gt; {x2 : (OrdList.OrdList a) | ((olen x2) == 1)}One (a -&gt; bf {VV : a | (VV == x)}x)\n222: mapOL f (Cons x xs) = a\n-&gt; x2:(OrdList.OrdList a)\n-&gt; {x2 : (OrdList.OrdList a) | ((olen x2) == (1 + (olen x2)))}Cons (a -&gt; bf {VV : a | (VV == x)}x) (forall a b.\n(b -&gt; a)\n-&gt; x3:(OrdList.OrdList b)\n-&gt; {VV : (OrdList.OrdList a) | ((olen VV) == (olen x3))}mapOL a -&gt; bf {x3 : (OrdList.OrdList a) | (x3 == xs) &amp;&amp; ((olen x3) &gt;= 0)}xs)\n223: mapOL f (Snoc xs x) = x1:(OrdList.OrdList a)\n-&gt; a -&gt; {x2 : (OrdList.OrdList a) | ((olen x2) == (1 + (olen x1)))}Snoc (forall a b.\n(b -&gt; a)\n-&gt; x3:(OrdList.OrdList b)\n-&gt; {VV : (OrdList.OrdList a) | ((olen VV) == (olen x3))}mapOL a -&gt; bf {x3 : (OrdList.OrdList a) | (x3 == xs) &amp;&amp; ((olen x3) &gt;= 0)}xs) (a -&gt; bf {VV : a | (VV == x)}x)\n224: mapOL f (Two x y)   = x1:{x6 : (OrdList.OrdList a) | ((olen x6) &gt; 0)}\n-&gt; x2:{x4 : (OrdList.OrdList a) | ((olen x4) &gt; 0)}\n-&gt; {x2 : (OrdList.OrdList a) | ((olen x2) == ((olen x1) + (olen x2)))}Two (forall a b.\n(b -&gt; a)\n-&gt; x3:(OrdList.OrdList b)\n-&gt; {VV : (OrdList.OrdList a) | ((olen VV) == (olen x3))}mapOL a -&gt; bf {x4 : (OrdList.OrdList a) | (x4 == x) &amp;&amp; ((olen x4) &gt; 0) &amp;&amp; ((olen x4) &gt;= 0)}x) (forall a b.\n(b -&gt; a)\n-&gt; x3:(OrdList.OrdList b)\n-&gt; {VV : (OrdList.OrdList a) | ((olen VV) == (olen x3))}mapOL a -&gt; bf {x4 : (OrdList.OrdList a) | (x4 == y) &amp;&amp; ((olen x4) &gt; 0) &amp;&amp; ((olen x4) &gt;= 0)}y)\n225: mapOL f (Many xs)   = x1:{x4 : [a] | ((len x4) &gt; 0)}\n-&gt; {x2 : (OrdList.OrdList a) | ((olen x2) == (len x1))}Many ((a -&gt; b) -&gt; x3:[a] -&gt; {x2 : [b] | ((len x2) == (len x3))}map a -&gt; bf {x6 : [a] | (x6 == xs) &amp;&amp; ((len x6) &gt; 0) &amp;&amp; ((len x6) &gt;= 0) &amp;&amp; ((olens x6) &gt;= 0) &amp;&amp; ((sumLens x6) &gt;= 0)}xs)\n</pre> <p>as does converting a Haskell list to an <code>OrdList</code>.</p> <pre>231: {-@ type ListN a N = {v:[a] | (len v) = N} @-}\n232: \n233: {-@ fromOL :: xs:OrdList a -&gt; ListN a {(olen xs)} @-}\n234: forall a.\nxs:(OrdList.OrdList a) -&gt; {v : [a] | ((len v) == (olen xs))}fromOL (OrdList.OrdList a)a = x1:(OrdList.OrdList a)\n-&gt; x2:{x4 : [a] | ((len x4) == 0)}\n-&gt; {x2 : [a] | ((len x2) == ((olen x1) + (len x2)))}go {x3 : (OrdList.OrdList a) | (x3 == a) &amp;&amp; ((olen x3) &gt;= 0)}a {x8 : [{VV : a | false}]&lt;\\_ VV -&gt; false&gt; | (((null x8)) &lt;=&gt; true) &amp;&amp; ((len x8) == 0) &amp;&amp; ((olens x8) == 0) &amp;&amp; ((sumLens x8) == 0) &amp;&amp; ((len x8) &gt;= 0) &amp;&amp; ((olens x8) &gt;= 0) &amp;&amp; ((sumLens x8) &gt;= 0)}[]\n235:   where\n236:     {-@ go :: xs:_ -&gt; ys:_\n237:            -&gt; {v:_ | (len v) = (olen xs) + (len ys)}\n238:       @-}\n239:     x1:(OrdList.OrdList a)\n-&gt; x2:{VV : [a] | ((len VV) &gt;= 0)}\n-&gt; {v : [a] | ((len v) == ((olen x1) + (len x2)))}go None       {VV : [a] | ((len VV) &gt;= 0)}acc = {x5 : [a] | (x5 == acc) &amp;&amp; ((len x5) &gt;= 0) &amp;&amp; ((olens x5) &gt;= 0) &amp;&amp; ((sumLens x5) &gt;= 0)}acc\n240:     go (One a)    acc = {VV : a | (VV == a)}a forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx1:a\n-&gt; x2:[{VV : a&lt;p x1&gt; | true}]&lt;p&gt;\n-&gt; {x5 : [a]&lt;p&gt; | (((null x5)) &lt;=&gt; false) &amp;&amp; ((len x5) == (1 + (len x2))) &amp;&amp; ((olens x5) == ((olen x1) + (olens x2))) &amp;&amp; ((sumLens x5) == ((len x1) + (sumLens x2)))}: {x5 : [a] | (x5 == acc) &amp;&amp; ((len x5) &gt;= 0) &amp;&amp; ((olens x5) &gt;= 0) &amp;&amp; ((sumLens x5) &gt;= 0)}acc\n241:     go (Cons a b) acc = {VV : a | (VV == a)}a forall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx1:a\n-&gt; x2:[{VV : a&lt;p x1&gt; | true}]&lt;p&gt;\n-&gt; {x5 : [a]&lt;p&gt; | (((null x5)) &lt;=&gt; false) &amp;&amp; ((len x5) == (1 + (len x2))) &amp;&amp; ((olens x5) == ((olen x1) + (olens x2))) &amp;&amp; ((sumLens x5) == ((len x1) + (sumLens x2)))}: x1:(OrdList.OrdList a)\n-&gt; x2:{VV : [a] | ((len VV) &gt;= 0)}\n-&gt; {v : [a] | ((len v) == ((olen x1) + (len x2)))}go {x3 : (OrdList.OrdList a) | (x3 == b) &amp;&amp; ((olen x3) &gt;= 0)}b {x5 : [a] | (x5 == acc) &amp;&amp; ((len x5) &gt;= 0) &amp;&amp; ((olens x5) &gt;= 0) &amp;&amp; ((sumLens x5) &gt;= 0)}acc\n242:     go (Snoc a b) acc = x1:(OrdList.OrdList a)\n-&gt; x2:{VV : [a] | ((len VV) &gt;= 0)}\n-&gt; {v : [a] | ((len v) == ((olen x1) + (len x2)))}go {x3 : (OrdList.OrdList a) | (x3 == a) &amp;&amp; ((olen x3) &gt;= 0)}a ({VV : a | (VV == b)}bforall &lt;p :: a-&gt; a-&gt; Bool&gt;.\nx1:a\n-&gt; x2:[{VV : a&lt;p x1&gt; | true}]&lt;p&gt;\n-&gt; {x5 : [a]&lt;p&gt; | (((null x5)) &lt;=&gt; false) &amp;&amp; ((len x5) == (1 + (len x2))) &amp;&amp; ((olens x5) == ((olen x1) + (olens x2))) &amp;&amp; ((sumLens x5) == ((len x1) + (sumLens x2)))}:{x5 : [a] | (x5 == acc) &amp;&amp; ((len x5) &gt;= 0) &amp;&amp; ((olens x5) &gt;= 0) &amp;&amp; ((sumLens x5) &gt;= 0)}acc)\n243:     go (Two a b)  acc = x1:(OrdList.OrdList a)\n-&gt; x2:{VV : [a] | ((len VV) &gt;= 0)}\n-&gt; {v : [a] | ((len v) == ((olen x1) + (len x2)))}go {x4 : (OrdList.OrdList a) | (x4 == a) &amp;&amp; ((olen x4) &gt; 0) &amp;&amp; ((olen x4) &gt;= 0)}a (x1:(OrdList.OrdList a)\n-&gt; x2:{VV : [a] | ((len VV) &gt;= 0)}\n-&gt; {v : [a] | ((len v) == ((olen x1) + (len x2)))}go {x4 : (OrdList.OrdList a) | (x4 == b) &amp;&amp; ((olen x4) &gt; 0) &amp;&amp; ((olen x4) &gt;= 0)}b {x5 : [a] | (x5 == acc) &amp;&amp; ((len x5) &gt;= 0) &amp;&amp; ((olens x5) &gt;= 0) &amp;&amp; ((sumLens x5) &gt;= 0)}acc)\n244:     go (Many xs)  acc = {x6 : [a] | (x6 == xs) &amp;&amp; ((len x6) &gt; 0) &amp;&amp; ((len x6) &gt;= 0) &amp;&amp; ((olens x6) &gt;= 0) &amp;&amp; ((sumLens x6) &gt;= 0)}xs x1:[a]\n-&gt; x2:[a] -&gt; {x2 : [a] | ((len x2) == ((len x1) + (len x2)))}++ {x5 : [a] | (x5 == acc) &amp;&amp; ((len x5) &gt;= 0) &amp;&amp; ((olens x5) &gt;= 0) &amp;&amp; ((sumLens x5) &gt;= 0)}acc\n</pre>  though for this last one we actually need to provide an explicit qualifier, which we haven't really seen so far. Can anyone guess why?   <pre>252: {-@ qualif Go(v:List a, xs:OrdList a, ys:List a):\n253:       (len v) = (olen xs) + (len ys)\n254:   @-}\n</pre>  The answer is that the return type of `go` must refer to the length of the `OrdList` that it's folding over *as well as* the length of the accumulator `acc`! We haven't written a refinement like that in any of our type signatures in this module, so LiquidHaskell doesn't know to guess that type.  <p>There's nothing super interesting to say about the <code>foldOL</code>s but I'll include them here for completeness' sake.</p> <pre>268: foldrOL :: (a-&gt;b-&gt;b) -&gt; b -&gt; OrdList a -&gt; b\n269: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; (OrdList.OrdList a) -&gt; bfoldrOL _ az None        = {VV : a | (VV == z)}z\n270: foldrOL k z (One x)     = a -&gt; b -&gt; bk {VV : a | (VV == x)}x {VV : a | (VV == z)}z\n271: foldrOL k z (Cons x xs) = a -&gt; b -&gt; bk {VV : a | (VV == x)}x (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; (OrdList.OrdList a) -&gt; bfoldrOL a -&gt; b -&gt; bk {VV : a | (VV == z)}z {x3 : (OrdList.OrdList a) | (x3 == xs) &amp;&amp; ((olen x3) &gt;= 0)}xs)\n272: foldrOL k z (Snoc xs x) = forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; (OrdList.OrdList a) -&gt; bfoldrOL a -&gt; b -&gt; bk (a -&gt; b -&gt; bk {VV : a | (VV == x)}x {VV : a | (VV == z)}z) {x3 : (OrdList.OrdList a) | (x3 == xs) &amp;&amp; ((olen x3) &gt;= 0)}xs\n273: foldrOL k z (Two b1 b2) = forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; (OrdList.OrdList a) -&gt; bfoldrOL a -&gt; b -&gt; bk (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; (OrdList.OrdList a) -&gt; bfoldrOL a -&gt; b -&gt; bk {VV : a | (VV == z)}z {x4 : (OrdList.OrdList a) | (x4 == b2) &amp;&amp; ((olen x4) &gt; 0) &amp;&amp; ((olen x4) &gt;= 0)}b2) {x4 : (OrdList.OrdList a) | (x4 == b1) &amp;&amp; ((olen x4) &gt; 0) &amp;&amp; ((olen x4) &gt;= 0)}b1\n274: foldrOL k z (Many xs)   = (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; bfoldr a -&gt; b -&gt; bk {VV : a | (VV == z)}z {x6 : [a] | (x6 == xs) &amp;&amp; ((len x6) &gt; 0) &amp;&amp; ((len x6) &gt;= 0) &amp;&amp; ((olens x6) &gt;= 0) &amp;&amp; ((sumLens x6) &gt;= 0)}xs\n275: \n276: foldlOL :: (b-&gt;a-&gt;b) -&gt; b -&gt; OrdList a -&gt; b\n277: forall a b. (a -&gt; b -&gt; a) -&gt; a -&gt; (OrdList.OrdList b) -&gt; afoldlOL _ az None        = {VV : a | (VV == z)}z\n278: foldlOL k z (One x)     = a -&gt; b -&gt; ak {VV : a | (VV == z)}z {VV : a | (VV == x)}x\n279: foldlOL k z (Cons x xs) = forall a b. (a -&gt; b -&gt; a) -&gt; a -&gt; (OrdList.OrdList b) -&gt; afoldlOL a -&gt; b -&gt; ak (a -&gt; b -&gt; ak {VV : a | (VV == z)}z {VV : a | (VV == x)}x) {x3 : (OrdList.OrdList a) | (x3 == xs) &amp;&amp; ((olen x3) &gt;= 0)}xs\n280: foldlOL k z (Snoc xs x) = a -&gt; b -&gt; ak (forall a b. (a -&gt; b -&gt; a) -&gt; a -&gt; (OrdList.OrdList b) -&gt; afoldlOL a -&gt; b -&gt; ak {VV : a | (VV == z)}z {x3 : (OrdList.OrdList a) | (x3 == xs) &amp;&amp; ((olen x3) &gt;= 0)}xs) {VV : a | (VV == x)}x\n281: foldlOL k z (Two b1 b2) = forall a b. (a -&gt; b -&gt; a) -&gt; a -&gt; (OrdList.OrdList b) -&gt; afoldlOL a -&gt; b -&gt; ak (forall a b. (a -&gt; b -&gt; a) -&gt; a -&gt; (OrdList.OrdList b) -&gt; afoldlOL a -&gt; b -&gt; ak {VV : a | (VV == z)}z {x4 : (OrdList.OrdList a) | (x4 == b1) &amp;&amp; ((olen x4) &gt; 0) &amp;&amp; ((olen x4) &gt;= 0)}b1) {x4 : (OrdList.OrdList a) | (x4 == b2) &amp;&amp; ((olen x4) &gt; 0) &amp;&amp; ((olen x4) &gt;= 0)}b2\n282: foldlOL k z (Many xs)   = (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; afoldl a -&gt; b -&gt; ak {VV : a | (VV == z)}z {x6 : [a] | (x6 == xs) &amp;&amp; ((len x6) &gt; 0) &amp;&amp; ((len x6) &gt;= 0) &amp;&amp; ((olens x6) &gt;= 0) &amp;&amp; ((sumLens x6) &gt;= 0)}xs\n</pre>","tags":["basic","measures"]},{"location":"blogposts/2014-02-11-the-advantage-of-measures.lhs/#concatenatation-nested-measures","title":"Concatenatation: Nested Measures","text":"<p>Now, the astute readers will have probably noticed that I'm missing  one function, <code>concatOL</code>, which glues a list of <code>OrdList</code>s into a  single long <code>OrdList</code>.</p> <p>With LiquidHaskell we can give <code>concatOL</code> a super precise type, which  states that the size of the output list equals the sum-of-the-sizes  of the input <code>OrdLists</code>.</p> <pre>298: {-@ concatOL :: xs:[OrdList a] -&gt; OrdListN a {(olens xs)} @-}\n299: forall a.\nx1:[(OrdList.OrdList a)]\n-&gt; {VV : (OrdList.OrdList a) | ((olen VV) == (olens x1))}concatOL []       = forall a. {x2 : (OrdList.OrdList a) | ((olen x2) == 0)}None\n300: concatOL (ol:ols) = {x3 : (OrdList.OrdList a) | (x3 == ol) &amp;&amp; ((olen x3) &gt;= 0)}ol x1:(OrdList.OrdList a)\n-&gt; x2:(OrdList.OrdList a)\n-&gt; {x2 : (OrdList.OrdList a) | ((olen x2) == ((olen x1) + (olen x2)))}`appOL` forall a.\nx1:[(OrdList.OrdList a)]\n-&gt; {VV : (OrdList.OrdList a) | ((olen VV) == (olens x1))}concatOL {x5 : [(OrdList.OrdList a)] | (x5 == ols) &amp;&amp; ((len x5) &gt;= 0) &amp;&amp; ((olens x5) &gt;= 0) &amp;&amp; ((sumLens x5) &gt;= 0)}ols\n</pre> <p>The notion of sum-of-the-sizes of the input lists is specifed by the measure</p> <pre>306: {-@ measure olens :: [OrdList a] -&gt; Int\n307:     olens ([])     = 0\n308:     olens (ol:ols) = (olen ol) + (olens ols)\n309:   @-}\n310: \n311: {-@ invariant {v:[OrdList a] | (olens v) &gt;= 0} @-}\n</pre> <p>LiquidHaskell is happy to verify the above signature, again without  requiring any explict proofs. </p>","tags":["basic","measures"]},{"location":"blogposts/2014-02-11-the-advantage-of-measures.lhs/#conclusion","title":"Conclusion","text":"<p>The above illustrates the flexibility provided by LiquidHaskell measures.</p> <p>Instead of having to bake particular invariants into a datatype using indices or phantom types (as in the GADT approach), we are able to split our  properties out into independent views of the datatype, yielding an approach that is more modular as </p> <ul> <li>we didn't have to go back and change the definition of <code>[]</code> to talk about <code>OrdList</code>s,</li> <li>we didn't have to provide explict non-emptiness witnesses,</li> <li>we obtained extra information about the behavior of API functions like <code>concatOL</code>.</li> </ul>  We can actually even verify the original definition of `concatOL` with a clever use of *abstract refinements*, but we have to slightly change the signature of `foldr`.   <pre>338: {- UGH CAN'T PARSE `GHC.Types.:`...\nfoldr' :: forall &lt;p :: [a] -&gt; b -&gt; Prop&gt;.\n          (xs:[a] -&gt; x:a -&gt; b&lt;p xs&gt; -&gt; b&lt;p (GHC.Types.: x xs)&gt;)\n       -&gt; b&lt;p GHC.Types.[]&gt;\n       -&gt; ys:[a]\n       -&gt; b&lt;p ys&gt;\n@-}\n345: forall a b.\n({VV : [a] | ((len VV) &gt;= 0)} -&gt; a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; bfoldr' {VV : [a] | ((len VV) &gt;= 0)} -&gt; a -&gt; b -&gt; bf az []     = {VV : a | (VV == z)}z\n346: foldr' f z (x:xs) = {x2 : [a] | ((len x2) &gt;= 0)} -&gt; a -&gt; b -&gt; bf {x5 : [a] | (x5 == xs) &amp;&amp; ((len x5) &gt;= 0) &amp;&amp; ((olens x5) &gt;= 0) &amp;&amp; ((sumLens x5) &gt;= 0)}xs {VV : a | (VV == x)}x (forall a b.\n({VV : [a] | ((len VV) &gt;= 0)} -&gt; a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; bfoldr' {x2 : [a] | ((len x2) &gt;= 0)} -&gt; a -&gt; b -&gt; bf {VV : a | (VV == z)}z {x5 : [a] | (x5 == xs) &amp;&amp; ((len x5) &gt;= 0) &amp;&amp; ((olens x5) &gt;= 0) &amp;&amp; ((sumLens x5) &gt;= 0)}xs)\n</pre>  We've added a *ghost parameter* to the folding function, letting us refer to the tail of the list at each folding step. This lets us encode inductive reasoning in the type of `foldr`, specifically that  1. given a base case `z` that satisfies `p []` 2. and a function that, given a value that satisfies `p xs`, returns a value satisfying `p (x:xs)` 3. the value returned by `foldr f z ys` must satisfy `p ys`!  LiquidHaskell can use this signature, instantiating `p` with `\\xs -&gt; {v:OrdList a | (olen v) = (olens xs)}` to prove the original definition of `concatOL`!   <pre>363: {- concatOL' :: xs:[OrdList a] -&gt; OrdListN a {(olens xs)} @-}\n364: forall a. [(OrdList.OrdList a)] -&gt; (OrdList.OrdList a)concatOL' [(OrdList.OrdList a)]aas = ([(OrdList.OrdList a)]\n -&gt; (OrdList.OrdList a)\n -&gt; (OrdList.OrdList a)\n -&gt; (OrdList.OrdList a))\n-&gt; (OrdList.OrdList a)\n-&gt; [(OrdList.OrdList a)]\n-&gt; (OrdList.OrdList a)foldr' ((x5:(OrdList.OrdList a)\n -&gt; x6:(OrdList.OrdList a)\n -&gt; {x15 : (OrdList.OrdList a) | ((olen x15) == ((olen x5) + (olen x6))) &amp;&amp; ((olen x15) == ((olen x6) + (olen x5)))})\n-&gt; [(OrdList.OrdList a)]\n-&gt; x5:(OrdList.OrdList a)\n-&gt; x6:(OrdList.OrdList a)\n-&gt; {x15 : (OrdList.OrdList a) | ((olen x15) == ((olen x5) + (olen x6))) &amp;&amp; ((olen x15) == ((olen x6) + (olen x5)))}const x1:(OrdList.OrdList a)\n-&gt; x2:(OrdList.OrdList a)\n-&gt; {x2 : (OrdList.OrdList a) | ((olen x2) == ((olen x1) + (olen x2)))}appOL) {x3 : (OrdList.OrdList {VV : a | false}) | ((olen x3) == 0) &amp;&amp; ((olen x3) &gt;= 0)}None {x5 : [(OrdList.OrdList a)] | (x5 == aas) &amp;&amp; ((len x5) &gt;= 0) &amp;&amp; ((olens x5) &gt;= 0) &amp;&amp; ((sumLens x5) &gt;= 0)}aas\n</pre>  We haven't added the modified version of `foldr` to the LiquidHaskell Prelude yet because it adds the ghost variable to the Haskell type-signature.","tags":["basic","measures"]},{"location":"blogposts/2014-05-28-pointers-gone-wild.lhs/","title":"Pointers Gone Wild","text":"<p>A large part of the allure of Haskell is its elegant, high-level ADTs that ensure<sup>1</sup> that programs won't be plagued by problems like the infamous SSL heartbleed bug.</p> <p>However, another part of Haskell's charm is that when you really really  need to, you can drop down to low-level pointer twiddling to squeeze the  most performance out of your machine. But of course, that opens the door  to the #heartbleeds.</p> <p>Can we have have our cake and eat it too? </p> <p>Can we twiddle pointers and still get the nice safety assurances of high-level types?</p> <p>To understand the potential for potential bleeding, let's study the popular <code>text</code> library for efficient  text processing. The library provides the high-level  API Haskellers have come to expect while using stream  fusion and byte arrays under the hood to guarantee  high performance.</p> <p>Suppose we wanted to get the ith <code>Char</code> of a <code>Text</code>,  we could write a function<sup>2</sup></p> <pre>39: charAt (Text a o l) i = word2char $ unsafeIndex a (o+i)\n40:   where \n41:     word2char         = chr . fromIntegral\n</pre> <p>which extracts the underlying array <code>a</code>, indexes into it starting at the offset <code>o</code> and casts the <code>Word16</code> to a <code>Char</code>, using  functions exported by <code>text</code>.</p> <p>Let's try this out in GHCi.</p> <pre>50: ghci&gt; let t = pack ['d','o','g']\n51: ghci&gt; charAt t 0\n52: 'd'\n53: ghci&gt; charAt t 2\n54: 'g'\n</pre> <p>Looks good so far, what happens if we keep going?</p> <pre>58: ghci&gt; charAt t 3\n59: '\\NUL'\n60: ghci&gt; charAt t 100\n61: '\\8745'\n</pre> <p>Oh dear, not only did we not get any sort of exception from Haskell,  we weren't even stopped by the OS with a segfault. This is quite  dangerous since we have no idea what sort of data we just read!  To be fair to the library's authors, we did use a function that  was clearly branded <code>unsafe</code>, but these functions, while not  intended for clients, pervade the implementation of the library.</p> <p>Wouldn't it be nice to have these last two calls rejected at compile time?</p> <p>In this post we'll see exactly how prevent invalid memory accesses  like this with LiquidHaskell.</p> <pre>80: {-# LANGUAGE BangPatterns, MagicHash, Rank2Types,\n    RecordWildCards, UnboxedTuples, ExistentialQuantification #-}\n82: {-@ LIQUID \"--no-termination\" @-}\n83: module TextInternal (test, goodMain, badMain, charAt, charAt') where\n84: \n85: import qualified Control.Exception as Ex\n86: import Control.Applicative     ((&lt;$&gt;))\n87: import Control.Monad           (when)\n88: import Control.Monad.ST.Unsafe (unsafeIOToST)\n89: import Data.Bits (shiftR, xor, (.&amp;.))\n90: import Data.Char\n91: import Foreign.C.Types (CSize)\n92: import GHC.Base (Int(..), ByteArray#, MutableByteArray#, newByteArray#,\n93:                  writeWord16Array#, indexWord16Array#, unsafeCoerce#, ord,\n94:                  iShiftL#)\n95: import GHC.ST (ST(..), runST)\n96: import GHC.Word (Word16(..))\n97: \n98: import qualified Data.Text.Lazy.IO as TIO\n99: import qualified Data.Text as T\n100: import qualified Data.Text.Internal as T\n101: \n102: import Language.Haskell.Liquid.Prelude\n103: \n104: {-@ aLen :: a:Array -&gt; {v:Nat | v = (aLen a)}  @-}\n105: \n106: {-@ maLen :: a:MArray s -&gt; {v:Nat | v = (maLen a)}  @-}\n107: \n108: new          :: forall s. Int -&gt; ST s (MArray s)\n109: unsafeWrite  :: MArray s -&gt; Int -&gt; Word16 -&gt; ST s ()\n110: unsafeFreeze :: MArray s -&gt; ST s Array\n111: unsafeIndex  :: Array -&gt; Int -&gt; Word16\n112: copyM        :: MArray s               -- ^ Destination\n113:              -&gt; Int                    -- ^ Destination offset\n114:              -&gt; MArray s               -- ^ Source\n115:              -&gt; Int                    -- ^ Source offset\n116:              -&gt; Int                    -- ^ Count\n117:              -&gt; ST s ()\n118: \n119: {-@ memcpyM :: MutableByteArray# s -&gt; CSize -&gt; MutableByteArray# s -&gt; CSize -&gt; CSize -&gt; IO () @-}\n120: memcpyM :: MutableByteArray# s -&gt; CSize -&gt; MutableByteArray# s -&gt; CSize -&gt; CSize -&gt; IO ()\n121: forall a.\n(MutableByteArray# a)\n-&gt; CSize -&gt; (MutableByteArray# a) -&gt; CSize -&gt; CSize -&gt; (IO ())memcpyM = forall a. aundefined\n122: \n123: --------------------------------------------------------------------------------\n124: --- Helper Code\n125: --------------------------------------------------------------------------------\n126: {-@ shiftL :: i:Nat -&gt; n:Nat -&gt; {v:Nat | ((n = 1) =&gt; (v = (i * 2)))} @-}\n127: shiftL :: Int -&gt; Int -&gt; Int\n128: x1:{v : Int | (v &gt;= 0)}\n-&gt; x2:{v : Int | (v &gt;= 0)}\n-&gt; {v : Int | ((x2 == 1) =&gt; (v == (x1 * 2))) &amp;&amp; (v &gt;= 0)}shiftL = forall a. aundefined -- (I# x#) (I# i#) = I# (x# `iShiftL#` i#)\n129: \n130: pack :: String -&gt; Text\n131: x1:[Char] -&gt; {v : Text | ((tLen v) == (len x1))}pack = forall a. aundefined -- not \"actually\" using\n132: \n133: forall a. {v : Bool | ((Prop v))} -&gt; a -&gt; aassert {v : Bool | ((Prop v))}b aa = Bool -&gt; a -&gt; aEx.assert {x3 : Bool | ((Prop x3)) &amp;&amp; (x3 == b)}b {VV : a | (VV == a)}a\n134: \n135: \n136: data Text = Text Array Int Int\n137: \n138: {-@ tLength :: t:Text -&gt; {v:_ | v = (tLen t)} @-}\n139: x1:Text -&gt; {v : Int | (v == (tLen x1))}tLength (Text _ _ n)  =  {x3 : Int | (x3 == n) &amp;&amp; (x3 &gt;= 0)}n\n</pre>","tags":["benchmarks","text"]},{"location":"blogposts/2014-05-28-pointers-gone-wild.lhs/#the-text-lifecycle","title":"The <code>Text</code> Lifecycle","text":"<p><code>text</code> splits the reading and writing array operations between two types of arrays, immutable <code>Array</code>s and mutable <code>MArray</code>s. This leads to the following general lifecycle:</p> <p></p> <p>The main four array operations we care about are:</p> <ol> <li>creating an <code>MArray</code>,</li> <li>writing into an <code>MArray</code>,</li> <li>freezing an <code>MArray</code> into an <code>Array</code>, and</li> <li>reading from an <code>Array</code>.</li> </ol>","tags":["benchmarks","text"]},{"location":"blogposts/2014-05-28-pointers-gone-wild.lhs/#creating-an-marray","title":"Creating an <code>MArray</code>","text":"<p>The (mutable) <code>MArray</code> is a thin wrapper around GHC's primitive <code>MutableByteArray#</code>, additionally carrying the number of <code>Word16</code>s it can store.</p> <pre>167: data MArray s = MArray { forall a. (MArray a) -&gt; (MutableByteArray# a)maBA  :: MutableByteArray# s\n168:                        , forall a.\nx1:(MArray a) -&gt; {v : Int | (v == (maLen x1)) &amp;&amp; (v &gt;= 0)}maLen :: !Int\n169:                        }\n</pre> <p>It doesn't make any sense to have a negative length, so we refine the data definition to require that <code>maLen</code> be non-negative. </p> <pre>176: {-@ data MArray s = MArray { maBA  :: MutableByteArray# s\n177:                            , maLen :: Nat\n178:                            }\n179:   @-}\n</pre> <p>As an added bonus, the above specification generates field-accessor measures that we will use inside the refined types:</p> <pre>184: {-@ measure maLen :: MArray s -&gt; Int\n185:     maLen (MArray a l) = l\n186:   @-}\n</pre> <p>We can use these accessor measures to define <code>MArray</code>s of size <code>N</code>:</p> <pre>192: {-@ type MArrayN a N = {v:MArray a | (maLen v) = N} @-}\n</pre> <p>and we can use the above alias, to write a type that tracks the size of an <code>MArray</code> at the point where it is created:</p> <pre>199: {-@ new :: forall s. n:Nat -&gt; ST s (MArrayN s n) @-}\n200: forall a.\nx1:{v : Int | (v &gt;= 0)}\n-&gt; (ST a {v : (MArray a) | ((maLen v) == x1)})new {v : Int | (v &gt;= 0)}n\n201:   | {x3 : Int | (x3 == n) &amp;&amp; (x3 &gt;= 0)}n x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 &lt; x2))}&lt; {x2 : Int | (x2 == (0  :  int))}0 x1:Bool\n-&gt; x2:Bool\n-&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (((Prop x1)) || ((Prop x2))))}|| {x3 : Int | (x3 == n) &amp;&amp; (x3 &gt;= 0)}n Int -&gt; Int -&gt; Int.&amp;. {x2 : Int | (x2 == highBit)}highBit x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 /= x2))}/= {x2 : Int | (x2 == (0  :  int))}0 = [Char] -&gt; {x1 : (ST a {x2 : (MArray a) | false}) | false}error {x2 : [Char] | ((len x2) &gt;= 0)}\"size overflow\"\n202:   | otherwise = ((State# a) -&gt; ((State# a), {x7 : (MArray a) | ((maLen x7) == n)}))\n-&gt; (ST a {x3 : (MArray a) | ((maLen x3) == n)})ST (((State# a)\n  -&gt; ((State# a), {x17 : (MArray a) | ((maLen x17) == n)}))\n -&gt; (ST a {x12 : (MArray a) | ((maLen x12) == n)}))\n-&gt; ((State# a)\n    -&gt; ((State# a), {x17 : (MArray a) | ((maLen x17) == n)}))\n-&gt; (ST a {x12 : (MArray a) | ((maLen x12) == n)})$ \\(State# a)s1# -&gt;\n203:        case Int# -&gt; (State# a) -&gt; ((State# a), (MutableByteArray# a))newByteArray# {x2 : Int# | (x2 == len)}len# {x2 : (State# a) | (x2 == s1)}s1# of\n204:          (# s2#, marr# #) -&gt; forall a b. a -&gt; b -&gt; (a, b)(# {x2 : (State# a) | (x2 == s2)}s2#, x1:(MutableByteArray# a)\n-&gt; x2:{x5 : Int | (x5 &gt;= 0)}\n-&gt; {x3 : (MArray a) | ((maBA x3) == x1) &amp;&amp; ((maLen x3) == x2)}MArray {x2 : (MutableByteArray# a) | (x2 == marr)}marr# {x3 : Int | (x3 == n) &amp;&amp; (x3 &gt;= 0)}n #)\n205:   where !(I# len#) = x1:{x11 : Int | (x11 == n) &amp;&amp; (x11 &gt;= 0)}\n-&gt; {x8 : Int | ((x1 == 1) =&gt; (x8 == (x1 * 2))) &amp;&amp; ((x1 == 1) =&gt; (x8 == (n * 2))) &amp;&amp; ((n == 1) =&gt; (x8 == (x1 * 2))) &amp;&amp; ((n == 1) =&gt; (x8 == (n * 2))) &amp;&amp; (x8 &gt;= 0) &amp;&amp; (x8 &gt;= x1) &amp;&amp; (x8 &gt;= n)}bytesInArray {x3 : Int | (x3 == n) &amp;&amp; (x3 &gt;= 0)}n\n206:         InthighBit    = IntmaxBound Int -&gt; Int -&gt; Int`xor` (IntmaxBound Int -&gt; Int -&gt; Int`shiftR` {x2 : Int | (x2 == (1  :  int))}1)\n207:         n:{VV : Int | (VV == n) &amp;&amp; (VV &gt;= 0)}\n-&gt; {VV : Int | ((n == 1) =&gt; (VV == (n * 2))) &amp;&amp; ((n == 1) =&gt; (VV == (n * 2))) &amp;&amp; ((n == 1) =&gt; (VV == (n * 2))) &amp;&amp; ((n == 1) =&gt; (VV == (n * 2))) &amp;&amp; (VV &gt;= 0) &amp;&amp; (VV &gt;= n) &amp;&amp; (VV &gt;= n)}bytesInArray {VV : Int | (VV == n) &amp;&amp; (VV &gt;= 0)}n = {x4 : Int | (x4 == n) &amp;&amp; (x4 == n) &amp;&amp; (x4 &gt;= 0)}n x1:{x7 : Int | (x7 &gt;= 0)}\n-&gt; x2:{x5 : Int | (x5 &gt;= 0)}\n-&gt; {x3 : Int | ((x2 == 1) =&gt; (x3 == (x1 * 2))) &amp;&amp; (x3 &gt;= 0)}`shiftL` {x2 : Int | (x2 == (1  :  int))}1\n</pre> <p><code>new n</code> is an <code>ST</code> action that produces an <code>MArray s</code> with <code>n</code> slots each  of which is 2 bytes (as internally <code>text</code> manipulates <code>Word16</code>s).</p> <p>The verification process here is quite simple; LH recognizes that  the <code>n</code> used to construct the returned array (<code>MArray marr# n</code>)  the same <code>n</code> passed to <code>new</code>. </p>","tags":["benchmarks","text"]},{"location":"blogposts/2014-05-28-pointers-gone-wild.lhs/#writing-into-an-marray","title":"Writing into an <code>MArray</code>","text":"<p>Once we have created an <code>MArray</code>, we'll want to write our data into it. </p> <p>A <code>Nat</code> is a valid index into an <code>MArray</code> if it is strictly less than  the size of the array.</p> <pre>226: {-@ type MAValidI MA = {v:Nat | v &lt; (maLen MA)} @-}\n</pre> <p>We use this valid index alias to refine the type of <code>unsafeWrite</code></p> <pre>232: {-@ unsafeWrite :: ma:MArray s -&gt; MAValidI ma -&gt; Word16 -&gt; ST s () @-}\n233: forall a.\nx1:(MArray a)\n-&gt; {v : Int | (v &gt;= 0) &amp;&amp; (v &lt; (maLen x1))} -&gt; Word16 -&gt; (ST a ())unsafeWrite MArray{..} {v : Int | (v &gt;= 0)}i@(I# i#) (W16# e#)\n234:   | {x5 : Int | (x5 == i) &amp;&amp; (x5 == i) &amp;&amp; (x5 == (i  :  int)) &amp;&amp; (x5 &gt;= 0)}i x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 &lt; x2))}&lt; {x2 : Int | (x2 == (0  :  int))}0 x1:Bool\n-&gt; x2:Bool\n-&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (((Prop x1)) || ((Prop x2))))}|| {x5 : Int | (x5 == i) &amp;&amp; (x5 == i) &amp;&amp; (x5 == (i  :  int)) &amp;&amp; (x5 &gt;= 0)}i x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 &gt;= x2))}&gt;= {x2 : Int | (x2 &gt;= 0)}maLen = {x6 : Bool | ((Prop x6))} -&gt; (ST a ()) -&gt; (ST a ())assert {x3 : Bool | (not (((Prop x3)))) &amp;&amp; (x3 == GHC.Types.False)}False ((ST a ()) -&gt; (ST a ())) -&gt; (ST a ()) -&gt; (ST a ())$ [Char] -&gt; (ST a ())error {x2 : [Char] | ((len x2) &gt;= 0)}\"out of bounds\"\n235:   | otherwise = ((State# a) -&gt; ((State# a), ())) -&gt; (ST a ())ST (((State# a) -&gt; ((State# a), ())) -&gt; (ST a ()))\n-&gt; ((State# a) -&gt; ((State# a), ())) -&gt; (ST a ())$ \\(State# a)s1# -&gt;\n236:       case (MutableByteArray# a) -&gt; Int# -&gt; Word# -&gt; (State# a) -&gt; (State# a)writeWord16Array# (MutableByteArray# a)maBA {x2 : Int# | (x2 == i)}i# {x2 : Word# | (x2 == e)}e# {x2 : (State# a) | (x2 == s1)}s1# of\n237:         s2# -&gt; forall a b. a -&gt; b -&gt; (a, b)(# (State# a)s2#, {x2 : () | (x2 == GHC.Tuple.())}() #)\n</pre> <p>Note that, when compiled with appropriate options, the implementation of <code>text</code> checks the bounds at run-time. However, LiquidHaskell can statically prove that the error branch is unreachable, i.e. the <code>assert</code> cannot fail (as long as the inputs adhere to the given specification) by giving <code>assert</code> the type:</p> <pre>247: {-@ assert assert :: {v:Bool | (Prop v)} -&gt; a -&gt; a @-}\n</pre>","tags":["benchmarks","text"]},{"location":"blogposts/2014-05-28-pointers-gone-wild.lhs/#bulk-writing-into-an-marray","title":"Bulk Writing into an <code>MArray</code>","text":"<p>So now we can write individual <code>Word16</code>s into an array, but maybe we have a whole bunch of text we want to dump into the array. Remember, <code>text</code> is supposed to be fast! C has <code>memcpy</code> for cases like this but  it's notoriously unsafe; with the right type however, we can regain safety.  <code>text</code> provides a wrapper around <code>memcpy</code> to copy <code>n</code> elements from  one <code>MArray</code> to another.</p> <p><code>copyM</code> requires two <code>MArray</code>s and valid offsets into each -- note that a valid offset is not necessarily a valid index, it may be one element out-of-bounds</p> <pre>265: {-@ type MAValidO MA = {v:Nat | v &lt;= (maLen MA)} @-}\n</pre> <p>-- and a <code>count</code> of elements to copy. The <code>count</code> must represent a valid region in each <code>MArray</code>, in other words <code>offset + count &lt;= length</code> must hold for each array.</p> <pre>273: {-@ copyM :: dest:MArray s\n274:           -&gt; didx:MAValidO dest\n275:           -&gt; src:MArray s\n276:           -&gt; sidx:MAValidO src\n277:           -&gt; {v:Nat | (((didx + v) &lt;= (maLen dest))\n                    &amp;&amp; ((sidx + v) &lt;= (maLen src)))}\n279:           -&gt; ST s ()\n280:   @-}\n281: forall a.\nx1:(MArray a)\n-&gt; x2:{v : Int | (v &gt;= 0) &amp;&amp; (v &lt;= (maLen x1))}\n-&gt; x3:(MArray a)\n-&gt; x4:{v : Int | (v &gt;= 0) &amp;&amp; (v &lt;= (maLen x3))}\n-&gt; {v : Int | (v &gt;= 0) &amp;&amp; ((x2 + v) &lt;= (maLen x1)) &amp;&amp; ((x4 + v) &lt;= (maLen x3))}\n-&gt; (ST a ())copyM (MArray a)dest {v : Int | (v &gt;= 0) &amp;&amp; (v &lt;= (maLen dest))}didx (MArray a)src {v : Int | (v &gt;= 0) &amp;&amp; (v &lt;= (maLen src))}sidx {v : Int | (v &gt;= 0) &amp;&amp; ((didx + v) &lt;= (maLen dest)) &amp;&amp; ((sidx + v) &lt;= (maLen src))}count\n282:     | {x5 : Int | (x5 == count) &amp;&amp; (x5 &gt;= 0) &amp;&amp; ((didx + x5) &lt;= (maLen dest)) &amp;&amp; ((sidx + x5) &lt;= (maLen src))}count x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 &lt;= x2))}&lt;= {x2 : Int | (x2 == (0  :  int))}0 = () -&gt; (ST a ())return {x2 : () | (x2 == GHC.Tuple.())}()\n283:     | otherwise =\n284:     {x6 : Bool | ((Prop x6))} -&gt; (ST a ()) -&gt; (ST a ())assert ({x4 : Int | (x4 == sidx) &amp;&amp; (x4 &gt;= 0) &amp;&amp; (x4 &lt;= (maLen src))}sidx x1:Int -&gt; x2:Int -&gt; {x4 : Int | (x4 == (x1 + x2))}+ {x5 : Int | (x5 == count) &amp;&amp; (x5 &gt;= 0) &amp;&amp; ((didx + x5) &lt;= (maLen dest)) &amp;&amp; ((sidx + x5) &lt;= (maLen src))}count x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 &lt;= x2))}&lt;= x1:(MArray a) -&gt; {x3 : Int | (x3 == (maLen x1)) &amp;&amp; (x3 &gt;= 0)}maLen {x2 : (MArray a) | (x2 == src)}src) ((ST a ()) -&gt; (ST a ()))\n-&gt; ((IO ()) -&gt; (ST a ()))\n-&gt; (IO ())\n-&gt; exists [(ST a ())].(ST a ()).\n285:     {x6 : Bool | ((Prop x6))} -&gt; (ST a ()) -&gt; (ST a ())assert ({x4 : Int | (x4 == didx) &amp;&amp; (x4 &gt;= 0) &amp;&amp; (x4 &lt;= (maLen dest))}didx x1:Int -&gt; x2:Int -&gt; {x4 : Int | (x4 == (x1 + x2))}+ {x5 : Int | (x5 == count) &amp;&amp; (x5 &gt;= 0) &amp;&amp; ((didx + x5) &lt;= (maLen dest)) &amp;&amp; ((sidx + x5) &lt;= (maLen src))}count x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 &lt;= x2))}&lt;= x1:(MArray a) -&gt; {x3 : Int | (x3 == (maLen x1)) &amp;&amp; (x3 &gt;= 0)}maLen {x2 : (MArray a) | (x2 == dest)}dest) ((ST a ()) -&gt; (ST a ()))\n-&gt; ((IO ()) -&gt; (ST a ()))\n-&gt; (IO ())\n-&gt; exists [(ST a ())].(ST a ()).\n286:     (IO ()) -&gt; (ST a ())unsafeIOToST ((IO ()) -&gt; (ST a ())) -&gt; (IO ()) -&gt; (ST a ())$ (MutableByteArray# a)\n-&gt; CSize -&gt; (MutableByteArray# a) -&gt; CSize -&gt; CSize -&gt; (IO ())memcpyM ((MArray a) -&gt; (MutableByteArray# a)maBA {x2 : (MArray a) | (x2 == dest)}dest) (x1:Int -&gt; {x2 : CSize | (x2 == x1)}fromIntegral {x4 : Int | (x4 == didx) &amp;&amp; (x4 &gt;= 0) &amp;&amp; (x4 &lt;= (maLen dest))}didx)\n287:                            ((MArray a) -&gt; (MutableByteArray# a)maBA {x2 : (MArray a) | (x2 == src)}src) (x1:Int -&gt; {x2 : CSize | (x2 == x1)}fromIntegral {x4 : Int | (x4 == sidx) &amp;&amp; (x4 &gt;= 0) &amp;&amp; (x4 &lt;= (maLen src))}sidx)\n288:                            (x1:Int -&gt; {x2 : CSize | (x2 == x1)}fromIntegral {x5 : Int | (x5 == count) &amp;&amp; (x5 &gt;= 0) &amp;&amp; ((didx + x5) &lt;= (maLen dest)) &amp;&amp; ((sidx + x5) &lt;= (maLen src))}count)\n</pre> <p>Again, the two <code>assert</code>s in the function were in the original code as  (optionally compiled out) run-time checks of the precondition, but with  LiquidHaskell we can actually prove that the <code>assert</code>s always succeed.</p>","tags":["benchmarks","text"]},{"location":"blogposts/2014-05-28-pointers-gone-wild.lhs/#freezing-an-marray-into-an-array","title":"Freezing an <code>MArray</code> into an <code>Array</code>","text":"<p>Before we can package up our <code>MArray</code> into a <code>Text</code>, we need to freeze it, preventing any further mutation. The key property  here is of course that the frozen <code>Array</code> should have the same  length as the <code>MArray</code>.</p> <p>Just as <code>MArray</code> wraps a mutable array, <code>Array</code> wraps an immutable <code>ByteArray#</code> and carries its length in <code>Word16</code>s.</p> <pre>307: data Array = Array { Array -&gt; ByteArray#aBA  :: ByteArray#\n308:                    , x1:Array -&gt; {v : Int | (v == (aLen x1)) &amp;&amp; (v &gt;= 0)}aLen :: !Int\n309:                    }\n</pre> <p>As before, we get free accessor measures <code>aBA</code> and <code>aLen</code> just by refining the data definition</p> <pre>316: {-@ data Array = Array { aBA  :: ByteArray#\n317:                        , aLen :: Nat\n318:                        }\n319:   @-}\n</pre> <p>so we can refer to the components of an <code>Array</code> in our refinements. Using these measures, we can define</p> <pre>326: {-@ type ArrayN N = {v:Array | (aLen v) = N} @-}\n327: {-@ unsafeFreeze :: ma:MArray s -&gt; ST s (ArrayN (maLen ma)) @-}\n328: forall a.\nx1:(MArray a) -&gt; (ST a {v : Array | ((aLen v) == (maLen x1))})unsafeFreeze MArray{..} = ((State# a) -&gt; ((State# a), {x5 : Array | false}))\n-&gt; (ST a {x2 : Array | false})ST (((State# a)\n  -&gt; {x11 : ((State# a), {x13 : Array | false}) | false})\n -&gt; (ST a {x9 : Array | false}))\n-&gt; ((State# a)\n    -&gt; {x11 : ((State# a), {x13 : Array | false}) | false})\n-&gt; (ST a {x9 : Array | false})$ \\(State# a)s# -&gt;\n329:                           forall a b. a -&gt; b -&gt; (a, b)(# {x2 : (State# a) | (x2 == s)}s#, x1:ByteArray#\n-&gt; x2:{x5 : Int | (x5 &gt;= 0)}\n-&gt; {x3 : Array | ((aBA x3) == x1) &amp;&amp; ((aLen x3) == x2)}Array ((MutableByteArray# a) -&gt; {x1 : ByteArray# | false}unsafeCoerce# (MutableByteArray# a)maBA) {x2 : Int | (x2 &gt;= 0)}maLen #)\n</pre> <p>Again, LiquidHaskell is happy to prove our specification as we simply copy the length parameter <code>maLen</code> over into the <code>Array</code>.</p>","tags":["benchmarks","text"]},{"location":"blogposts/2014-05-28-pointers-gone-wild.lhs/#reading-from-an-array","title":"Reading from an <code>Array</code>","text":"<p>Finally, we will eventually want to read a value out of the <code>Array</code>. As with <code>unsafeWrite</code> we require a valid index into the <code>Array</code>, which we denote using the <code>AValidI</code> alias.</p> <pre>342: {-@ type AValidI A = {v:Nat | v &lt; (aLen A)} @-}\n343: {-@ unsafeIndex :: a:Array -&gt; AValidI a -&gt; Word16 @-}\n344: x1:Array -&gt; {v : Int | (v &gt;= 0) &amp;&amp; (v &lt; (aLen x1))} -&gt; Word16unsafeIndex Array{..} {v : Int | (v &gt;= 0)}i@(I# i#)\n345:   | {x5 : Int | (x5 == i) &amp;&amp; (x5 == i) &amp;&amp; (x5 == (i  :  int)) &amp;&amp; (x5 &gt;= 0)}i x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 &lt; x2))}&lt; {x2 : Int | (x2 == (0  :  int))}0 x1:Bool\n-&gt; x2:Bool\n-&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (((Prop x1)) || ((Prop x2))))}|| {x5 : Int | (x5 == i) &amp;&amp; (x5 == i) &amp;&amp; (x5 == (i  :  int)) &amp;&amp; (x5 &gt;= 0)}i x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 &gt;= x2))}&gt;= {x2 : Int | (x2 &gt;= 0)}aLen = {x4 : Bool | ((Prop x4))} -&gt; Word16 -&gt; Word16assert {x3 : Bool | (not (((Prop x3)))) &amp;&amp; (x3 == GHC.Types.False)}False (Word16 -&gt; Word16) -&gt; Word16 -&gt; Word16$ [Char] -&gt; Word16error {x2 : [Char] | ((len x2) &gt;= 0)}\"out of bounds\"\n346:   | otherwise = case ByteArray# -&gt; Int# -&gt; Word#indexWord16Array# ByteArray#aBA {x2 : Int# | (x2 == i)}i# of\n347:                   r# -&gt; (Word# -&gt; Word16W16# Word#r#)\n</pre> <p>As before, LiquidHaskell can easily prove that the error branch is unreachable, i.e. is never executed at run-time.</p>","tags":["benchmarks","text"]},{"location":"blogposts/2014-05-28-pointers-gone-wild.lhs/#wrapping-it-all-up","title":"Wrapping it all up","text":"<p>Now we can finally define the core datatype of the <code>text</code> package! A <code>Text</code> value consists of three fields:</p> <p>A. an <code>Array</code>,</p> <p>B. an <code>Int</code> offset into the middle of the array, and</p> <p>C. an <code>Int</code> length denoting the number of valid indices after the offset.</p> <p>We can specify the invariants for fields (b) and (c) with the refined type:</p> <pre>368: {-@ data Text\n369:       = Text { tArr :: Array\n370:              , tOff :: {v:Nat | v      &lt;= (aLen tArr)}\n371:              , tLen :: {v:Nat | v+tOff &lt;= (aLen tArr)}\n372:              }\n373:   @-}\n</pre> <p>These invariants ensure that any index we pick between <code>tOff</code> and <code>tOff + tLen</code> will be a valid index into <code>tArr</code>. </p> <p>As shown above with <code>new</code>, <code>unsafeWrite</code>, and <code>unsafeFreeze</code>, we can type the top-level function that creates a <code>Text</code> from a <code>[Char]</code> as:</p> <pre>383: {-@ pack :: s:String -&gt; {v:Text | (tLen v) = (len s)} @-}\n</pre>","tags":["benchmarks","text"]},{"location":"blogposts/2014-05-28-pointers-gone-wild.lhs/#preventing-bleeds","title":"Preventing Bleeds","text":"<p>Now, let us close the circle and return to potentially bleeding function:</p> <pre>392: Text -&gt; Int -&gt; CharcharAt' (Text a o l) Inti = Word16 -&gt; exists [Int].Charword2char (Word16 -&gt; Char) -&gt; Word16 -&gt; Char$ x1:Array -&gt; {x4 : Int | (x4 &gt;= 0) &amp;&amp; (x4 &lt; (aLen x1))} -&gt; Word16unsafeIndex {x2 : Array | (x2 == a)}a ({x4 : Int | (x4 == o) &amp;&amp; (x4 &gt;= 0) &amp;&amp; (x4 &lt;= (aLen a))}ox1:Int -&gt; x2:Int -&gt; {x4 : Int | (x4 == (x1 + x2))}+{x2 : Int | (x2 == i)}i)\n393:   where \n394:     Word16 -&gt; exists [Int].Charword2char          = Int -&gt; Charchr (Int -&gt; Char) -&gt; (Word16 -&gt; Int) -&gt; Word16 -&gt; exists [Int].Char. x1:Word16 -&gt; {x2 : Int | (x2 == x1)}fromIntegral\n</pre> <p>Aha! LiquidHaskell flags the call to <code>unsafeIndex</code> because of course, <code>i</code> may fall outside the bounds of the given array <code>a</code>! We can remedy that by specifying a bound for the index:</p> <pre>402: {-@ charAt :: t:Text -&gt; {v:Nat | v &lt; (tLen t)} -&gt; Char @-}\n403: x1:Text -&gt; {v : Int | (v &gt;= 0) &amp;&amp; (v &lt; (tLen x1))} -&gt; CharcharAt (Text a o l) {v : Int | (v &gt;= 0)}i = Word16 -&gt; exists [Int].Charword2char (Word16 -&gt; Char) -&gt; Word16 -&gt; Char$ x1:Array -&gt; {x4 : Int | (x4 &gt;= 0) &amp;&amp; (x4 &lt; (aLen x1))} -&gt; Word16unsafeIndex {x2 : Array | (x2 == a)}a ({x4 : Int | (x4 == o) &amp;&amp; (x4 &gt;= 0) &amp;&amp; (x4 &lt;= (aLen a))}ox1:Int -&gt; x2:Int -&gt; {x4 : Int | (x4 == (x1 + x2))}+{x3 : Int | (x3 == i) &amp;&amp; (x3 &gt;= 0)}i)\n404:   where \n405:     Word16 -&gt; exists [Int].Charword2char         = Int -&gt; Charchr (Int -&gt; Char) -&gt; (Word16 -&gt; Int) -&gt; Word16 -&gt; exists [Int].Char. x1:Word16 -&gt; {x2 : Int | (x2 == x1)}fromIntegral\n</pre> <p>That is, we can access the <code>i</code>th <code>Char</code> as long as <code>i</code> is a <code>Nat</code> less than the the size of the text, namely <code>tLen t</code>. Now LiquidHaskell is convinced that the call to <code>unsafeIndex</code> is safe, but of course, we have passed the burden of proof onto users of <code>charAt</code>.</p> <p>Now, if we try calling <code>charAt</code> as we did at the beginning</p> <pre>416: [Char]test = {x3 : [Char] | (((null x3)) &lt;=&gt; false) &amp;&amp; ((len x3) &gt;= 0)}[{x2 : Char | (x2 == good)}good,{x2 : Char | (x2 == bad)}bad]\n417:   where\n418:     {x2 : [Char] | (((null x2)) &lt;=&gt; false)}dog  = {x2 : [Char] | (((null x2)) &lt;=&gt; false)}[Char'd',Char'o',Char'g']\n419:     Chargood = x1:Text -&gt; {x4 : Int | (x4 &gt;= 0) &amp;&amp; (x4 &lt; (tLen x1))} -&gt; CharcharAt (x1:[Char] -&gt; {x2 : Text | ((tLen x2) == (len x1))}pack {x4 : [Char] | (((null x4)) &lt;=&gt; false) &amp;&amp; (x4 == dog) &amp;&amp; ((len x4) &gt;= 0)}dog) {x2 : Int | (x2 == (2  :  int))}2\n420:     Charbad  = x1:Text -&gt; {x4 : Int | (x4 &gt;= 0) &amp;&amp; (x4 &lt; (tLen x1))} -&gt; CharcharAt (x1:[Char] -&gt; {x2 : Text | ((tLen x2) == (len x1))}pack {x4 : [Char] | (((null x4)) &lt;=&gt; false) &amp;&amp; (x4 == dog) &amp;&amp; ((len x4) &gt;= 0)}dog) {x2 : Int | (x2 == (3  :  int))}3\n</pre> <p>we see that LiquidHaskell verifies the <code>good</code> call, but flags <code>bad</code> as unsafe.</p>","tags":["benchmarks","text"]},{"location":"blogposts/2014-05-28-pointers-gone-wild.lhs/#enforcing-sanitization","title":"Enforcing Sanitization","text":"<p>EDIT: As several folks have pointed out, the #heartbleed error was due to inputs not being properly sanitized. The above approach  ensures, at compile time, that proper sanitization has been  performed. </p> <p>To see this in action, lets write a little function that just shows the  character at a given position:</p> <pre>438: {-@ showCharAt :: t:_ -&gt; {v:Nat | v &lt; (tLen t)} -&gt; _ @-}\n439: x1:Text -&gt; {v : Int | (v &gt;= 0) &amp;&amp; (v &lt; (tLen x1))} -&gt; (IO ())showCharAt Textt {v : Int | (v &gt;= 0) &amp;&amp; (v &lt; (tLen t))}i = [Char] -&gt; (IO ())putStrLn ([Char] -&gt; (IO ())) -&gt; [Char] -&gt; (IO ())$ Char -&gt; [Char]show (Char -&gt; [Char]) -&gt; Char -&gt; [Char]$ x1:Text -&gt; {x4 : Int | (x4 &gt;= 0) &amp;&amp; (x4 &lt; (tLen x1))} -&gt; CharcharAt {x2 : Text | (x2 == t)}t {x4 : Int | (x4 == i) &amp;&amp; (x4 &gt;= 0) &amp;&amp; (x4 &lt; (tLen t))}i\n</pre> <p>Now, the following function, that correctly sanitizes is accepted</p> <pre>445: goodMain :: IO ()\n446: (IO ())goodMain \n447:   = do Texttxt &lt;- x1:[Char] -&gt; {x2 : Text | ((tLen x2) == (len x1))}pack ([Char] -&gt; Text) -&gt; (IO [Char]) -&gt; (IO Text)&lt;$&gt; {x2 : (IO [Char]) | (x2 == System.IO.getLine)}getLine\n448:        Inti   &lt;- (IO Int)readLn\n449:        if {x2 : Int | (x2 == (0  :  int))}0 x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 &lt;= x2))}&lt;= {x2 : Int | (x2 == i)}i x1:Bool\n-&gt; x2:Bool\n-&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (((Prop x1)) &amp;&amp; ((Prop x2))))}&amp;&amp; {x2 : Int | (x2 == i)}i x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 &lt; x2))}&lt; x1:Text -&gt; {x2 : Int | (x2 == (tLen x1))}tLength {x2 : Text | (x2 == txt)}txt \n450:          then x1:Text -&gt; {x5 : Int | (x5 &gt;= 0) &amp;&amp; (x5 &lt; (tLen x1))} -&gt; (IO ())showCharAt {x2 : Text | (x2 == txt)}txt {x2 : Int | (x2 == i)}i \n451:          else [Char] -&gt; (IO ())putStrLn {x2 : [Char] | ((len x2) &gt;= 0)}\"Bad Input!\"\n</pre> <p>but this function, which has insufficient sanitization, is rejected</p> <pre>457: badMain :: IO ()\n458: (IO ())badMain \n459:   = do Texttxt &lt;- x1:[Char] -&gt; {x2 : Text | ((tLen x2) == (len x1))}pack ([Char] -&gt; Text) -&gt; (IO [Char]) -&gt; (IO Text)&lt;$&gt; {x2 : (IO [Char]) | (x2 == System.IO.getLine)}getLine \n460:        Inti   &lt;- (IO Int)readLn\n461:        if {x2 : Int | (x2 == (0  :  int))}0 x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 &lt;= x2))}&lt;= {x2 : Int | (x2 == i)}i \n462:          then x1:Text -&gt; {x5 : Int | (x5 &gt;= 0) &amp;&amp; (x5 &lt; (tLen x1))} -&gt; (IO ())showCharAt {x2 : Text | (x2 == txt)}txt {x2 : Int | (x2 == i)}i \n463:          else [Char] -&gt; (IO ())putStrLn {x2 : [Char] | ((len x2) &gt;= 0)}\"Bad Input!\"\n</pre> <p>Thus, we can use LiquidHaskell to block, at compile time, any serious bleeding from pointers gone wild.</p> <ol> <li> <p>Assuming the absence of errors in the compiler and run-time...\u00a0\u21a9</p> </li> <li> <p>This function is bad for numerous reasons, least of which is that <code>Data.Text.index</code> is already provided, but stay with us...\u00a0\u21a9</p> </li> </ol>","tags":["benchmarks","text"]},{"location":"blogposts/2014-08-15-a-finer-filter.lhs/","title":"A Finer Filter","text":"<p>This morning, I came across this nice post which describes how one can write a very expressive type for  <code>filter</code> using singletons.</p> <p>Lets see how one might achieve this with abstract refinements.</p> <pre>23: \n24: {-@ LIQUID \"--short-names\" @-}\n25: \n26: module Filter (filter) where\n27: \n28: import Prelude hiding (filter)\n29: import Data.Set (Set)\n30: \n31: import Prelude hiding (filter)\n32: isPos, isEven, isOdd :: Int -&gt; Maybe Int\n33: filter, filter3 :: (a -&gt; Maybe a) -&gt; [a] -&gt; [a]\n34: \n35: {-@ measure elts :: [a] -&gt; (Set a) \n36:     elts ([])   = {v | Set_emp v }\n37:     elts (x:xs) = {v | v = Set_cup (Set_sng x) (elts xs) }\n38:   @-}\n39:  \n</pre>","tags":["abstract-refinements"]},{"location":"blogposts/2014-08-15-a-finer-filter.lhs/#goal","title":"Goal","text":"<p>What we're after is a way to write a <code>filter</code> function such that:</p> <pre>50: {-@ getPoss  :: [Int] -&gt; [Pos] @-}\n51: x1:[{x7 : Int | false}]\n-&gt; {x2 : [{x7 : Int | false}] | ((Set_sub (elts x2) (elts x1)))}getPoss      = ({x10 : Int | false} -&gt; (Maybe {x10 : Int | false}))\n-&gt; x3:[{x10 : Int | false}]\n-&gt; {x2 : [{x10 : Int | false}] | ((Set_sub (elts x2) (elts x3)))}filter x1:Int\n-&gt; (Maybe {x6 : Int | (x6 == x1) &amp;&amp; (x6 == (x1  :  int)) &amp;&amp; (x6 &gt; 0) &amp;&amp; (0 &lt; x6)})isPos\n52: \n53: {-@ getEvens :: [Int] -&gt; [Even] @-}\n54: x1:[{x7 : Int | false}]\n-&gt; {x2 : [{x7 : Int | false}] | ((Set_sub (elts x2) (elts x1)))}getEvens     = ({x10 : Int | false} -&gt; (Maybe {x10 : Int | false}))\n-&gt; x3:[{x10 : Int | false}]\n-&gt; {x2 : [{x10 : Int | false}] | ((Set_sub (elts x2) (elts x3)))}filter x1:Int\n-&gt; (Maybe {x5 : Int | (x5 == x1) &amp;&amp; (x5 == (x1  :  int)) &amp;&amp; ((x5 mod 2) == 0)})isEven\n55: \n56: {-@ getOdds  :: [Int] -&gt; [Odd] @-}\n57: x1:[{x7 : Int | false}]\n-&gt; {x2 : [{x7 : Int | false}] | ((Set_sub (elts x2) (elts x1)))}getOdds      = ({x10 : Int | false} -&gt; (Maybe {x10 : Int | false}))\n-&gt; x3:[{x10 : Int | false}]\n-&gt; {x2 : [{x10 : Int | false}] | ((Set_sub (elts x2) (elts x3)))}filter x1:Int\n-&gt; (Maybe {x6 : Int | (x6 == x1) &amp;&amp; (x6 == (x1  :  int)) &amp;&amp; ((x6 mod 2) == 1) &amp;&amp; (x6 /= 0)})isOdd\n</pre> <p>where <code>Pos</code>, <code>Even</code> and <code>Odd</code> are just subsets of <code>Int</code>:</p> <pre>63: {-@ type Pos  = {v:Int| 0 &lt; v}        @-}\n64: \n65: {-@ type Even = {v:Int| v mod 2 == 0} @-}\n66: \n67: {-@ type Odd  = {v:Int| v mod 2 /= 0} @-}\n</pre>","tags":["abstract-refinements"]},{"location":"blogposts/2014-08-15-a-finer-filter.lhs/#take-1-map-maybe","title":"Take 1: Map, maybe?","text":"<p>Bowing to the anti-boolean sentiment currently in the air, lets eschew  the classical approach where the predicates (<code>isPos</code> etc.) return <code>True</code>  or <code>False</code> and instead implement <code>filter</code> using a map.</p> <pre>78: filter1          :: (a -&gt; Maybe b) -&gt; [a] -&gt; [b]\n79: \n80: forall a b.\n(a -&gt; (Maybe b))\n-&gt; x3:[a] -&gt; {VV : [b] | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x3))}filter1 a -&gt; (Maybe b)f []     = forall a &lt;p :: a a -&gt; Prop&gt;.\n{x5 : [a]&lt;\\x6 VV -&gt; p x6&gt; | (((null x5)) &lt;=&gt; true) &amp;&amp; ((Set_emp (listElts x5))) &amp;&amp; ((Set_emp (elts x5))) &amp;&amp; ((len x5) == 0)}[]\n81: filter1 f (x:xs) = case a -&gt; (Maybe b)f {VV : a | (VV == x)}x of\n82:                      Just y  -&gt; {VV : a | (VV == y)}y x1:a\n-&gt; x2:[a]\n-&gt; {x5 : [a] | (((null x5)) &lt;=&gt; false) &amp;&amp; ((listElts x5) == (Set_cup (Set_sng x1) (listElts x2))) &amp;&amp; ((len x5) == (1 + (len x2))) &amp;&amp; ((elts x5) == (Set_cup (Set_sng x1) (elts x2)))}: forall a b.\n(a -&gt; (Maybe b))\n-&gt; x3:[a] -&gt; {VV : [b] | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x3))}filter1 a -&gt; (Maybe b)f {x3 : [a] | (x3 == xs) &amp;&amp; ((len x3) &gt;= 0)}xs \n83:                      Nothing -&gt;     forall a b.\n(a -&gt; (Maybe b))\n-&gt; x3:[a] -&gt; {VV : [b] | ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x3))}filter1 a -&gt; (Maybe b)f {x3 : [a] | (x3 == xs) &amp;&amp; ((len x3) &gt;= 0)}xs\n</pre> <p>To complete the picture, we need just define the predicates as functions returning a <code>Maybe</code>:</p> <pre>90: {- isPos          :: Int -&gt; Maybe Pos  @-}\n91: x:Int\n-&gt; (Maybe {VV : Int | (VV == x) &amp;&amp; (VV == (x  :  int)) &amp;&amp; (VV &gt; 0) &amp;&amp; (0 &lt; VV)})isPos Intx\n92:   | {x2 : Int | (x2 == x)}x x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 &gt; x2))}&gt; {x2 : Int | (x2 == (0  :  int))}0          = x1:{x13 : Int | (x13 == x) &amp;&amp; (x13 == (x  :  int)) &amp;&amp; (x13 &gt; 0) &amp;&amp; (0 &lt; x13)}\n-&gt; {x3 : (Maybe {x13 : Int | (x13 == x) &amp;&amp; (x13 == (x  :  int)) &amp;&amp; (x13 &gt; 0) &amp;&amp; (0 &lt; x13)}) | (((isJust x3)) &lt;=&gt; true) &amp;&amp; ((fromJust x3) == x1)}Just {x2 : Int | (x2 == x)}x\n93:   | otherwise      = {x2 : (Maybe {x3 : Int | false}) | (((isJust x2)) &lt;=&gt; false)}Nothing\n94: \n95: {- isEven         :: Int -&gt; Maybe Even @-}\n96: x:Int\n-&gt; (Maybe {VV : Int | (VV == x) &amp;&amp; (VV == (x  :  int)) &amp;&amp; ((VV mod 2) == 0)})isEven Intx\n97:   | {x2 : Int | (x2 == x)}x x1:Int\n-&gt; x2:Int\n-&gt; {x6 : Int | (((0 &lt;= x1) &amp;&amp; (0 &lt; x2)) =&gt; ((0 &lt;= x6) &amp;&amp; (x6 &lt; x2))) &amp;&amp; (x6 == (x1 mod x2))}`mod` {x2 : Int | (x2 == (2  :  int))}2 x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 == x2))}== {x2 : Int | (x2 == (0  :  int))}0 = x1:{x11 : Int | (x11 == x) &amp;&amp; (x11 == (x  :  int)) &amp;&amp; ((x11 mod 2) == 0)}\n-&gt; {x3 : (Maybe {x11 : Int | (x11 == x) &amp;&amp; (x11 == (x  :  int)) &amp;&amp; ((x11 mod 2) == 0)}) | (((isJust x3)) &lt;=&gt; true) &amp;&amp; ((fromJust x3) == x1)}Just {x2 : Int | (x2 == x)}x\n98:   | otherwise      = {x2 : (Maybe {x3 : Int | false}) | (((isJust x2)) &lt;=&gt; false)}Nothing\n99: \n100: {- isOdd          :: Int -&gt; Maybe Odd  @-}\n101: x:Int\n-&gt; (Maybe {VV : Int | (VV == x) &amp;&amp; (VV == (x  :  int)) &amp;&amp; ((VV mod 2) == 1) &amp;&amp; (VV /= 0)})isOdd Intx\n102:   | {x2 : Int | (x2 == x)}x x1:Int\n-&gt; x2:Int\n-&gt; {x6 : Int | (((0 &lt;= x1) &amp;&amp; (0 &lt; x2)) =&gt; ((0 &lt;= x6) &amp;&amp; (x6 &lt; x2))) &amp;&amp; (x6 == (x1 mod x2))}`mod` {x2 : Int | (x2 == (2  :  int))}2 x1:Int -&gt; x2:Int -&gt; {x2 : Bool | (((Prop x2)) &lt;=&gt; (x1 /= x2))}/= {x2 : Int | (x2 == (0  :  int))}0 = x1:{x13 : Int | (x13 == x) &amp;&amp; (x13 == (x  :  int)) &amp;&amp; ((x13 mod 2) == 1) &amp;&amp; (x13 /= 0)}\n-&gt; {x3 : (Maybe {x13 : Int | (x13 == x) &amp;&amp; (x13 == (x  :  int)) &amp;&amp; ((x13 mod 2) == 1) &amp;&amp; (x13 /= 0)}) | (((isJust x3)) &lt;=&gt; true) &amp;&amp; ((fromJust x3) == x1)}Just {x2 : Int | (x2 == x)}x\n103:   | otherwise      = {x2 : (Maybe {x3 : Int | false}) | (((isJust x2)) &lt;=&gt; false)}Nothing\n</pre> <p>and now, we can achieve our goal!</p> <pre>109: {-@ getPoss1 :: [Int] -&gt; [Pos] @-}\n110: [Int] -&gt; [{v : Int | (0 &lt; v)}]getPoss1     = (Int -&gt; (Maybe {x14 : Int | (x14 &gt; 0) &amp;&amp; (0 &lt; x14)}))\n-&gt; x3:[Int]\n-&gt; {x3 : [{x14 : Int | (x14 &gt; 0) &amp;&amp; (0 &lt; x14)}] | ((len x3) &gt;= 0) &amp;&amp; ((len x3) &lt;= (len x3))}filter1 x1:Int\n-&gt; (Maybe {x6 : Int | (x6 == x1) &amp;&amp; (x6 == (x1  :  int)) &amp;&amp; (x6 &gt; 0) &amp;&amp; (0 &lt; x6)})isPos\n111: \n112: {-@ getEvens1 :: [Int] -&gt; [Even] @-}\n113: [Int] -&gt; [{v : Int | ((v mod 2) == 0)}]getEvens1    = (Int -&gt; (Maybe {x12 : Int | ((x12 mod 2) == 0)}))\n-&gt; x3:[Int]\n-&gt; {x3 : [{x12 : Int | ((x12 mod 2) == 0)}] | ((len x3) &gt;= 0) &amp;&amp; ((len x3) &lt;= (len x3))}filter1 x1:Int\n-&gt; (Maybe {x5 : Int | (x5 == x1) &amp;&amp; (x5 == (x1  :  int)) &amp;&amp; ((x5 mod 2) == 0)})isEven\n114: \n115: {-@ getOdds1 :: [Int] -&gt; [Odd] @-}\n116: [Int] -&gt; [{v : Int | ((v mod 2) == 1)}]getOdds1     = (Int -&gt; (Maybe {x14 : Int | ((x14 mod 2) == 1) &amp;&amp; (x14 /= 0)}))\n-&gt; x3:[Int]\n-&gt; {x3 : [{x14 : Int | ((x14 mod 2) == 1) &amp;&amp; (x14 /= 0)}] | ((len x3) &gt;= 0) &amp;&amp; ((len x3) &lt;= (len x3))}filter1 x1:Int\n-&gt; (Maybe {x6 : Int | (x6 == x1) &amp;&amp; (x6 == (x1  :  int)) &amp;&amp; ((x6 mod 2) == 1) &amp;&amp; (x6 /= 0)})isOdd\n</pre> <p>The Subset Guarantee</p> <p>Well that was easy! Or was it?</p> <p>I fear we've cheated a little bit.</p> <p>One of the nice things about the classical <code>filter</code> is that by eyeballing the signature:</p> <pre>129: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]\n</pre> <p>we are guaranteed, via parametricity, that the output list's elements are a subset of the input list's elements. The signature for our new-fangled</p> <pre>136: filter1 :: (a -&gt; Maybe b) -&gt; [a] -&gt; [b]\n</pre> <p>yields no such guarantee!</p> <p>In this case, things work out, because in each case, LiquidHaskell instantiates the type variables <code>a</code> and <code>b</code> in the signature of <code>filter1</code> suitably:</p> <ul> <li>In <code>getPoss</code> LH instantiates <code>a := Int</code> and <code>b := Pos</code></li> <li>In <code>getEvens</code> LH instantiates <code>a := Int</code> and <code>b := Even</code></li> <li>In <code>getOdds</code> LH instantiates <code>a := Int</code> and <code>b := Odd</code></li> </ul> <p>(Hover over the different instances of <code>filter1</code> above to confirm this.)</p> <p>But in general, we'd rather not lose the nice \"subset\" guarantee that the classical <code>filter</code> provides.</p>","tags":["abstract-refinements"]},{"location":"blogposts/2014-08-15-a-finer-filter.lhs/#take-2-one-type-variable","title":"Take 2: One Type Variable","text":"<p>Easy enough! Why do we need two type variables anyway?</p> <pre>160: filter2          :: (a -&gt; Maybe a) -&gt; [a] -&gt; [a]\n161: \n162: forall a.\n(x2:a -&gt; (Maybe {VV : a | (VV == x2)}))\n-&gt; x3:[a]\n-&gt; {VV : [a] | ((Set_sub (elts VV) (elts x3))) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x3))}filter2 x1:a -&gt; (Maybe {VV : a | (VV == x1)})f []     = forall a &lt;p :: a a -&gt; Prop&gt;.\n{x5 : [a]&lt;\\x6 VV -&gt; p x6&gt; | (((null x5)) &lt;=&gt; true) &amp;&amp; ((Set_emp (listElts x5))) &amp;&amp; ((Set_emp (elts x5))) &amp;&amp; ((len x5) == 0)}[]\n163: filter2 f (x:xs) = case x1:a -&gt; (Maybe {VV : a | (VV == x1)})f {VV : a | (VV == x)}x of\n164:                      Just y  -&gt; {VV : a | (VV == y) &amp;&amp; (VV == x)}y x1:a\n-&gt; x2:[a]\n-&gt; {x5 : [a] | (((null x5)) &lt;=&gt; false) &amp;&amp; ((listElts x5) == (Set_cup (Set_sng x1) (listElts x2))) &amp;&amp; ((len x5) == (1 + (len x2))) &amp;&amp; ((elts x5) == (Set_cup (Set_sng x1) (elts x2)))}: forall a.\n(x2:a -&gt; (Maybe {VV : a | (VV == x2)}))\n-&gt; x3:[a]\n-&gt; {VV : [a] | ((Set_sub (elts VV) (elts x3))) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x3))}filter2 x1:a -&gt; (Maybe {VV : a | (VV == x1)})f {x3 : [a] | (x3 == xs) &amp;&amp; ((len x3) &gt;= 0)}xs \n165:                      Nothing -&gt;     forall a.\n(x2:a -&gt; (Maybe {VV : a | (VV == x2)}))\n-&gt; x3:[a]\n-&gt; {VV : [a] | ((Set_sub (elts VV) (elts x3))) &amp;&amp; ((len VV) &gt;= 0) &amp;&amp; ((len VV) &lt;= (len x3))}filter2 x1:a -&gt; (Maybe {VV : a | (VV == x1)})f {x3 : [a] | (x3 == xs) &amp;&amp; ((len x3) &gt;= 0)}xs\n</pre> <p>There! Now the <code>f</code> is forced to take or leave its input <code>x</code>,  and so we can breathe easy knowing that <code>filter2</code> returns a  subset of its inputs.</p> <p>But...</p> <pre>175: {-@ getPoss2 :: [Int] -&gt; [Pos] @-}\n176: [Int] -&gt; [{v : Int | (0 &lt; v)}]getPoss2     = (x2:Int -&gt; (Maybe {x13 : Int | (x13 == x2)}))\n-&gt; x3:[Int]\n-&gt; {x4 : [Int] | ((Set_sub (elts x4) (elts x3))) &amp;&amp; ((len x4) &gt;= 0) &amp;&amp; ((len x4) &lt;= (len x3))}filter2 x1:Int\n-&gt; (Maybe {x6 : Int | (x6 == x1) &amp;&amp; (x6 == (x1  :  int)) &amp;&amp; (x6 &gt; 0) &amp;&amp; (0 &lt; x6)})isPos\n177: \n178: {-@ getEvens2 :: [Int] -&gt; [Even] @-}\n179: [Int] -&gt; [{v : Int | ((v mod 2) == 0)}]getEvens2    = (x2:Int -&gt; (Maybe {x13 : Int | (x13 == x2)}))\n-&gt; x3:[Int]\n-&gt; {x4 : [Int] | ((Set_sub (elts x4) (elts x3))) &amp;&amp; ((len x4) &gt;= 0) &amp;&amp; ((len x4) &lt;= (len x3))}filter2 x1:Int\n-&gt; (Maybe {x5 : Int | (x5 == x1) &amp;&amp; (x5 == (x1  :  int)) &amp;&amp; ((x5 mod 2) == 0)})isEven\n180: \n181: {-@ getOdds2 :: [Int] -&gt; [Odd] @-}\n182: [Int] -&gt; [{v : Int | ((v mod 2) == 1)}]getOdds2     = (x2:Int -&gt; (Maybe {x13 : Int | (x13 == x2)}))\n-&gt; x3:[Int]\n-&gt; {x4 : [Int] | ((Set_sub (elts x4) (elts x3))) &amp;&amp; ((len x4) &gt;= 0) &amp;&amp; ((len x4) &lt;= (len x3))}filter2 x1:Int\n-&gt; (Maybe {x6 : Int | (x6 == x1) &amp;&amp; (x6 == (x1  :  int)) &amp;&amp; ((x6 mod 2) == 1) &amp;&amp; (x6 /= 0)})isOdd\n</pre> <p>Yikes, LH is not impressed -- the red highlight indicates that LH is not convinced that the functions have the specified types.</p> <p>Perhaps you know why already?</p> <p>Since we used the same type variable <code>a</code> for both the  input and output, LH must instantiate <code>a</code> with a type that  matches both the input and output, i.e. is a super-type of both, which is simply <code>Int</code> in all the cases. </p> <p>Consequently, we get the errors above -- \"expected <code>Pos</code> but got <code>Int</code>\".</p>","tags":["abstract-refinements"]},{"location":"blogposts/2014-08-15-a-finer-filter.lhs/#take-3-add-abstract-refinement","title":"Take 3: Add Abstract Refinement","text":"<p>What we need is a generic way of specifying that the  output of the predicate is not just an <code>a</code> but an <code>a</code>  that also enjoys whatever property we are filtering for. </p> <p>This sounds like a job for abstract refinements which let us parameterize a signature over its refinements:</p> <pre>208: {-@ filter3      :: forall a &lt;p :: a -&gt; Prop&gt;.\n209:                       (a -&gt; Maybe a&lt;p&gt;) -&gt; [a] -&gt; [a&lt;p&gt;] @-}\n210: forall a &lt;p :: a -&gt; Prop&gt;.\n(a -&gt; (Maybe {VV : a&lt;p&gt; | true})) -&gt; [a] -&gt; [{VV : a&lt;p&gt; | true}]filter3 a -&gt; (Maybe {VV : a | ((papp1 p VV))})f []     = forall a &lt;p :: a a -&gt; Prop&gt;.\n{x5 : [a]&lt;\\x6 VV -&gt; p x6&gt; | (((null x5)) &lt;=&gt; true) &amp;&amp; ((Set_emp (listElts x5))) &amp;&amp; ((Set_emp (elts x5))) &amp;&amp; ((len x5) == 0)}[]\n211: filter3 f (x:xs) = case a -&gt; (Maybe {VV : a | ((papp1 p VV))})f {VV : a | (VV == x)}x of\n212:                      Just x'  -&gt; {VV : a | ((papp1 p VV)) &amp;&amp; (VV == x')}x' x1:{VV : a | ((papp1 p VV))}\n-&gt; x2:[{VV : a | ((papp1 p VV))}]&lt;\\_ VV -&gt; ((papp1 p VV))&gt;\n-&gt; {x5 : [{VV : a | ((papp1 p VV))}]&lt;\\_ VV -&gt; ((papp1 p VV))&gt; | (((null x5)) &lt;=&gt; false) &amp;&amp; ((listElts x5) == (Set_cup (Set_sng x1) (listElts x2))) &amp;&amp; ((len x5) == (1 + (len x2))) &amp;&amp; ((elts x5) == (Set_cup (Set_sng x1) (elts x2)))}: forall a &lt;p :: a -&gt; Prop&gt;.\n(a -&gt; (Maybe {VV : a&lt;p&gt; | true})) -&gt; [a] -&gt; [{VV : a&lt;p&gt; | true}]filter3 a -&gt; (Maybe {VV : a | ((papp1 p VV))})f {x3 : [a] | (x3 == xs) &amp;&amp; ((len x3) &gt;= 0)}xs \n213:                      Nothing -&gt;       forall a &lt;p :: a -&gt; Prop&gt;.\n(a -&gt; (Maybe {VV : a&lt;p&gt; | true})) -&gt; [a] -&gt; [{VV : a&lt;p&gt; | true}]filter3 a -&gt; (Maybe {VV : a | ((papp1 p VV))})f {x3 : [a] | (x3 == xs) &amp;&amp; ((len x3) &gt;= 0)}xs\n</pre> <p>Now, we've decoupled the filter-property from the type variable <code>a</code>.</p> <p>The input still is a mere <code>a</code>, but the output is an <code>a</code> with bells on, specifically, which satisfies the (abstract) refinement <code>p</code>.</p> <p>Voila!</p> <pre>224: {-@ getPoss3  :: [Int] -&gt; [Pos] @-}\n225: [Int] -&gt; [{v : Int | (0 &lt; v)}]getPoss3      = (Int -&gt; (Maybe {x13 : Int | (x13 &gt; 0) &amp;&amp; (0 &lt; x13)}))\n-&gt; [Int] -&gt; [{x13 : Int | (x13 &gt; 0) &amp;&amp; (0 &lt; x13)}]filter3 x1:Int\n-&gt; (Maybe {x6 : Int | (x6 == x1) &amp;&amp; (x6 == (x1  :  int)) &amp;&amp; (x6 &gt; 0) &amp;&amp; (0 &lt; x6)})isPos\n226: \n227: {-@ getEvens3 :: [Int] -&gt; [Even] @-}\n228: [Int] -&gt; [{v : Int | ((v mod 2) == 0)}]getEvens3     = (Int -&gt; (Maybe {x11 : Int | ((x11 mod 2) == 0)}))\n-&gt; [Int] -&gt; [{x11 : Int | ((x11 mod 2) == 0)}]filter3 x1:Int\n-&gt; (Maybe {x5 : Int | (x5 == x1) &amp;&amp; (x5 == (x1  :  int)) &amp;&amp; ((x5 mod 2) == 0)})isEven\n229: \n230: {-@ getOdds3  :: [Int] -&gt; [Odd] @-}\n231: [Int] -&gt; [{v : Int | ((v mod 2) == 1)}]getOdds3      = (Int -&gt; (Maybe {x13 : Int | ((x13 mod 2) == 1) &amp;&amp; (x13 /= 0)}))\n-&gt; [Int] -&gt; [{x13 : Int | ((x13 mod 2) == 1) &amp;&amp; (x13 /= 0)}]filter3 x1:Int\n-&gt; (Maybe {x6 : Int | (x6 == x1) &amp;&amp; (x6 == (x1  :  int)) &amp;&amp; ((x6 mod 2) == 1) &amp;&amp; (x6 /= 0)})isOdd\n</pre> <p>Now, LH happily accepts each of the above.</p> <p>At each use of <code>filter</code> LH separately instantiates the <code>a</code> and the <code>p</code>. In each case, the <code>a</code> is just <code>Int</code> but the <code>p</code> is instantiated as:</p> <ul> <li>In <code>getPoss</code> LH instantiates <code>p := \\v -&gt; 0 &lt;= v</code></li> <li>In <code>getEvens</code> LH instantiates <code>p := \\v -&gt; v mod 2 == 0</code></li> <li>In <code>getOdds</code> LH instantiates <code>p := \\v -&gt; v mod 2 /= 0</code></li> </ul> <p>That is, in each case, LH instantiates <code>p</code> with the refinement that describes the output type we are looking for.</p> <p>Edit: At this point, I was ready to go to bed, and so happily  declared victory and turned in. The next morning, mypetclone graciously pointed out my folly: the signature for <code>filter3</code> makes no guarantees about the subset property. In fact, </p> <pre>252: [Integer] -&gt; [Integer]doubles = (Integer -&gt; (Maybe Integer)) -&gt; [Integer] -&gt; [Integer]filter3 (Integer -&gt; (Maybe Integer)\\Integerx -&gt; x1:Integer\n-&gt; {x3 : (Maybe Integer) | (((isJust x3)) &lt;=&gt; true) &amp;&amp; ((fromJust x3) == x1)}Just ({x2 : Integer | (x2 == x)}x x1:Integer -&gt; x2:Integer -&gt; {x4 : Integer | (x4 == (x1 + x2))}+ {x2 : Integer | (x2 == x)}x)) \n</pre> <p>typechecks just fine, while <code>doubles</code> clearly violates the subset property. </p>","tags":["abstract-refinements"]},{"location":"blogposts/2014-08-15-a-finer-filter.lhs/#take-4","title":"Take 4:","text":"<p>I suppose the moral is that it may be tricky -- for me at least! -- to read more into a type than what it actually says. Fortunately, with refinements, our types can say quite a lot.</p> <p>In particular, lets make the subset property explicit, by</p> <ol> <li>Requiring the predicate return its input (or nothing), and,</li> <li>Ensuring  the output is indeed a subset of the inputs.</li> </ol> <pre>270: {-@ filter      :: forall a &lt;p :: a -&gt; Prop&gt;.\n271:                        (x:a -&gt; Maybe {v:a&lt;p&gt; | v = x})\n272:                     -&gt; xs:[a]\n273:                     -&gt; {v:[a&lt;p&gt;] | Set_sub (elts v) (elts xs)} @-}\n274: \n275: forall a &lt;p :: a -&gt; Prop&gt;.\n(x2:a -&gt; (Maybe {VV : a&lt;p&gt; | (VV == x2)}))\n-&gt; x3:[a]\n-&gt; {v : [{VV : a&lt;p&gt; | true}] | ((Set_sub (elts v) (elts x3)))}filter x1:a -&gt; (Maybe {VV : a | ((papp1 p VV)) &amp;&amp; (VV == x1)})f []     = forall a &lt;p :: a a -&gt; Prop&gt;.\n{x5 : [a]&lt;\\x6 VV -&gt; p x6&gt; | (((null x5)) &lt;=&gt; true) &amp;&amp; ((Set_emp (listElts x5))) &amp;&amp; ((Set_emp (elts x5))) &amp;&amp; ((len x5) == 0)}[]\n276: filter f (x:xs) = case x1:a -&gt; (Maybe {VV : a | ((papp1 p VV)) &amp;&amp; (VV == x1)})f {VV : a | (VV == x)}x of\n277:                     Just x'  -&gt; {VV : a | ((papp1 p VV)) &amp;&amp; (VV == x) &amp;&amp; (VV == x')}x' x1:{VV : a | ((papp1 p VV))}\n-&gt; x2:[{VV : a | ((papp1 p VV))}]&lt;\\_ VV -&gt; ((papp1 p VV))&gt;\n-&gt; {x5 : [{VV : a | ((papp1 p VV))}]&lt;\\_ VV -&gt; ((papp1 p VV))&gt; | (((null x5)) &lt;=&gt; false) &amp;&amp; ((listElts x5) == (Set_cup (Set_sng x1) (listElts x2))) &amp;&amp; ((len x5) == (1 + (len x2))) &amp;&amp; ((elts x5) == (Set_cup (Set_sng x1) (elts x2)))}: forall a &lt;p :: a -&gt; Prop&gt;.\n(x2:a -&gt; (Maybe {VV : a&lt;p&gt; | (VV == x2)}))\n-&gt; x3:[a]\n-&gt; {v : [{VV : a&lt;p&gt; | true}] | ((Set_sub (elts v) (elts x3)))}filter x1:a -&gt; (Maybe {VV : a | ((papp1 p VV)) &amp;&amp; (VV == x1)})f {x3 : [a] | (x3 == xs) &amp;&amp; ((len x3) &gt;= 0)}xs \n278:                     Nothing -&gt;       forall a &lt;p :: a -&gt; Prop&gt;.\n(x2:a -&gt; (Maybe {VV : a&lt;p&gt; | (VV == x2)}))\n-&gt; x3:[a]\n-&gt; {v : [{VV : a&lt;p&gt; | true}] | ((Set_sub (elts v) (elts x3)))}filter x1:a -&gt; (Maybe {VV : a | ((papp1 p VV)) &amp;&amp; (VV == x1)})f {x3 : [a] | (x3 == xs) &amp;&amp; ((len x3) &gt;= 0)}xs\n</pre> <p>where <code>elts</code> describes the set of elements in a list.</p> <p>Note: The implementation of each of the above <code>filter</code> functions are the same; they only differ in their type specification.</p>","tags":["abstract-refinements"]},{"location":"blogposts/2014-08-15-a-finer-filter.lhs/#conclusion","title":"Conclusion","text":"<p>And so, using abstract refinements, we've written a <code>filter</code> whose signature guarantees:</p> <ul> <li>The outputs must be a subset of the inputs, and</li> <li>The outputs indeed satisfy the property being filtered for.</li> </ul> <p>Another thing that I've learnt from this exercise, is that the old  school <code>Boolean</code> approach has its merits. Take a look at the clever  \"latent predicates\" technique of Tobin-Hochstadt and Felleisen or this lovely new paper by Kaki and Jagannathan which shows how refinements can be further generalized to make Boolean filters fine.</p>","tags":["abstract-refinements"]},{"location":"blogposts/2015-01-30-okasakis-lazy-queue.lhs/","title":"Okasaki's Lazy Queues","text":"<p>The \"Hello World!\" example for fancy type systems is probably the sized vector or list <code>append</code> function (\"The output has size equal to the sum of the inputs!\").  One the one hand, it is perfect: simple enough to explain without pages of code, yet complex enough to show off whats cool about dependency. On the other hand, like the sweater I'm sporting right now, it's a bit well-worn and worse, was never wholly convincing (\"Why do I care what the size of the output list is anyway?\")</p> <p>Recently, I came across a nice example that is almost as simple, but is also well motivated: Okasaki's beautiful Lazy Amortized Queues.  This structure leans heavily on an invariant to provide fast insertion and deletion. Let's see how to enforce that invariant with LiquidHaskell.</p> <pre>30: {-@ LIQUID \"--no-termination\" @-}\n31: {-@ LIQUID \"--total\"          @-}\n32: {-@ LIQUID \"--maxparams=3\"    @-}\n33: \n34: module LazyQueue (Queue, insert, remove, emp) where\n35: \n36: import Prelude hiding (length)\n37: \n38: -- | Size function actually returns the size: (Duh!)\n39: \n40: {-@ size :: q:SList a -&gt; {v:Nat | v = size q} @-}\n41: data Queue a = Q  { forall a. (LazyQueue.Queue a) -&gt; (LazyQueue.SList a)front :: SList a\n42:                   , forall a. (LazyQueue.Queue a) -&gt; (LazyQueue.SList a)back  :: SList a\n43:                   }\n44: \n45: -- Source: Okasaki, JFP 1995\n46: -- http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp95queue.pdf\n47: \n</pre>","tags":["measures"]},{"location":"blogposts/2015-01-30-okasakis-lazy-queue.lhs/#queues","title":"Queues","text":"<p>A queue is a structure into which we can <code>insert</code> and <code>remove</code> data such that the order in which the data is removed is the same as the order in which it was inserted.</p> <p></p> <p>To implement a queue efficiently one needs to have rapid access to both the \"head\" as well as the \"tail\" because we <code>remove</code> elements from former and <code>insert</code> elements into the latter. This is quite straightforward with explicit pointers and mutation -- one uses an old school linked list and maintains pointers to the head and the tail. But can we implement the structure efficiently without having stoop so low?</p>","tags":["measures"]},{"location":"blogposts/2015-01-30-okasakis-lazy-queue.lhs/#queues-pair-of-lists","title":"Queues = Pair of Lists","text":"<p>Almost two decades ago, Chris Okasaki came up with a very cunning way to implement queues using a pair of lists -- let's call them <code>front</code> and <code>back</code> which represent the corresponding parts of the Queue.</p> <ul> <li>To <code>insert</code> elements, we just cons them onto the <code>back</code> list,</li> <li>To <code>remove</code> elements, we just un-cons them from the <code>front</code> list.</li> </ul> <p></p> <p>The catch is that we need to shunt elements from the back to the front every so often, e.g. when</p> <ol> <li>a <code>remove</code> call is triggered, and</li> <li>the <code>front</code> list is empty,</li> </ol> <p>We can transfer the elements from the <code>back</code> to the <code>front</code>.</p> <p></p> <p>Okasaki observed that every element is only moved once from the front to the back; hence, the time for <code>insert</code> and <code>lookup</code> could be <code>O(1)</code> when amortized over all the operations. Awesome, right?!</p> <p>Almost. Some set of unlucky <code>remove</code> calls (which occur when the <code>front</code> is empty) are stuck paying the bill. They have a rather high latency up to <code>O(n)</code> where <code>n</code> is the total number of operations. Oops.</p>","tags":["measures"]},{"location":"blogposts/2015-01-30-okasakis-lazy-queue.lhs/#queue-balanced-lazy-lists","title":"Queue = Balanced Lazy Lists","text":"<p>This is where Okasaki's beautiful insights kick in. Okasaki observed that all we need to do is to enforce a simple invariant:</p> <p>Invariant: Size of <code>front</code> &gt;= Size of <code>back</code></p> <p>Now, if the lists are lazy i.e. only constructed as the head value is demanded, then a single <code>remove</code> needs only a tiny <code>O(log n)</code> in the worst case, and so no single <code>remove</code> is stuck paying the bill.</p> <p>Let's see how to represent these Queues and ensure the crucial invariant(s) with LiquidHaskell. What we need are the following ingredients:</p> <ol> <li> <p>A type for <code>List</code>s, and a way to track their <code>size</code>,</p> </li> <li> <p>A type for <code>Queue</code>s which encodes the balance invariant -- ``front longer than back\",</p> </li> <li> <p>A way to implement the <code>insert</code>, <code>remove</code> and <code>transfer</code> operations.</p> </li> </ol>","tags":["measures"]},{"location":"blogposts/2015-01-30-okasakis-lazy-queue.lhs/#sized-lists","title":"Sized Lists","text":"<p>The first part is super easy. Let's define a type:</p> <pre>127: data SList a = SL { forall a.\nx1:(LazyQueue.SList a)\n-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}size :: Int, forall a. (LazyQueue.SList a) -&gt; [a]elems :: [a]}\n</pre> <p>We have a special field that saves the <code>size</code> because otherwise, we have a linear time computation that wrecks Okasaki's careful analysis. (Actually, he presents a variant which does not require saving the size as well, but that's for another day.)</p> <p>But how can we be sure that <code>size</code> is indeed the real size of <code>elems</code>?</p> <p>Let's write a function to measure the real size:</p> <pre>140: {-@ measure realSize @-}\n141: realSize      :: [a] -&gt; Int\n142: forall a. x1:[a] -&gt; {VV : GHC.Types.Int | VV == realSize x1}realSize []     = x1:GHC.Prim.Int# -&gt; {v : GHC.Types.Int | v == (x1  :  int)}0\n143: realSize (_:xs) = {v : GHC.Types.Int | v == (1  :  int)}1 x1:GHC.Types.Int\n-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ forall a. x1:[a] -&gt; {VV : GHC.Types.Int | VV == realSize x1}realSize {v : [a] | v == xs &amp;&amp; len v &gt;= 0}xs\n</pre> <p>and now, we can simply specify a refined type for <code>SList</code> that ensures that the real size is saved in the <code>size</code> field:</p> <pre>150: {-@ data SList a = SL {\n151:        size  :: Nat \n152:      , elems :: {v:[a] | realSize v = size}\n153:      }\n154:   @-}\n</pre> <p>As a sanity check, consider this:</p> <pre>160: {VV : (LazyQueue.SList {VV : [GHC.Types.Char] | len VV &gt;= 0}) | size VV &gt; 0}okList  = x1:{v : GHC.Types.Int | v &gt;= 0}\n-&gt; x2:{v : [{v : [GHC.Types.Char] | len v &gt;= 0}] | realSize v == x1}\n-&gt; {v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | elems v == x2 &amp;&amp; size v == x1}SL {v : GHC.Types.Int | v == (1  :  int)}1 {v : [{v : [GHC.Types.Char] | len v &gt;= 0}]&lt;\\_ VV -&gt; false&gt; | null v &lt;=&gt; false &amp;&amp; len v &gt;= 0}[{v : [GHC.Types.Char] | len v &gt;= 0}\"cat\"]    -- accepted\n161: \n162: forall a. (LazyQueue.SList a)badList = x1:{v : GHC.Types.Int | v &gt;= 0}\n-&gt; x2:{v : [a] | realSize v == x1}\n-&gt; {v : (LazyQueue.SList a) | elems v == x2 &amp;&amp; size v == x1}SL {v : GHC.Types.Int | v == (1  :  int)}1 {v : [a] | null v &lt;=&gt; true &amp;&amp; realSize v == 0 &amp;&amp; len v == 0 &amp;&amp; len v &gt;= 0}[]         -- rejected\n</pre> <p>It is helpful to define a few aliases for <code>SList</code>s of a size <code>N</code> and non-empty <code>SList</code>s:</p> <pre>169: -- | SList of size N\n170: \n171: {-@ type SListN a N = {v:SList a | size v = N} @-}\n172: \n173: -- | Non-Empty SLists:\n174: \n175: {-@ type NEList a = {v:SList a | size v &gt; 0} @-}\n176: \n</pre> <p>Finally, we can define a basic API for <code>SList</code>.</p> <p>To Construct lists, we use <code>nil</code> and <code>cons</code>:</p> <pre>184: {-@ nil          :: SListN a 0  @-}\n185: forall a. {v : (LazyQueue.SList a) | size v == 0}nil              = x1:{v : GHC.Types.Int | v &gt;= 0}\n-&gt; x2:{v : [a] | realSize v == x1}\n-&gt; {v : (LazyQueue.SList a) | elems v == x2 &amp;&amp; size v == x1}SL {v : GHC.Types.Int | v == (0  :  int)}0 {v : [a] | null v &lt;=&gt; true &amp;&amp; realSize v == 0 &amp;&amp; len v == 0 &amp;&amp; len v &gt;= 0}[]\n186: \n187: {-@ cons         :: a -&gt; xs:SList a -&gt; SListN a {size xs + 1}   @-}\n188: forall a.\na\n-&gt; x2:(LazyQueue.SList a)\n-&gt; {v : (LazyQueue.SList a) | size v == size x2 + 1}cons ax (SL n xs) = x1:{v : GHC.Types.Int | v &gt;= 0}\n-&gt; x2:{v : [a] | realSize v == x1}\n-&gt; {v : (LazyQueue.SList a) | elems v == x2 &amp;&amp; size v == x1}SL ({v : GHC.Types.Int | v == n &amp;&amp; v &gt;= 0}nx1:GHC.Types.Int\n-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+{v : GHC.Types.Int | v == (1  :  int)}1) ({VV : a | VV == x}xx1:a\n-&gt; x2:[a]\n-&gt; {v : [a] | null v &lt;=&gt; false &amp;&amp; xListSelector v == x1 &amp;&amp; realSize v == 1 + realSize x2 &amp;&amp; xsListSelector v == x2 &amp;&amp; len v == 1 + len x2}:{v : [a] | v == xs &amp;&amp; realSize v == n &amp;&amp; len v &gt;= 0}xs)\n</pre> <p>To Destruct lists, we have <code>hd</code> and <code>tl</code>.</p> <pre>194: {-@ tl           :: xs:NEList a -&gt; SListN a {size xs - 1}  @-}\n195: forall a.\nx1:{v : (LazyQueue.SList a) | size v &gt; 0}\n-&gt; {v : (LazyQueue.SList a) | size v == size x1 - 1}tl (SL n (_:xs)) = x1:{v : GHC.Types.Int | v &gt;= 0}\n-&gt; x2:{v : [a] | realSize v == x1}\n-&gt; {v : (LazyQueue.SList a) | elems v == x2 &amp;&amp; size v == x1}SL ({v : GHC.Types.Int | v == n &amp;&amp; v &gt;= 0}nx1:GHC.Types.Int\n-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}-{v : GHC.Types.Int | v == (1  :  int)}1) {v : [a] | v == xs &amp;&amp; len v &gt;= 0}xs\n196: \n197: {-@ hd           :: xs:NEList a -&gt; a @-}\n198: forall a. {v : (LazyQueue.SList a) | size v &gt; 0} -&gt; ahd (SL _ (x:_))  = {VV : a | VV == x}x \n</pre> <p>Don't worry, they are perfectly safe as LiquidHaskell will make sure we only call these operators on non-empty <code>SList</code>s. For example,</p> <pre>205: {v : [GHC.Types.Char] | len v &gt;= 0}okHd  = {v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | size v &gt; 0}\n-&gt; {v : [GHC.Types.Char] | len v &gt;= 0}hd {v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | v == LazyQueue.okList &amp;&amp; size v &gt; 0}okList       -- accepted\n206: \n207: {VV : [GHC.Types.Char] | len VV &gt;= 0}badHd = {v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | size v &gt; 0}\n-&gt; {v : [GHC.Types.Char] | len v &gt;= 0}hd (x1:{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | size v &gt; 0}\n-&gt; {v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | size v == size x1 - 1}tl {v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | v == LazyQueue.okList &amp;&amp; size v &gt; 0}okList)  -- rejected\n</pre>","tags":["measures"]},{"location":"blogposts/2015-01-30-okasakis-lazy-queue.lhs/#queue-type","title":"Queue Type","text":"<p>Now, it is quite straightforward to define the <code>Queue</code> type, as a pair of lists, <code>front</code> and <code>back</code>, such that the latter is always smaller than the former:</p> <pre>218: {-@ data Queue a = Q {\n219:        front :: SList a \n220:      , back  :: SListLE a (size front)\n221:      }\n222:   @-}\n</pre> <p>Where the alias <code>SListLE a L</code> corresponds to lists with less than <code>N</code> elements:</p> <pre>228: {-@ type SListLE a N = {v:SList a | size v &lt;= N} @-}\n</pre> <p>As a quick check, notice that we cannot represent illegal Queues:</p> <pre>234: {VV : (LazyQueue.Queue [GHC.Types.Char]) | 0 &lt; qsize VV}okQ  = x1:(LazyQueue.SList [GHC.Types.Char])\n-&gt; x2:{v : (LazyQueue.SList [GHC.Types.Char]) | size v &lt;= size x1}\n-&gt; {v : (LazyQueue.Queue [GHC.Types.Char]) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}Q {v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | v == LazyQueue.okList &amp;&amp; size v &gt; 0}okList {v : (LazyQueue.SList [GHC.Types.Char]) | size v == 0}nil  -- accepted, |front| &gt; |back| \n235: \n236: {VV : (LazyQueue.Queue [GHC.Types.Char]) | 0 &lt; qsize VV}badQ = x1:(LazyQueue.SList [GHC.Types.Char])\n-&gt; x2:{v : (LazyQueue.SList [GHC.Types.Char]) | size v &lt;= size x1}\n-&gt; {v : (LazyQueue.Queue [GHC.Types.Char]) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}Q {v : (LazyQueue.SList [GHC.Types.Char]) | size v == 0}nil {v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | v == LazyQueue.okList &amp;&amp; size v &gt; 0}okList  -- rejected, |front| &lt; |back|\n</pre> <p>To Measure Queue Size let us define a function</p> <pre>242: {-@ measure qsize @-}\n243: qsize         :: Queue a -&gt; Int\n244: forall a.\nx1:(LazyQueue.Queue a) -&gt; {VV : GHC.Types.Int | VV == qsize x1}qsize (Q l r) = x1:(LazyQueue.SList a)\n-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}size {v : (LazyQueue.SList a) | v == l}l x1:GHC.Types.Int\n-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ x1:(LazyQueue.SList a)\n-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}size {v : (LazyQueue.SList a) | v == r &amp;&amp; size v &lt;= size l}r\n</pre> <p>This will prove helpful to define <code>Queue</code>s of a given size <code>N</code> and non-empty <code>Queue</code>s (from which values can be safely removed.)</p> <pre>251: {-@ type QueueN a N = {v:Queue a | N = qsize v} @-}\n252: {-@ type NEQueue a  = {v:Queue a | 0 &lt; qsize v} @-}\n</pre>","tags":["measures"]},{"location":"blogposts/2015-01-30-okasakis-lazy-queue.lhs/#queue-operations","title":"Queue Operations","text":"<p>Almost there! Now all that remains is to define the <code>Queue</code> API. The code below is more or less identical to Okasaki's (I prefer <code>front</code> and <code>back</code> to his <code>left</code> and <code>right</code>.)</p> <p>The Empty Queue is simply one where both <code>front</code> and <code>back</code> are <code>nil</code>.</p> <pre>267: {-@ emp :: QueueN a 0 @-}\n268: forall a. {v : (LazyQueue.Queue a) | 0 == qsize v}emp = x1:(LazyQueue.SList a)\n-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1}\n-&gt; {v : (LazyQueue.Queue a) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}Q {v : (LazyQueue.SList a) | size v == 0}nil {v : (LazyQueue.SList a) | size v == 0}nil\n</pre> <p>To Insert an element we just <code>cons</code> it to the <code>back</code> list, and call the smart constructor <code>makeq</code> to ensure that the balance invariant holds:</p> <pre>275: {-@ insert       :: a -&gt; q:Queue a -&gt; QueueN a {qsize q + 1}   @-}\n276: forall a.\na\n-&gt; x2:(LazyQueue.Queue a)\n-&gt; {v : (LazyQueue.Queue a) | qsize x2 + 1 == qsize v}insert ae (Q f b) = x1:(LazyQueue.SList a)\n-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1 + 1}\n-&gt; {v : (LazyQueue.Queue a) | size x1 + size v == qsize v}makeq {v : (LazyQueue.SList a) | v == f}f ({VV : a | VV == e}e a\n-&gt; x2:(LazyQueue.SList a)\n-&gt; {v : (LazyQueue.SList a) | size v == size v + 1}`cons` {v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f}b)\n</pre> <p>To Remove an element we pop it off the <code>front</code> by using <code>hd</code> and <code>tl</code>. Notice that the <code>remove</code> is only called on non-empty <code>Queue</code>s, which together with the key balance invariant, ensures that the calls to <code>hd</code> and <code>tl</code> are safe.</p> <pre>284: {-@ remove       :: q:NEQueue a -&gt; (a, QueueN a {qsize q - 1}) @-}\n285: forall a.\nx1:{v : (LazyQueue.Queue a) | 0 &lt; qsize v}\n-&gt; (a, {v : (LazyQueue.Queue a) | qsize x1 - 1 == qsize v})remove (Q f b)   = forall a b &lt;p2 :: a b -&gt; Prop&gt;.\nx1:a\n-&gt; x2:{VV : b&lt;p2 x1&gt; | true}\n-&gt; {v : (a, b)&lt;\\x6 VV -&gt; p2 x6&gt; | fst v == x1 &amp;&amp; x_Tuple22 v == x2 &amp;&amp; snd v == x2 &amp;&amp; x_Tuple21 v == x1}({v : (LazyQueue.SList a) | size v &gt; 0} -&gt; ahd {v : (LazyQueue.SList a) | v == f}f, x1:(LazyQueue.SList a)\n-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1 + 1}\n-&gt; {v : (LazyQueue.Queue a) | size x1 + size v == qsize v}makeq (x1:{v : (LazyQueue.SList a) | size v &gt; 0}\n-&gt; {v : (LazyQueue.SList a) | size v == size x1 - 1}tl {v : (LazyQueue.SList a) | v == f}f) {v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f}b)\n</pre> <p>Aside: Why didn't we (or Okasaki) use a pattern match here?</p> <p>To Ensure the Invariant we use the smart constructor <code>makeq</code>, which is where the heavy lifting, such as it is, happens. The constructor takes two lists, the front <code>f</code> and back <code>b</code> and if they are balanced, directly returns the <code>Queue</code>, and otherwise transfers the elements from <code>b</code> over using <code>rot</code>ate.</p> <pre>297: {-@ makeq :: f:SList a\n298:           -&gt; b:SListLE a {size f + 1 }\n299:           -&gt; QueueN a {size f + size b}\n300:   @-}\n301: forall a.\nx1:(LazyQueue.SList a)\n-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1 + 1}\n-&gt; {v : (LazyQueue.Queue a) | size x1 + size x2 == qsize v}makeq (LazyQueue.SList a)f {v : (LazyQueue.SList a) | size v &lt;= size f + 1}b \n302:   | x1:(LazyQueue.SList a)\n-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}size {v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f + 1}b x1:GHC.Types.Int\n-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 &lt;= v}&lt;= x1:(LazyQueue.SList a)\n-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}size {v : (LazyQueue.SList a) | v == f}f = x1:(LazyQueue.SList a)\n-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1}\n-&gt; {v : (LazyQueue.Queue a) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}Q {v : (LazyQueue.SList a) | v == f}f {v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f + 1}b\n303:   | otherwise        = x1:(LazyQueue.SList a)\n-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1}\n-&gt; {v : (LazyQueue.Queue a) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}Q (forall a.\nx1:(LazyQueue.SList a)\n-&gt; x2:{v : (LazyQueue.SList a) | size v == 1 + size x1}\n-&gt; x3:(LazyQueue.SList a)\n-&gt; {v : (LazyQueue.SList a) | size v == size x1 + size x2 + size x3}rot {v : (LazyQueue.SList a) | v == f}f {v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f + 1}b {v : (LazyQueue.SList a) | size v == 0}nil) {v : (LazyQueue.SList a) | size v == 0}nil\n</pre> <p>The Rotate function is only called when the <code>back</code> is one larger than the <code>front</code> (we never let things drift beyond that). It is arranged so that it the <code>hd</code> is built up fast, before the entire computation finishes; which, combined with laziness provides the efficient worst-case guarantee.</p> <pre>313: {-@ rot :: f:SList a\n314:         -&gt; b:SListN _ {1 + size f}\n315:         -&gt; a:SList _\n316:         -&gt; SListN _ {size f + size b + size a}\n317:   @-}\n318: forall a.\nx1:(LazyQueue.SList a)\n-&gt; x2:{v : (LazyQueue.SList a) | size v == 1 + size x1}\n-&gt; x3:(LazyQueue.SList a)\n-&gt; {v : (LazyQueue.SList a) | size v == size x1 + size x2 + size x3}rot (LazyQueue.SList a)f {v : (LazyQueue.SList a) | size v == 1 + size f}b (LazyQueue.SList a)a\n319:   | x1:(LazyQueue.SList a)\n-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}size {v : (LazyQueue.SList a) | v == f}f x1:GHC.Types.Int\n-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == v}== {v : GHC.Types.Int | v == (0  :  int)}0 = {v : (LazyQueue.SList a) | size v &gt; 0} -&gt; ahd {v : (LazyQueue.SList a) | v == b &amp;&amp; size v == 1 + size f}b a\n-&gt; x2:(LazyQueue.SList a)\n-&gt; {v : (LazyQueue.SList a) | size v == size v + 1}`cons` {v : (LazyQueue.SList a) | v == a}a\n320:   | otherwise   = {v : (LazyQueue.SList a) | size v &gt; 0} -&gt; ahd {v : (LazyQueue.SList a) | v == f}f a\n-&gt; x2:(LazyQueue.SList a)\n-&gt; {v : (LazyQueue.SList a) | size v == size v + 1}`cons` forall a.\nx1:(LazyQueue.SList a)\n-&gt; x2:{v : (LazyQueue.SList a) | size v == 1 + size x1}\n-&gt; x3:(LazyQueue.SList a)\n-&gt; {v : (LazyQueue.SList a) | size v == size x1 + size x2 + size x3}rot (x1:{v : (LazyQueue.SList a) | size v &gt; 0}\n-&gt; {v : (LazyQueue.SList a) | size v == size x1 - 1}tl {v : (LazyQueue.SList a) | v == f}f) (x1:{v : (LazyQueue.SList a) | size v &gt; 0}\n-&gt; {v : (LazyQueue.SList a) | size v == size x1 - 1}tl {v : (LazyQueue.SList a) | v == b &amp;&amp; size v == 1 + size f}b) ({v : (LazyQueue.SList a) | size v &gt; 0} -&gt; ahd {v : (LazyQueue.SList a) | v == b &amp;&amp; size v == 1 + size f}b a\n-&gt; x2:(LazyQueue.SList a)\n-&gt; {v : (LazyQueue.SList a) | size v == size v + 1}`cons` {v : (LazyQueue.SList a) | v == a}a)\n</pre>","tags":["measures"]},{"location":"blogposts/2015-01-30-okasakis-lazy-queue.lhs/#conclusion","title":"Conclusion","text":"<p>Well there you have it; Okasaki's beautiful lazy Queue, with the invariants easily expressed and checked with LiquidHaskell. I find this example particularly interesting because the refinements express invariants that are critical for efficiency, and furthermore the code introspects on the <code>size</code> in order to guarantee the invariants.  Plus, it's just marginally more complicated than <code>append</code> and so, (I hope!) was easy to follow.</p>","tags":["measures"]},{"location":"blogposts/2016-09-01-normal-forms.lhs/","title":"Normal Forms","text":"<p>I have been preparing an undergraduate course on Compilers in which we build a compiler that crunches an ML-like language to X86 assembly. One of my favorite steps in the compilation is the conversion to A-Normal Form (ANF) where, informally speaking, each call or primitive operation's arguments are immediate values, i.e. constants or variable lookups whose values can be loaded with a single machine instruction. For example, the expression</p> <pre>25: ((2 + 3) * (12 - 4)) * (7 + 8)\n</pre> <p>has the A-Normal Form:</p> <pre>31: let anf0 = 2 + 3\n32:     anf1 = 12 - 4\n33:     anf2 = anf0 * anf1\n34:     anf3 = 7 + 8\n35: in\n36:     anf2 * anf3\n</pre> <p>The usual presentation of ANF conversion is very elegant but relies upon a clever use of continuations. Lets look at another perhaps simpler approach, where we can use refinements to light the way.</p> <pre>49: {-@ LIQUID \"--no-termination\" @-}\n50: {-@ LIQUID \"--total\"          @-}\n51: \n52: module ANF (Op (..), Expr (..), isImm, isAnf, toAnf) where\n53: \n54: import Control.Monad.State.Lazy\n55: \n56: mkLet :: [(Var, AnfExpr)] -&gt; AnfExpr -&gt; AnfExpr\n57: imm, immExpr :: Expr -&gt; AnfM ([(Var, AnfExpr)], ImmExpr)\n58: anf   :: Expr -&gt; AnfM AnfExpr\n59: \n60: -- data IExpr\n61:   -- = IInt Int\n62:   -- | IVar Var\n63: --\n64: -- data AExpr\n65:   -- = AImm IExpr\n66:   -- | ABin Op    IExpr IExpr\n67:   -- | ALet Var   AExpr AExpr\n68:   -- | ALam Var   AExpr\n69:   -- | AApp IExpr IExpr\n70: \n71: type AnfExpr = Expr\n72: type ImmExpr = Expr\n</pre>","tags":["measures"]},{"location":"blogposts/2016-09-01-normal-forms.lhs/#source-language","title":"Source Language","text":"<p>Lets commence by defining the source language that we wish to work with:</p> <pre>82: data Expr\n83:   = EInt  Int               -- ^ Integers\n84:   | EVar  Var               -- ^ Variables\n85:   | EBin  Op   Expr Expr    -- ^ Binary Operators\n86:   | ELet  Var  Expr Expr    -- ^ Let-binders\n87:   | ELam  Var  Expr         -- ^ Function definitions\n88:   | EApp  Expr Expr         -- ^ Function applications\n89:   deriving ((GHC.Show.Show ANF.Expr)Show)\n</pre> <p>The language, defined by <code>Expr</code> has integers, variables, binary operators, let-binders and function definitions (lambdas) and calls (applications). In the above, <code>Var</code> and <code>Op</code> are simply:</p> <pre>97: type Var = String\n98: \n99: data Op  = Plus | Minus | Times\n100:          deriving ((GHC.Show.Show ANF.Op)Show)\n</pre> <p>For example, the source expression above corresponds to the value:</p> <pre>106: -- ((2 + 3) * (12 - 4)) * (7 + 8)\n107: srcExpr :: Expr\n108: {VV : ANF.Expr | VV /= ANF.e1\n                 &amp;&amp; VV /= ANF.e2\n                 &amp;&amp; VV /= ANF.e2'\n                 &amp;&amp; VV /= ANF.e3\n                 &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                      bool])) ((isImm : func(0, [ANF.Expr;\n                                                                 GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; false)}srcExpr = {v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)\n                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}EBin Times\n109:             ({v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)\n                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}EBin Times\n110:               ({v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)\n                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}EBin Plus  ({v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)\n                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}EInt  2) ({v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)\n                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}EInt 3))\n111:               ({v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)\n                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}EBin Minus ({v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)\n                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}EInt 12) ({v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)\n                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}EInt 4)))\n112:             ({v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)\n                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}EBin Plus ({v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)\n                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}EInt 7) ({v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)\n                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}EInt 8))\n</pre>","tags":["measures"]},{"location":"blogposts/2016-09-01-normal-forms.lhs/#a-normal-form","title":"A-Normal Form","text":"<p>Before we can describe a conversion to A-Normal Form (ANF), we must pin down what ANF is. Our informal description was: ``each call or primitive operation's arguments are immediate   values, i.e. constants or variable lookups''.</p> <p>We could define a brand new datatypes, say <code>IExpr</code> and <code>AExpr</code> whose values correspond to immediate and ANF terms. (Try it, as an exercise.) Unfortunately, doing so leads to a bunch of code duplication, e.g. duplicate printers for <code>Expr</code> and <code>AExpr</code>. Instead, lets see how we can use refinements to carve out suitable subsets.</p> <p>Immediate Expressions</p> <p>An <code>Expr</code> is immediate if it is a <code>Number</code> or a <code>Var</code>; we can formalize this as a Haskell predicate:</p> <pre>136: {-@ measure isImm @-}\n137: isImm :: Expr -&gt; Bool\n138: x1:ANF.Expr -&gt; {VV : GHC.Types.Bool | Prop VV &lt;=&gt; Prop (isImm x1)}isImm (EInt _) = True\n139: isImm (EVar _) = True\n140: isImm _        = False\n</pre> <p>and then we can use the predicate to define a refinement type for immediate expressions:</p> <pre>147: {-@ type ImmExpr = {v:Expr | isImm v} @-}\n</pre> <p>For example, <code>e1</code> is immediate but <code>e2</code> is not:</p> <pre>153: {-@ e1 :: ImmExpr @-}\n154: {v : ANF.Expr | Prop (isImm v)}e1 = {v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)\n                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}EInt 7\n155: \n156: {-@ e2 :: ImmExpr @-}\n157: {v : ANF.Expr | Prop (isImm v)}e2 = {v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)\n                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}EBin Plus e1 e1\n</pre> <p>ANF Expressions</p> <p>Similiarly, an <code>Expr</code> is in ANF if all arguments for operators and applications are immediate. Once again, we can formalize this intuition as a Haskell predicate:</p> <pre>167: {-@ measure isAnf @-}\n168: isAnf :: Expr -&gt; Bool\n169: x1:ANF.Expr -&gt; {VV : GHC.Types.Bool | Prop VV &lt;=&gt; Prop (isAnf x1)}isAnf (EInt {})      = True\n170: isAnf (EVar {})      = True\n171: isAnf (EBin _ e1 e2) = {v : x1:ANF.Expr -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop (isImm x1)} | v == isImm}isImm e1 {v : x1:GHC.Types.Bool -&gt; x2:GHC.Types.Bool -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop x1\n                                                                                &amp;&amp; Prop x2} | v == GHC.Classes.&amp;&amp;}&amp;&amp; {v : x1:ANF.Expr -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop (isImm x1)} | v == isImm}isImm e2  -- args for operators\n172: isAnf (EApp e1 e2)   = {v : x1:ANF.Expr -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop (isImm x1)} | v == isImm}isImm e1 {v : x1:GHC.Types.Bool -&gt; x2:GHC.Types.Bool -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop x1\n                                                                                &amp;&amp; Prop x2} | v == GHC.Classes.&amp;&amp;}&amp;&amp; {v : x1:ANF.Expr -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop (isImm x1)} | v == isImm}isImm e2  -- must be immediate,\n173: isAnf (ELet _ e1 e2) = x1:ANF.Expr -&gt; {VV : GHC.Types.Bool | Prop VV &lt;=&gt; Prop (isAnf x1)}isAnf e1 {v : x1:GHC.Types.Bool -&gt; x2:GHC.Types.Bool -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop x1\n                                                                                &amp;&amp; Prop x2} | v == GHC.Classes.&amp;&amp;}&amp;&amp; x1:ANF.Expr -&gt; {VV : GHC.Types.Bool | Prop VV &lt;=&gt; Prop (isAnf x1)}isAnf e2  -- and sub-expressions\n174: isAnf (ELam _ e)     = x1:ANF.Expr -&gt; {VV : GHC.Types.Bool | Prop VV &lt;=&gt; Prop (isAnf x1)}isAnf e               -- must be in ANF\n</pre> <p>and then use the predicate to define the subset of legal ANF expressions:</p> <pre>180: {-@ type AnfExpr = {v:Expr | isAnf v} @-}\n</pre> <p>For example, <code>e2</code> above is in ANF but <code>e3</code> is not:</p> <pre>186: {-@ e2' :: AnfExpr @-}\n187: {v : ANF.Expr | Prop (isAnf v)}e2' = {v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)\n                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}EBin Plus e1 e1\n188: \n189: {-@ e3 :: AnfExpr @-}\n190: {v : ANF.Expr | Prop (isAnf v)}e3 = {v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)\n                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}EBin Plus e2' e2'\n</pre>","tags":["measures"]},{"location":"blogposts/2016-09-01-normal-forms.lhs/#anf-conversion-intuition","title":"ANF Conversion: Intuition","text":"<p>Now that we have clearly demarcated the territories belonging to plain <code>Expr</code>, immediate <code>ImmExpr</code> and A-Normal <code>AnfExpr</code>, lets see how we can convert the former to the latter.</p> <p>Recall that our goal is to convert expressions like</p> <pre>203: ((2 + 3) * (12 - 4)) * (7 + 8)\n</pre> <p>into</p> <pre>209: let anf0 = 2 + 3\n210:     anf1 = 12 - 4\n211:     anf2 = anf0 * anf1\n212:     anf3 = 7 + 8\n213: in\n214:     anf2 * anf3\n</pre> <p>Generalising a bit, we want to convert</p> <pre>220: e1 + e2\n</pre> <p>into</p> <pre>226: let x1  = a1  ... xn  = an\n227:     x1' = a1' ... xm' = am'\n228: in\n229:     v1 + v2\n</pre> <p>where, <code>v1</code> and <code>v2</code> are immediate, and <code>ai</code> are ANF.</p> <p>Making Arguments Immediate</p> <p>In other words, the key requirement is a way to crunch arbitrary argument expressions like <code>e1</code> into a pair</p> <pre>240: ([(x1, a1) ... (xn, an)], v1)\n</pre> <p>where</p> <ol> <li><code>a1...an</code> are <code>AnfExpr</code>, and</li> <li><code>v1</code> is an immediate <code>ImmExpr</code></li> </ol> <p>such that <code>e1</code> is equivalent to <code>let x1 = a1 ... xn = an in v1</code>. Thus, we need a function</p> <pre>252: imm :: Expr -&gt; ([(Var, AnfExpr)], ImmExpr)\n</pre> <p>which we will use to make arguments immediate thereby yielding a top level conversion function</p> <pre>259: anf :: Expr -&gt; AnfExpr\n</pre> <p>As we need to generate \"temporary\" intermediate binders, it will be convenient to work within a monad that generates <code>fresh</code> variables:</p> <pre>267: type AnfM a = State Int a\n268: \n269: fresh :: AnfM Var\n270: (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity {VV : [GHC.Types.Char] | (len : func(2, [(@(0)  @(1));\n                                                                                                                             int])) (VV : [@(0)]) &gt; 0\n                                                                                                             &amp;&amp; (len : func(2, [(@(0)  @(1));\n                                                                                                                                int])) (VV : [@(0)]) &gt;= 0})fresh = do\n271:   GHC.Types.Intn &lt;- (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity GHC.Types.Int)get\n272:   GHC.Types.Int -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ())put (GHC.Types.Intnx1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+1)\n273:   [GHC.Types.Char] -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity [GHC.Types.Char])return ([GHC.Types.Char]\"anf\" ++ GHC.Types.Int -&gt; [GHC.Types.Char]show n)\n</pre> <p>Thus, the conversion functions will have the types:</p> <pre>279: anf :: Expr -&gt; AnfM AnfExpr\n280: imm :: Expr -&gt; AnfM ([(Var, AnfExpr)], ImmExpr)\n</pre>","tags":["measures"]},{"location":"blogposts/2016-09-01-normal-forms.lhs/#anf-conversion-code","title":"ANF Conversion: Code","text":"<p>We can now define the top-level conversion thus:</p> <pre>289: --------------------------------------------------------------------------------\n290: {-@ anf :: Expr -&gt; AnfM AnfExpr @-}\n291: --------------------------------------------------------------------------------\n292: ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity {v : ANF.Expr | Prop (isAnf v)})anf (EInt n) =\n293:   ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ANF.Expr)return ({v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)\n                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}EInt n)\n294: \n295: anf (EVar x) =\n296:   ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ANF.Expr)return ({v : [GHC.Types.Char] -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)\n                                         &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EVar}EVar x)\n297: \n298: anf (ELet x e1 e2) = do\n299:   {v : ANF.Expr | Prop (isAnf v)}a1 &lt;- ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity {v : ANF.Expr | Prop (isAnf v)})anf e1\n300:   {v : ANF.Expr | Prop (isAnf v)}a2 &lt;- ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity {v : ANF.Expr | Prop (isAnf v)})anf e2\n301:   ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ANF.Expr)return ({v : [GHC.Types.Char] -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                                       &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isAnf x2)\n                                                                                              &amp;&amp; Prop (isAnf x3))} | v == ANF.ELet}ELet x a1 a2)\n302: \n303: anf (EBin o e1 e2) = do\n304:   (b1s, v1) &lt;- ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))imm e1\n305:   (b2s, v2) &lt;- ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))imm e2\n306:   ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ANF.Expr)return ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})] -&gt; {v : ANF.Expr | Prop (isAnf v)} -&gt; {v : ANF.Expr | Prop (isAnf v)}mkLet ({v : [([GHC.Types.Char], ANF.Expr)] | len v == len b1s + len b2s}b1s ++ b2s) ({v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)\n                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}EBin o v1 v2))\n307: \n308: anf (ELam x e) = do\n309:   {v : ANF.Expr | Prop (isAnf v)}a &lt;- ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity {v : ANF.Expr | Prop (isAnf v)})anf e\n310:   ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ANF.Expr)return ({v : [GHC.Types.Char] -&gt; x2:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                        &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isAnf x2))} | v == ANF.ELam}ELam x a)\n311: \n312: anf (EApp e1 e2) = do\n313:   (b1s, v1) &lt;- ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))imm e1\n314:   (b2s, v2) &lt;- ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))imm e2\n315:   ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ANF.Expr)return ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})] -&gt; {v : ANF.Expr | Prop (isAnf v)} -&gt; {v : ANF.Expr | Prop (isAnf v)}mkLet ({v : [([GHC.Types.Char], ANF.Expr)] | len v == len b1s + len b2s}b1s ++ b2s) ({v : x1:ANF.Expr -&gt; x2:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                   &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x1)\n                                                                          &amp;&amp; Prop (isImm x2))} | v == ANF.EApp}EApp v1 v2))\n</pre> <p>In <code>anf</code> the real work happens inside <code>imm</code> which takes an arbitary argument expression and makes it immediate by generating temporary (ANF) bindings. The resulting bindings (and immediate values) are composed by the helper <code>mkLet</code> that takes a list of binders and a body <code>AnfExpr</code> and stitches them into a single <code>AnfExpr</code>:</p> <pre>325: {-@ mkLet :: [(Var, AnfExpr)] -&gt; AnfExpr -&gt; AnfExpr @-}\n326: [([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})] -&gt; {v : ANF.Expr | Prop (isAnf v)} -&gt; {v : ANF.Expr | Prop (isAnf v)}mkLet []         {v : ANF.Expr | Prop (isAnf v)}e' = e'\n327: mkLet ((x,e):bs) e' = {v : [GHC.Types.Char] -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                                       &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isAnf x2)\n                                                                                              &amp;&amp; Prop (isAnf x3))} | v == ANF.ELet}ELet x e ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})] -&gt; {v : ANF.Expr | Prop (isAnf v)} -&gt; {v : ANF.Expr | Prop (isAnf v)}mkLet bs e')\n</pre> <p>The arguments are made immediate by <code>imm</code> defined as:</p> <pre>333: --------------------------------------------------------------------------------\n334: {-@ imm :: Expr -&gt; AnfM ([(Var, AnfExpr)], ImmExpr) @-}\n335: --------------------------------------------------------------------------------\n336: ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))imm (EInt n)       = ([([GHC.Types.Char], ANF.Expr)], ANF.Expr) -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], ANF.Expr)], ANF.Expr))return ([], {v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)\n                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}EInt n)\n337: imm (EVar x)       = ([([GHC.Types.Char], ANF.Expr)], ANF.Expr) -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], ANF.Expr)], ANF.Expr))return ([], {v : [GHC.Types.Char] -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)\n                                         &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EVar}EVar x)\n338: imm e@(ELet {})    = ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))immExpr e\n339: imm e@(ELam {})    = ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))immExpr e\n340: imm (EBin o e1 e2) = ANF.Expr -&gt; ANF.Expr -&gt; (x4:{VV : ANF.Expr | VV /= ANF.srcExpr\n                                             &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                             GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                            GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; x5:{VV : ANF.Expr | VV /= ANF.srcExpr\n                                                                                                                                                                        &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                             bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                        GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; {VV : ANF.Expr | (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; false)\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= x5\n                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= ANF.e2\n                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= x4\n                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= ANF.e1}) -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ({VV : [([GHC.Types.Char], {VV : ANF.Expr | ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)})] | (len : func(2, [(@(0)  @(1));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             int])) (VV : [@(0)]) &gt; 0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (len : func(2, [(@(0)  @(1));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                int])) (VV : [@(0)]) &gt;= 0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (VV : @(43)) == ((fst : func(0, [(Tuple  @(43)  @(44));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 @(43)])) (VV : (Tuple  @(45)  @(44))) : @(43))}, {VV : ANF.Expr | VV /= ANF.srcExpr\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (VV : @(42)) == ((snd : func(0, [(Tuple  @(45)  @(42));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       @(42)])) (VV : (Tuple  @(45)  @(44))) : @(42))}))imm2 e1 e2 ({v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)\n                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}EBin o)\n341: imm (EApp e1 e2)   = ANF.Expr -&gt; ANF.Expr -&gt; (x4:{VV : ANF.Expr | VV /= ANF.srcExpr\n                                             &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                             GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                            GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; x5:{VV : ANF.Expr | VV /= ANF.srcExpr\n                                                                                                                                                                        &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                             bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                        GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; {VV : ANF.Expr | (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; false)\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= x5\n                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= ANF.e2\n                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= x4\n                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= ANF.e1}) -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ({VV : [([GHC.Types.Char], {VV : ANF.Expr | ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)})] | (len : func(2, [(@(0)  @(1));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             int])) (VV : [@(0)]) &gt; 0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (len : func(2, [(@(0)  @(1));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                int])) (VV : [@(0)]) &gt;= 0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (VV : @(43)) == ((fst : func(0, [(Tuple  @(43)  @(44));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 @(43)])) (VV : (Tuple  @(45)  @(44))) : @(43))}, {VV : ANF.Expr | VV /= ANF.srcExpr\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (VV : @(42)) == ((snd : func(0, [(Tuple  @(45)  @(42));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       @(42)])) (VV : (Tuple  @(45)  @(44))) : @(42))}))imm2 e1 e2 {v : x1:ANF.Expr -&gt; x2:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)\n                                                   &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x1)\n                                                                          &amp;&amp; Prop (isImm x2))} | v == ANF.EApp}EApp\n</pre> <ul> <li> <p>Numbers and variables are already immediate, and are returned directly.</p> </li> <li> <p>Let-binders and lambdas are simply converted to ANF, and assigned to a fresh   binder:</p> </li> </ul> <pre>350: {-@ immExpr :: Expr -&gt; AnfM ([(Var, AnfExpr)], ImmExpr) @-}\n351: ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))immExpr ANF.Expre = do\n352:   {v : ANF.Expr | Prop (isAnf v)}a &lt;- ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity {v : ANF.Expr | Prop (isAnf v)})anf e\n353:   {v : [GHC.Types.Char] | (len : func(2, [(@(0)  @(1));\n                                        int])) (v : [@(0)]) &gt; 0\n                        &amp;&amp; (len : func(2, [(@(0)  @(1)); int])) (v : [@(0)]) &gt;= 0}t &lt;- fresh\n354:   ([([GHC.Types.Char], ANF.Expr)], ANF.Expr) -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], ANF.Expr)], ANF.Expr))return ([(t, a)], {v : [GHC.Types.Char] -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)\n                                         &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EVar}EVar t)\n</pre> <ul> <li>Finally, binary operators and applications are converted by <code>imm2</code> that   takes two arbitrary expressions and an expression constructor, yielding   the anf-binders and immediate expression.</li> </ul> <pre>362: imm2 :: Expr -&gt; Expr -&gt; (ImmExpr -&gt; ImmExpr -&gt; AnfExpr)\n363:      -&gt; AnfM ([(Var, AnfExpr)], ImmExpr)\n364: ANF.Expr -&gt; ANF.Expr -&gt; (x4:{VV : ANF.Expr | VV /= ANF.srcExpr\n                                             &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                             GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                            GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; x5:{VV : ANF.Expr | VV /= ANF.srcExpr\n                                                                                                                                                                        &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                             bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                        GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; {VV : ANF.Expr | (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; false)\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= x5\n                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= ANF.e2\n                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= x4\n                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= ANF.e1}) -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ({VV : [([GHC.Types.Char], {VV : ANF.Expr | ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)})] | (len : func(2, [(@(0)  @(1));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             int])) (VV : [@(0)]) &gt; 0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (len : func(2, [(@(0)  @(1));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                int])) (VV : [@(0)]) &gt;= 0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (VV : @(43)) == ((fst : func(0, [(Tuple  @(43)  @(44));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 @(43)])) (VV : (Tuple  @(45)  @(44))) : @(43))}, {VV : ANF.Expr | VV /= ANF.srcExpr\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (VV : @(42)) == ((snd : func(0, [(Tuple  @(45)  @(42));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       @(42)])) (VV : (Tuple  @(45)  @(44))) : @(42))}))imm2 ANF.Expre1 ANF.Expre2 x1:{VV : ANF.Expr | VV /= ANF.srcExpr\n                    &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                         bool])) ((isImm : func(0, [ANF.Expr;\n                                                                    GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                    &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                        bool])) ((isImm : func(0, [ANF.Expr;\n                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; x2:{VV : ANF.Expr | VV /= ANF.srcExpr\n                                                                                                                                               &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                    bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                               GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                              GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; {VV : ANF.Expr | (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; false)\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; VV /= x2\n                                                                                                                                                                                                                                                                       &amp;&amp; VV /= ANF.e2\n                                                                                                                                                                                                                                                                       &amp;&amp; VV /= x1\n                                                                                                                                                                                                                                                                       &amp;&amp; VV /= ANF.e1}f = do\n365:   (b1s, v1) &lt;- ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))imm e1\n366:   (b2s, v2) &lt;- ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))imm e2\n367:   {v : [GHC.Types.Char] | (len : func(2, [(@(0)  @(1));\n                                        int])) (v : [@(0)]) &gt; 0\n                        &amp;&amp; (len : func(2, [(@(0)  @(1)); int])) (v : [@(0)]) &gt;= 0}t         &lt;- fresh\n368:   let [([GHC.Types.Char], ANF.Expr)]bs'    = [([GHC.Types.Char], ANF.Expr)]b1s ++ [([GHC.Types.Char], ANF.Expr)]b2s ++ [(t, {v : x1:{v : ANF.Expr | v /= ANF.srcExpr\n                        &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                             bool])) ((isImm : func(0, [ANF.Expr;\n                                                                        GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool)} -&gt; x2:{v : ANF.Expr | v /= ANF.srcExpr\n                                                                                                                                                 &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                      bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                 GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                 &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                     bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool)} -&gt; {v : ANF.Expr | (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; false)\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)\n                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;\n                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;\n                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))\n                                                                                                                                                                                                                                                                       &amp;&amp; v /= x2\n                                                                                                                                                                                                                                                                       &amp;&amp; v /= ANF.e2\n                                                                                                                                                                                                                                                                       &amp;&amp; v /= x1\n                                                                                                                                                                                                                                                                       &amp;&amp; v /= ANF.e1} | v == f}f v1 v2)]\n369:   ([([GHC.Types.Char], ANF.Expr)], ANF.Expr) -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], ANF.Expr)], ANF.Expr))return      (bs', {v : [GHC.Types.Char] -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)\n                                         &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EVar}EVar t)\n</pre> <p>You can run it thus:</p> <pre>376: toAnf :: Expr -&gt; AnfExpr\n377: ANF.Expr -&gt; ANF.ExprtoAnf ANF.Expre = GHC.Types.Int -&gt; ANF.ExprevalState (ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity {v : ANF.Expr | Prop (isAnf v)})anf e) 0\n</pre> <pre>381: ghci&gt; toAnf srcExpr\n382: ELet \"anf0\" (EBin Plus (EInt 2) (EInt 3))\n383:  (ELet \"anf1\" (EBin Minus (EInt 12) (EInt 4))\n384:    (ELet \"anf2\" (EBin Times (EVar \"anf0\") (EVar \"anf1\"))\n385:      (ELet \"anf3\" (EBin Plus (EInt 7) (EInt 8))\n386:        (EBin Times (EVar \"anf2\") (EVar \"anf3\")))))\n</pre> <p>which, can be pretty-printed to yield exactly the outcome desired at the top:</p> <pre>392: let anf0 = 2 + 3\n393:     anf1 = 12 - 4\n394:     anf2 = anf0 * anf1\n395:     anf3 = 7 + 8\n396: in\n397:     anf2 * anf3\n</pre> <p>There! The refinements make this tricky conversion quite straightforward and natural, without requiring us to duplicate types and code. As an exercise, can you use refinements to:</p> <ol> <li>Port the classic continuation-based conversion ?</li> <li>Check that the conversion yields well-scoped terms ?</li> </ol>","tags":["measures"]},{"location":"blogposts/2016-09-18-refinement-reflection.lhs/","title":"Haskell as a Theorem Prover","text":"<p>We've taught LiquidHaskell a new trick that we call ``Refinement Reflection'' which lets us turn Haskell into a theorem prover capable of proving arbitrary properties of code. The key idea is to reflect the code of the function into its output type, which lets us then reason about the function at the (refinement) type level. Lets see how to use refinement types to express a theorem, for example that fibonacci is a monotonically increasing function,  then write plain Haskell code to reify a paper-and-pencil-style proof  for that theorem, that can be machine checked by LiquidHaskell.</p> <p> </p> <pre>38: {-@ LIQUID \"--higherorder\"     @-}\n39: {-@ LIQUID \"--totality\"        @-}\n40: module RefinementReflection where\n41: import Language.Haskell.Liquid.ProofCombinators\n42: \n43: fib :: Int -&gt; Int\n44: propPlusComm :: Int -&gt; Int -&gt; Proof \n45: propOnePlueOne :: () -&gt; Proof \n46: fibTwo :: () -&gt; Proof \n47: fibCongruence :: Int -&gt; Int -&gt; Proof\n48: fibUp :: Int -&gt; Proof \n49: fibTwoPretty :: Proof \n50: fibThree :: () -&gt; Proof \n51: fMono :: (Int -&gt; Int)\n52:       -&gt; (Int -&gt; Proof)\n53:       -&gt; Int\n54:       -&gt; Int \n55:       -&gt; Proof \n56: fibMono :: Int -&gt; Int -&gt; Proof \n57: \n</pre>","tags":["reflection"]},{"location":"blogposts/2016-09-18-refinement-reflection.lhs/#shallow-vs-deep-specifications","title":"Shallow vs. Deep Specifications","text":"<p>Up to now, we have been using Liquid Haskell to specify and verify \"shallow\" specifications that abstractly describe the behavior of functions.  For example, below, we specify and verify that <code>fib</code>restricted to natural numbers, always terminates returning a natural number.</p> <pre>70: {-@ fib :: i:Nat -&gt; Nat / [i] @-}\n71: {v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}fib {v : GHC.Types.Int | v &gt;= 0}i | GHC.Types.Booli x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}== 0    = 0 \n72:       | GHC.Types.Booli x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}== 1    = 1 \n73:       | otherwise = {v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}fib (GHC.Types.Intix1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}-1) x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ {v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}fib (GHC.Types.Intix1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}-2)\n</pre> <p>In this post we present how refinement reflection is used to verify  \"deep\" specifications that use the exact definition of Haskell functions.  For example, we will prove that the Haskell <code>fib</code> function is increasing.</p>","tags":["reflection"]},{"location":"blogposts/2016-09-18-refinement-reflection.lhs/#propositions","title":"Propositions","text":"<p>To begin with, we import ProofCombinators, a (Liquid) Haskell  library that defines and manipulates logical proofs. </p> <pre>89: import Language.Haskell.Liquid.ProofCombinators\n</pre> <p>A <code>Proof</code> is a data type that carries no run time information</p> <pre>95: type Proof = ()\n</pre> <p>but can be refined with desired logical propositions. For example, the following type states that <code>1 + 1 == 2</code></p> <pre>102: {-@ type OnePlusOne = {v: Proof | 1 + 1 == 2} @-}\n</pre> <p>Since the <code>v</code> and <code>Proof</code> are irrelevant, we may as well abbreviate  the above to </p> <pre>109: {-@ type OnePlusOne' = { 1 + 1 == 2 } @-}\n</pre> <p>As another example, the following function type declares  that for each <code>x</code> and <code>y</code> the plus operator commutes. </p> <pre>117: {-@ type PlusComm = x:Int -&gt; y:Int -&gt; {x + y == y + x} @-} \n</pre>","tags":["reflection"]},{"location":"blogposts/2016-09-18-refinement-reflection.lhs/#trivial-proofs","title":"Trivial Proofs","text":"<p>We prove the above theorems using Haskell programs.  The <code>ProofCombinators</code> module defines the <code>trivial</code> proof</p> <pre>129: trivial :: Proof \n130: trivial = ()\n</pre> <p>and the \"casting\" operator <code>(***)</code> that makes proof terms look  nice:</p> <pre>137: data QED = QED\n138: \n139: (***) :: a -&gt; QED -&gt; Proof\n140: _ *** _ = ()\n</pre> <p>Using the underlying SMT's knowledge on linear arithmetic,  we can trivially prove the above propositions.</p> <pre>147: {-@ propOnePlueOne :: _ -&gt; OnePlusOne @-} \n148: () -&gt; {VV : () | 1 + 1 == 2}propOnePlueOne _ = {v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}trivial *** QED \n149: \n150: {-@ propPlusComm :: PlusComm @-} \n151: x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {VV : () | x1 + x2 == x2 + x1}propPlusComm _ _ = {v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}trivial *** QED \n</pre> <p>We saw how we use SMT's knowledge on linear arithmetic  to trivially prove arithmetic properties. But how can  we prove ``deep'' properties on Haskell's functions?</p>","tags":["reflection"]},{"location":"blogposts/2016-09-18-refinement-reflection.lhs/#refinement-reflection","title":"Refinement Reflection","text":"<p>Refinement Reflection allows deep specification and  verification by reflecting the code implementing a Haskell function into the function\u2019s output refinement type.</p> <p>Refinement Reflection proceeds in 3 steps: definition, reflection, and application. Consider reflecting the definition of <code>fib</code> into the logic</p> <pre>171: {-@ reflect fib @-}\n</pre> <p>then the following three reflection steps will occur. </p>","tags":["reflection"]},{"location":"blogposts/2016-09-18-refinement-reflection.lhs/#step-1-definition","title":"Step 1: Definition","text":"<p>Reflection of the Haskell function <code>fib</code> defines in logic  an uninterpreted function <code>fib</code> that satisfies the congruence axiom.</p> <p>In the logic the function <code>fib</code> is defined.</p> <pre>185: fib :: Int -&gt; Int \n</pre> <p>SMT only knows that <code>fib</code> satisfies the congruence axiom.</p> <pre>191: {-@ fibCongruence :: i:Nat -&gt; j:Nat -&gt; {i == j =&gt; fib i == fib j} @-}\n192: x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 == x2 =&gt; fib x1 == fib x2}fibCongruence _ _ = {v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}trivial *** QED \n</pre> <p>Other than congruence, SMT knowns nothing for the function <code>fib</code>, until reflection happens!</p>","tags":["reflection"]},{"location":"blogposts/2016-09-18-refinement-reflection.lhs/#step-2-reflection","title":"Step 2: Reflection","text":"<p>As a second step, Liquid Haskell connects the Haskell function <code>fib</code> with the homonymous logical function,  by reflecting the implementation of <code>fib</code> in its result type. </p> <p>The result type of <code>fib</code> is automatically strengthened to the following.</p> <pre>210: fib :: i:Nat -&gt; {v:Nat | v == fib i &amp;&amp; v = fibP i }\n</pre> <p>That is, the result satisfies the <code>fibP</code> predicate exactly reflecting the implementation of <code>fib</code>.</p> <pre>217: fibP i = if i == 0 then 0 else\n218:          if i == 1 then 1 else\n219:          fin (i-1) + fib (i-2)\n</pre>","tags":["reflection"]},{"location":"blogposts/2016-09-18-refinement-reflection.lhs/#step-3-application","title":"Step 3: Application","text":"<p>With the reflected refinement type, each application of <code>fib</code> automatically unfolds the definition of <code>fib</code>  once.  As an example, applying <code>fib</code> to <code>0</code>, <code>1</code>, and <code>2</code> allows us to prove that <code>fib 2 == 1</code>:</p> <pre>231: {-@ fibTwo :: _ -&gt; { fib 2 == 1 } @-}\n232: () -&gt; {VV : () | fib 2 == 1}fibTwo _ = {v : [GHC.Types.Int] | null v &lt;=&gt; false}[{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 0, {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 1, {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 2] *** QED\n</pre> <p>Though valid, the above <code>fibTwo</code> proof is not pretty! </p>","tags":["reflection"]},{"location":"blogposts/2016-09-18-refinement-reflection.lhs/#structuring-proofs","title":"Structuring Proofs","text":"<p>To make our proofs look nice, we use combinators from  the <code>ProofCombinators</code> library, which exports a family  of operators <code>(*.)</code> where <code>*</code> comes from the theory of  linear arithmetic and the refinement type of <code>x *. y</code> </p> <ul> <li>requires that <code>x *. y</code> holds and </li> <li>ensures that the returned value is equal to <code>x</code>.</li> </ul> <p>For example, <code>(==.)</code> and <code>(&lt;=.)</code> are predefined in <code>ProofCombinators</code> as</p> <pre>252: (==.) :: x:a -&gt; y:{a| x==y} -&gt; {v:a| v==x}\n253: x ==. _ = x\n254: \n255: (&lt;=.) :: x:a -&gt; y:{a| x&lt;=y} -&gt; {v:a| v==x}\n256: x &lt;=. _ = x\n</pre> <p>Using these predefined operators, we construct paper and pencil-like proofs  for the <code>fib</code> function.</p> <pre>263: {-@ fibTwoPretty :: { fib 2 == 1 } @-}\n264: {VV : () | fib 2 == 1}fibTwoPretty \n265:   =   {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 2 \n266:   GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int==. {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 1 x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 0 \n267:   *** QED\n</pre>","tags":["reflection"]},{"location":"blogposts/2016-09-18-refinement-reflection.lhs/#because-operator","title":"Because operator","text":"<p>To allow the reuse of existing proofs, <code>ProofCombinators</code> defines the because  operator <code>(\u2235)</code></p> <pre>279: (\u2235) :: (Proof -&gt; a) -&gt; Proof -&gt; a\n280: f \u2235 y = f y\n</pre> <p>For example, <code>fib 3 == 2</code> holds because <code>fib 2 == 1</code>:</p> <pre>286: {-@ fibThree :: _ -&gt; { fib 3 == 2 } @-}\n287: () -&gt; {VV : () | fib 3 == 2}fibThree _ \n288:   =   {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 3 \n289:   GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int==. {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 2 x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 1\n290:   GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int==. GHC.Types.Int1     x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ 1      \u2235 fibTwoPretty\n291:   GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int==. 2 \n292:   *** QED\n</pre>","tags":["reflection"]},{"location":"blogposts/2016-09-18-refinement-reflection.lhs/#proofs-by-induction-ie-recursion","title":"Proofs by Induction (i.e. Recursion)","text":"<p>Next, combining the above operators we specify and prove that  <code>fib</code> is increasing, that is for each natural number <code>i</code>,  <code>fib i &lt;= fib (i+1)</code>. </p> <p>We specify the theorem as a refinement type for <code>fubUp</code> and use Haskell code to persuade Liquid Haskell that  the theorem holds. </p> <pre>309: {-@ fibUp :: i:Nat -&gt; {fib i &lt;= fib (i+1)} @-}\n310: x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}fibUp {v : GHC.Types.Int | v &gt;= 0}i\n311:   | GHC.Types.Booli x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}== 0\n312:   =   {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 0 GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int&lt;. {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 1\n313:   *** QED\n314: \n315:   | GHC.Types.Booli x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}== 1\n316:   =   {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 1 GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int&lt;=. {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 1 x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 0 GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int&lt;=. {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib 2\n317:   *** QED\n318: \n319:   | otherwise\n320:   =   {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib i\n321:   GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int==. {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib (GHC.Types.Intix1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}-1) x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib (GHC.Types.Intix1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}-2)\n322:   GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int&lt;=. {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib i     x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib (GHC.Types.Intix1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}-2) \u2235 x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}fibUp (GHC.Types.Intix1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}-1)\n323:   GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int&lt;=. {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib i     x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib (GHC.Types.Intix1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}-1) \u2235 x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}fibUp (GHC.Types.Intix1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}-2)\n324:   GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int&lt;=. {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib (GHC.Types.Intix1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+1)\n325:   *** QED\n</pre> <p>The proof proceeds by induction on <code>i</code>. </p> <ul> <li> <p>The base cases <code>i == 0</code> and <code>i == 1</code> are represented    as Haskell's case splitting. </p> </li> <li> <p>The inductive hypothesis is represented by recursive calls    on smaller inputs. </p> </li> </ul> <p>Finally, the SMT solves arithmetic reasoning to conclude the proof.  </p>","tags":["reflection"]},{"location":"blogposts/2016-09-18-refinement-reflection.lhs/#higher-order-theorems","title":"Higher Order Theorems","text":"<p>Refinement Reflection can be used to express and verify higher order theorems! For example, <code>fMono</code> specifies that each locally increasing function is monotonic! </p> <pre>345: {-@ fMono :: f:(Nat -&gt; Int)\n346:           -&gt; fUp:(z:Nat -&gt; {f z &lt;= f (z+1)})\n347:           -&gt; x:Nat\n348:           -&gt; y:{Nat|x &lt; y}\n349:           -&gt; {f x &lt;= f y} / [y] \n350:   @-}\n351: x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0\n                                                                                                                                                                                          &amp;&amp; x5 &lt; v} -&gt; {VV : () | x1 x5 &lt;= x1 x6}fMono {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Intf x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | f x1 &lt;= f (x1 + 1)}thm {v : GHC.Types.Int | v &gt;= 0}x {v : GHC.Types.Int | v &gt;= 0\n                     &amp;&amp; x &lt; v}y  \n352:   | GHC.Types.Intx x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ 1 x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}== y\n353:   = {v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}f y GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int==. {v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}f (GHC.Types.Intx x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ 1)\n354:          GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int&gt;. {v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}f x       \u2235 {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}thm x\n355:         *** QED\n356: \n357:   | GHC.Types.Intx x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ 1 x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 &lt; x2}&lt; y\n358:   = {v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}f x\n359:   GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int&lt;.  {v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}f (GHC.Types.Intyx1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}-1)         \u2235 x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0\n                                                                                                                                                                                          &amp;&amp; x5 &lt; v} -&gt; {VV : () | x1 x5 &lt;= x1 x6}fMono {v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}f {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}thm x (GHC.Types.Intyx1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}-1)\n360:   GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int&lt;.  {v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}f y             \u2235 {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}thm (GHC.Types.Intyx1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}-1)\n361:   *** QED\n</pre> <p>Again, the recursive implementation of <code>fMono</code> depicts the paper and pencil  proof of <code>fMono</code> by induction on the decreasing argument <code>/ [y]</code>. </p> <p>Since <code>fib</code> is proven to be locally increasing by <code>fUp</code>, we use <code>fMono</code>  to prove that <code>fib</code> is monotonic. </p> <pre>371: {-@ fibMono :: n:Nat -&gt; m:{Nat | n &lt; m }  -&gt; {fib n &lt;= fib m} @-}\n372: x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:{v : GHC.Types.Int | v &gt;= 0\n                                                           &amp;&amp; x1 &lt; v} -&gt; {VV : () | fib x1 &lt;= fib x2}fibMono = {v : x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0\n                                                                                                                                                                                              &amp;&amp; x5 &lt; v} -&gt; {v : () | x1 x5 &lt;= x1 x6} | v == RefinementReflection.fMono}fMono {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                             &amp;&amp; v == fib x1\n                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}fib {v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | fib x1 &lt;= fib (x1 + 1)} | v == RefinementReflection.fibUp}fibUp\n</pre>","tags":["reflection"]},{"location":"blogposts/2016-09-18-refinement-reflection.lhs/#conclusion","title":"Conclusion","text":"<p>We saw how refinement reflection turns Haskell into a theorem prover by reflecting the code  implementing a Haskell function into the  function\u2019s output refinement type.</p> <p>Refinement Types are used to express theorems,  Haskell code is used to prove such theorems expressing paper pencil proofs, and Liquid Haskell  verifies the validity of the proofs!</p> <p>Proving <code>fib</code> monotonic is great, but this is Haskell! Wouldn\u2019t it be nice to prove theorems about inductive data types  and higher order functions? Like fusions and folds?  Or program equivalence on run-time optimizations like map-reduce?</p> <p>Stay tuned!</p> <p>Even better, if you happen you be in Nara for ICFP'16,  come to my CUFP tutorial for more!</p>","tags":["reflection"]},{"location":"blogposts/2016-10-06-structural-induction.lhs/","title":"Refinement Reflection on ADTs","text":"","tags":["reflection","induction","measures"]},{"location":"blogposts/2016-10-06-structural-induction.lhs/#lists-are-monoids","title":"Lists are Monoids","text":"<p>Previously we saw how Refinement Reflection can be used to write Haskell functions that prove theorems about other Haskell functions. Today, we will see how Refinement Reflection works on recursive data types. As an example, we will prove that lists are monoids (under nil and append).</p> <p>Lets see how to express the monoid laws as liquid types, and then prove the laws by writing plain Haskell functions that are checked by LiquidHaskell.</p> <p></p> <p>         Recursive Paper and Pencil Proofs.        \"Drawing Hands\" by Escher.         </p> <pre>46: {-@ LIQUID \"--higherorder\"     @-}\n47: {-@ LIQUID \"--totality\"        @-}\n48: module StructuralInduction where\n49: import Language.Haskell.Liquid.ProofCombinators\n50: \n51: import Prelude hiding (length)\n52: \n53: length :: List a -&gt; Int\n54: leftId :: List a -&gt; Proof\n55: rightId :: List a -&gt; Proof\n56: associativity :: List a -&gt; List a -&gt; List a -&gt; Proof\n</pre>","tags":["reflection","induction","measures"]},{"location":"blogposts/2016-10-06-structural-induction.lhs/#lists","title":"Lists","text":"<p>First, lets define the <code>List a</code> data type</p> <pre>66: data List a = N | C a (List a)\n</pre>","tags":["reflection","induction","measures"]},{"location":"blogposts/2016-10-06-structural-induction.lhs/#induction-on-lists","title":"Induction on Lists","text":"<p>As we will see, proofs by structural induction will correspond to programs that perform recursion on lists. To keep things legit, we must verify that those programs are total and terminating.</p> <p>To that end, lets define a <code>length</code> function that computes the natural number that is the size of a list.</p> <pre>81: {-@ measure length               @-}\n82: {-@ length      :: List a -&gt; Nat @-}\n83: x1:(StructuralInduction.List a) -&gt; {v : GHC.Types.Int | v &gt;= 0\n                                                        &amp;&amp; v == length x1}length N        = 0\n84: length (C x xs) = {v : GHC.Types.Int | v == (1 : int)}1 x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ {v : GHC.Types.Int | v &gt;= 0\n                     &amp;&amp; v == length xs\n                     &amp;&amp; v == length xs}length xs\n</pre> <p>We lift <code>length</code> in the logic, as a measure.</p> <p>We can now tell Liquid Haskell that when proving termination on recursive functions with a list argument <code>xs</code>, it should check whether the <code>length xs</code> is decreasing.</p> <pre>94: {-@ data List [length] a = N | C {hd :: a, tl :: List a} @-}\n</pre>","tags":["reflection","induction","measures"]},{"location":"blogposts/2016-10-06-structural-induction.lhs/#reflecting-lists-into-the-logic","title":"Reflecting Lists into the Logic","text":"<p>To talk about lists in the logic, we use the annotation</p> <pre>104: {-@ LIQUID \"--exact-data-cons\" @-}\n</pre> <p>which automatically derives measures for</p> <ul> <li>testing if a value has a given data constructor, and</li> <li>extracting the corresponding field's value.</li> </ul> <p>For our example, LH will automatically derive the following functions in the refinement logic.</p> <pre>116: isN :: L a -&gt; Bool         -- Haskell's null\n117: isC :: L a -&gt; Bool         -- Haskell's not . null\n118: \n119: select_C_1 :: L a -&gt; a     -- Haskell's head\n120: select_C_2 :: L a -&gt; L a   -- Haskell's tail\n</pre> <p>A programmer never sees the above operators; they are internally used by LH to reflect Haskell functions into the refinement logic, as we shall see shortly.</p>","tags":["reflection","induction","measures"]},{"location":"blogposts/2016-10-06-structural-induction.lhs/#defining-the-monoid-operators","title":"Defining the Monoid Operators","text":"<p>A structure is a monoid, when it has two operators:</p> <ul> <li>the identity element <code>empty</code> and</li> <li>an associative operator <code>&lt;&gt;</code>.</li> </ul> <p>Lets define these two operators for our <code>List</code>.</p> <ul> <li>the identity element is the empty list, and</li> <li>the associative operator <code>&lt;&gt;</code> is list append.</li> </ul> <pre>141: {-@ reflect empty @-}\n142: empty  :: List a\n143: {VV : (StructuralInduction.List a) | VV == empty\n                                     &amp;&amp; VV == StructuralInduction.N}empty  = N\n144: \n145: {-@ infix   &lt;&gt; @-}\n146: {-@ reflect &lt;&gt; @-}\n147: (&lt;&gt;)           :: List a -&gt; List a -&gt; List a\n148: N        x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; {VV : (StructuralInduction.List a) | VV == &lt;&gt; x1 x2\n                                                                                                           &amp;&amp; VV == (if is_N x1 then x2 else StructuralInduction.C (select_C_1 x1) (&lt;&gt; (select_C_2 x1) x2))}&lt;&gt; (StructuralInduction.List a)ys = ys\n149: (C x xs) &lt;&gt; ys = x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1\n                                                                       &amp;&amp; hd v == x\n                                                                       &amp;&amp; select_C_2 v == x1\n                                                                       &amp;&amp; select_C_1 v == x\n                                                                       &amp;&amp; (is_C v &lt;=&gt; true)\n                                                                       &amp;&amp; (is_N v &lt;=&gt; false)\n                                                                       &amp;&amp; length v == 1 + length x1\n                                                                       &amp;&amp; v == StructuralInduction.C x x1}C x ({VV : (StructuralInduction.List a) | VV == &lt;&gt; xs ys\n                                     &amp;&amp; VV == (if is_N xs then ys else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) ys))\n                                     &amp;&amp; VV == &lt;&gt; xs ys}xs &lt;&gt; ys)\n</pre> <p>LiquidHaskell automatically checked that the recursive <code>(&lt;&gt;)</code> is terminating, by checking that the <code>length</code> of its first argument is decreasing. Since both the above operators are provably terminating, LH lets us reflect them into logic.</p> <p>As with our previous <code>fibonacci</code> example, reflection of a function into logic, means strengthening the result type of the function with its implementation.</p> <p>Thus, the automatically derived, strengthened types for <code>empty</code> and <code>(&lt;&gt;)</code> will be</p> <pre>166: empty   :: {v:List a | v == empty &amp;&amp; v == N }\n167: \n168: (&lt;&gt;) :: xs:List a -&gt; ys:List a\n169:      -&gt; {v:List a | v == xs &lt;&gt; ys &amp;&amp;\n170:                     v == if isN xs then ys else\n171:                          C (select_C_1 xs) (select_C_2 xs &lt;&gt; ys)\n172:         }\n</pre> <p>In effect, the derived checker and selector functions are used to translate Haskell to logic. The above is just to explain how LH reasons about the operators; the programmer never (directly) reads or writes the operators <code>isN</code> or <code>select_C_1</code> etc.</p>","tags":["reflection","induction","measures"]},{"location":"blogposts/2016-10-06-structural-induction.lhs/#proving-the-monoid-laws","title":"Proving the Monoid Laws","text":"<p>Finally, we have set everything up, (actually LiquidHaskell did most of the work for us) and we are ready to prove the monoid laws for the <code>List</code>.</p> <p>First we prove left identity of <code>empty</code>.</p> <pre>190: {-@ leftId  :: x:List a -&gt; { empty &lt;&gt; x == x } @-}\n191: x1:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; empty x1 == x1}leftId (StructuralInduction.List a)x\n192:    =   (StructuralInduction.List a)empty &lt;&gt; x\n193:    (StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)==. (StructuralInduction.List a)N &lt;&gt; x\n194:    (StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)==. x\n195:    *** QED\n</pre> <p>This proof was trivial, because left identity is satisfied by the way we defined <code>(&lt;&gt;)</code>.</p> <p>Next, we prove right identity of <code>empty</code>.</p> <pre>204: {-@ rightId  :: x:List a -&gt; { x &lt;&gt; empty  == x } @-}\n205: x1:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 empty == x1}rightId N\n206:    =   (StructuralInduction.List (GHC.Prim.Any *))N &lt;&gt; empty\n207:    (StructuralInduction.List (GHC.Prim.Any *)) -&gt; (StructuralInduction.List (GHC.Prim.Any *)) -&gt; (StructuralInduction.List (GHC.Prim.Any *))==. N\n208:    *** QED\n209: \n210: rightId (C x xs)\n211:    =   (StructuralInduction.List a)(x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1\n                                                                       &amp;&amp; hd v == x\n                                                                       &amp;&amp; select_C_2 v == x1\n                                                                       &amp;&amp; select_C_1 v == x\n                                                                       &amp;&amp; (is_C v &lt;=&gt; true)\n                                                                       &amp;&amp; (is_N v &lt;=&gt; false)\n                                                                       &amp;&amp; length v == 1 + length x1\n                                                                       &amp;&amp; v == StructuralInduction.C x x1}C x xs) &lt;&gt; empty\n212:    (StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)==. x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1\n                                                                       &amp;&amp; hd v == x\n                                                                       &amp;&amp; select_C_2 v == x1\n                                                                       &amp;&amp; select_C_1 v == x\n                                                                       &amp;&amp; (is_C v &lt;=&gt; true)\n                                                                       &amp;&amp; (is_N v &lt;=&gt; false)\n                                                                       &amp;&amp; length v == 1 + length x1\n                                                                       &amp;&amp; v == StructuralInduction.C x x1}C x ((StructuralInduction.List a)xs &lt;&gt; empty)\n213:    (StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; () -&gt; (StructuralInduction.List a)==. x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1\n                                                                       &amp;&amp; hd v == x\n                                                                       &amp;&amp; select_C_2 v == x1\n                                                                       &amp;&amp; select_C_1 v == x\n                                                                       &amp;&amp; (is_C v &lt;=&gt; true)\n                                                                       &amp;&amp; (is_N v &lt;=&gt; false)\n                                                                       &amp;&amp; length v == 1 + length x1\n                                                                       &amp;&amp; v == StructuralInduction.C x x1}C x xs        \u2235 {VV : () | &lt;&gt; xs empty == xs}rightId xs\n214:    *** QED\n</pre> <p>This proof is more tricky, as it requires structural induction which is encoded in LH proofs simply as recursion.  LH ensures that the inductive hypothesis is appropriately applied by checking that the recursive proof is total and terminating.  In the <code>rightId</code> case, for termination, Liquid Haskell checked that <code>length xs &lt; length (C x xs)</code>.</p> <p>It turns out that we can prove lots of properties about lists using structural induction, encoded in Haskell as</p> <ul> <li>case splitting,</li> <li>recursive calls, and</li> <li>rewriting,</li> </ul> <p>To see a last example, lets prove the associativity of <code>(&lt;&gt;)</code>.</p> <pre>233: {-@ associativity :: x:List a -&gt; y:List a -&gt; z:List a\n234:                   -&gt; { x &lt;&gt; (y &lt;&gt; z) == (x &lt;&gt; y) &lt;&gt; z } @-}\n235: x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; x3:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 (&lt;&gt; x2 x3) == &lt;&gt; (&lt;&gt; x1 x2) x3}associativity N (StructuralInduction.List a)y (StructuralInduction.List a)z\n236:   =   (StructuralInduction.List a)N &lt;&gt; ({v : (StructuralInduction.List a) | v == &lt;&gt; y z\n                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))\n                                    &amp;&amp; v == &lt;&gt; y z}y &lt;&gt; z)\n237:   (StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)==. {v : (StructuralInduction.List a) | v == &lt;&gt; y z\n                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))\n                                    &amp;&amp; v == &lt;&gt; y z}y &lt;&gt; z\n238:   (StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)==. (StructuralInduction.List a)((StructuralInduction.List a)N &lt;&gt; y) &lt;&gt; z\n239:   *** QED\n240: \n241: associativity (C x xs) y z\n242:   =  (StructuralInduction.List a)(x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1\n                                                                       &amp;&amp; hd v == x\n                                                                       &amp;&amp; select_C_2 v == x1\n                                                                       &amp;&amp; select_C_1 v == x\n                                                                       &amp;&amp; (is_C v &lt;=&gt; true)\n                                                                       &amp;&amp; (is_N v &lt;=&gt; false)\n                                                                       &amp;&amp; length v == 1 + length x1\n                                                                       &amp;&amp; v == StructuralInduction.C x x1}C x xs) &lt;&gt; ({v : (StructuralInduction.List a) | v == &lt;&gt; y z\n                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))\n                                    &amp;&amp; v == &lt;&gt; y z}y &lt;&gt; z)\n243:   (StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)==. x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1\n                                                                       &amp;&amp; hd v == x\n                                                                       &amp;&amp; select_C_2 v == x1\n                                                                       &amp;&amp; select_C_1 v == x\n                                                                       &amp;&amp; (is_C v &lt;=&gt; true)\n                                                                       &amp;&amp; (is_N v &lt;=&gt; false)\n                                                                       &amp;&amp; length v == 1 + length x1\n                                                                       &amp;&amp; v == StructuralInduction.C x x1}C x ((StructuralInduction.List a)xs &lt;&gt; ({v : (StructuralInduction.List a) | v == &lt;&gt; y z\n                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))\n                                    &amp;&amp; v == &lt;&gt; y z}y &lt;&gt; z))\n244:   (StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; () -&gt; (StructuralInduction.List a)==. x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1\n                                                                       &amp;&amp; hd v == x\n                                                                       &amp;&amp; select_C_2 v == x1\n                                                                       &amp;&amp; select_C_1 v == x\n                                                                       &amp;&amp; (is_C v &lt;=&gt; true)\n                                                                       &amp;&amp; (is_N v &lt;=&gt; false)\n                                                                       &amp;&amp; length v == 1 + length x1\n                                                                       &amp;&amp; v == StructuralInduction.C x x1}C x ((StructuralInduction.List a)({v : (StructuralInduction.List a) | v == &lt;&gt; xs y\n                                    &amp;&amp; v == (if is_N xs then y else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) y))\n                                    &amp;&amp; v == &lt;&gt; xs y}xs &lt;&gt; y) &lt;&gt; z) \u2235 x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; x3:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 (&lt;&gt; x2 x3) == &lt;&gt; (&lt;&gt; x1 x2) x3}associativity xs y z\n245:   (StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)==. (StructuralInduction.List a)(x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1\n                                                                       &amp;&amp; hd v == x\n                                                                       &amp;&amp; select_C_2 v == x1\n                                                                       &amp;&amp; select_C_1 v == x\n                                                                       &amp;&amp; (is_C v &lt;=&gt; true)\n                                                                       &amp;&amp; (is_N v &lt;=&gt; false)\n                                                                       &amp;&amp; length v == 1 + length x1\n                                                                       &amp;&amp; v == StructuralInduction.C x x1}C x ({v : (StructuralInduction.List a) | v == &lt;&gt; xs y\n                                    &amp;&amp; v == (if is_N xs then y else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) y))\n                                    &amp;&amp; v == &lt;&gt; xs y}xs &lt;&gt; y)) &lt;&gt; z\n246:   (StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)==. (StructuralInduction.List a)((StructuralInduction.List a)(x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1\n                                                                       &amp;&amp; hd v == x\n                                                                       &amp;&amp; select_C_2 v == x1\n                                                                       &amp;&amp; select_C_1 v == x\n                                                                       &amp;&amp; (is_C v &lt;=&gt; true)\n                                                                       &amp;&amp; (is_N v &lt;=&gt; false)\n                                                                       &amp;&amp; length v == 1 + length x1\n                                                                       &amp;&amp; v == StructuralInduction.C x x1}C x xs) &lt;&gt; y) &lt;&gt; z\n247:   *** QED\n</pre> <p>The above proof of associativity reifies the paper and pencil proof by structural induction.</p> <p>With that, we can safely conclude that our user defined list is a monoid!</p>","tags":["reflection","induction","measures"]},{"location":"blogposts/2016-10-06-structural-induction.lhs/#conclusion","title":"Conclusion","text":"<p>We saw how Refinement Reflection can be used to</p> <ul> <li>specify properties of <code>ADTs</code>,</li> <li>naturally encode structural inductive proofs of these properties, and</li> <li>have these proofs machine checked by Liquid Haskell.</li> </ul> <p>Why is this useful? Because the theorems we prove refer to your Haskell functions!  Thus you (or in the future, the compiler) can use properties like monoid or monad laws to optimize your Haskell code.  In the future, we will present examples of code optimizations using monoid laws. Stay tuned!</p>","tags":["reflection","induction","measures"]},{"location":"blogposts/2017-03-20-arithmetic-overflows.lhs/","title":"Arithmetic Overflows","text":"<p>Computers are great at crunching numbers. However, if programmers aren't careful, their machines can end up biting off more than they can chew: simple arithmetic operations over very large (or very tiny) inputs can overflow leading to bizarre crashes or vulnerabilities. For example, Joshua Bloch's classic post argues that nearly all binary searches are broken due to integer overflows. Lets see how we can teach LiquidHaskell to spot such overflows.</p> <pre>30: module Bounded where\n31: \n32: import           Control.Exception (assert)\n33: import           Prelude hiding (Num (..))\n34: import qualified Prelude\n35: \n36: plusStrict :: Int -&gt; Int -&gt; Int\n37: plusLazy   :: Int -&gt; Int -&gt; Int\n38: mono       :: Int -&gt; Bool\n</pre>","tags":["basic"]},{"location":"blogposts/2017-03-20-arithmetic-overflows.lhs/#1-the-problem","title":"1. The Problem","text":"<p>LiquidHaskell, like some programmers, likes to make believe that <code>Int</code> represents the set of integers. For example, you might define a function <code>plus</code> as:</p> <pre>51: {-@ plus :: x:Int -&gt; y:Int -&gt; {v:Int | v == x + y} @-}\n52: plus :: Int -&gt; Int -&gt; Int\n53: x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}plus Intx Inty = {v : Int | v == y}x x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}Prelude.+ y\n</pre> <p>The output type of the function states that the returned value is equal to the \\emph{logical} result of adding the two inputs.</p> <p>The above signature lets us \"prove\" facts like addition by one yields a bigger number:</p> <pre>63: {-@ monoPlus :: Int -&gt; {v:Bool | v &lt;=&gt; true } @-}\n64: monoPlus :: Int -&gt; Bool\n65: Int -&gt; {v : Bool | v &lt;=&gt; true}monoPlus Intx = {v : Int | v == x}x x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; {v : x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2} | v == Bounded.plus}plus x 1\n</pre> <p>Unfortunately, the signature for plus and hence, the above \"fact\" are both lies.</p> <p>LH checks <code>plus</code> as the same signature is assumed for the primitive <code>Int</code> addition operator <code>Prelude.+</code>. LH has to assume some signature for this \"foreign\" machine operation, and by default, LH assumes that machine addition behaves like logical addition.</p> <p>However, this assumption, and its consequences are only true upto a point:</p> <pre><code>\u03bb&gt;  monoPlus 0\nTrue\n\u03bb&gt;  monoPlus 100\nTrue\n\u03bb&gt;  monoPlus 10000\nTrue\n\u03bb&gt;  monoPlus 1000000\nTrue\n</code></pre> <p>Once we get to <code>maxBound</code> at the very edge of <code>Int</code>, a tiny bump is enough to send us tumbling backwards into a twilight zone.</p> <pre><code>\u03bb&gt; monoPlus maxBound\nFalse\n\n\u03bb&gt; plus maxBound 1\n-9223372036854775808\n</code></pre>","tags":["basic"]},{"location":"blogposts/2017-03-20-arithmetic-overflows.lhs/#2-keeping-int-in-their-place","title":"2. Keeping Int In Their Place","text":"<p>The news isn't all bad: the glass half full view is that for \"reasonable\" values like 10, 100, 10000 and 1000000, the machine's arithmetic is the same as logical arithmetic. Lets see how to impart this wisdom to LH. We do this in two steps: define the biggest <code>Int</code> value, and then, use this value to type the arithmetic operations.</p> <p>A. The Biggest Int</p> <p>First, we need a way to talk about \"the edge\" -- i.e. the largest <code>Int</code> value at which overflows occur.</p> <p>We could use the concrete number</p> <pre><code>\u03bb&gt; maxBound :: Int\n9223372036854775807\n</code></pre> <p>However, instead of hardwiring a particular number, a more general strategy is to define a symbolic constant <code>maxInt</code> to represent any arbitrary overflow value and thus, make the type checking robust to different machine integer widths.</p> <pre>135: -- defines an Int constant called `maxInt`\n136: {-@ measure maxInt :: Int @-}\n</pre> <p>To tell LH that <code>maxInt</code> is the \"biggest\" <code>Int</code>, we write a predicate that describes values bounded by <code>maxInt</code>:</p> <pre>144: {-@ predicate Bounded N = 0 &lt; N + maxInt &amp;&amp; N &lt; maxInt @-}\n</pre> <p>Thus, <code>Bounded n</code> means that the number <code>n</code> is in the range <code>[-maxInt, maxInt]</code>.</p> <p>B.  Bounded Machine Arithmetic</p> <p>Next, we can assign the machine arithmetic operations types that properly capture the possibility of arithmetic overflows. Here are two possible specifications.</p> <p>Strict: Thou Shalt Not Overflow A strict specification simply prohibits any overflow:</p> <pre>160: {-@ plusStrict :: x:Int -&gt; y:{Int|Bounded(x+y)} -&gt; {v:Int|v = x+y} @-}\n161: x1:Int -&gt; x2:{y : Int | 0 &lt; (x1 + y) + maxInt\n                        &amp;&amp; x1 + y &lt; maxInt} -&gt; {v : Int | v == x1 + x2}plusStrict Intx {y : Int | 0 &lt; (x + y) + maxInt\n           &amp;&amp; x + y &lt; maxInt}y = {v : Int | 0 &lt; (x + v) + maxInt\n           &amp;&amp; x + v &lt; maxInt\n           &amp;&amp; v == y}x x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}Prelude.+ y\n</pre> <p>The inputs <code>x</code> and <code>y</code> must be such that the result is <code>Bounded</code>, and in that case, the output value is indeed their logical sum.</p> <p>Lazy: Overflow at Thine Own Risk Instead, a lazy specification could permit overflows but gives no guarantees about the output when they occur.</p> <pre>172: {-@ plusLazy :: x:Int -&gt; y:Int -&gt; {v:Int|Bounded(x+y) =&gt; v = x+y} @-}\n173: x1:Int -&gt; x2:Int -&gt; {v : Int | 0 &lt; (x1 + x2) + maxInt\n                               &amp;&amp; x1 + x2 &lt; maxInt =&gt; v == x1 + x2}plusLazy Intx Inty = {v : Int | v == y}x x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}Prelude.+ y\n</pre> <p>The lazy specification says that while <code>plusLazy</code> can be called with any values you like, the result is the logical sum only if there is no overflow.</p> <p>To understand the difference between the two specifications, lets revisit the <code>monoPlus</code> property using the new machine-arithmetic sensitive signatures:</p> <pre>188: {-@ monoPlusStrict :: Int -&gt; {v:Bool | v &lt;=&gt; true } @-}\n189: Int -&gt; {v : Bool | v &lt;=&gt; true}monoPlusStrict Intx = {v : Int | v == x}x x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; {v : x1:Int -&gt; x2:{v : Int | 0 &lt; (x1 + v) + maxInt\n                             &amp;&amp; x1 + v &lt; maxInt} -&gt; {v : Int | v == x1 + x2} | v == Bounded.plusStrict}plusStrict x 1\n190: \n191: {-@ monoPlusLazy :: Int -&gt; {v:Bool | v &lt;=&gt; true } @-}\n192: Int -&gt; {v : Bool | v &lt;=&gt; true}monoPlusLazy Intx = {v : Int | v == x}x x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; {v : x1:Int -&gt; x2:Int -&gt; {v : Int | 0 &lt; (x1 + x2) + maxInt\n                                    &amp;&amp; x1 + x2 &lt; maxInt =&gt; v == x1 + x2} | v == Bounded.plusLazy}plusLazy x 1\n</pre> <p>Both are rejected by LH, since, as we saw earlier, the functions do not always evaluate to <code>True</code>. However, in the strict version the error is at the possibly overflowing call to <code>plusStrict</code>. In the lazy version, the call to <code>plusLazy</code> is accepted, but as the returned value is some arbitrary <code>Int</code> (not the logical <code>x+1</code>), the comparison may return <code>False</code> hence the output is not always <code>True</code>.</p> <p>Exercise: Can you fix the specification for <code>monoPlusStrict</code> and <code>monoPlusLazy</code> to get LH to verify the implementation?</p>","tags":["basic"]},{"location":"blogposts/2017-03-20-arithmetic-overflows.lhs/#3-a-typeclass-for-machine-arithmetic","title":"3. A Typeclass for Machine Arithmetic","text":"<p>Its a bit inconvenient to write <code>plusStrict</code> and <code>plusLazy</code>, and really, we'd just like to write <code>+</code> and <code>-</code> and so on. We can do so, by tucking the above specifications into a bounded numeric typeclass whose signatures capture machine arithmetic. First, we define a <code>BoundedNum</code> variant of <code>Num</code></p> <pre>220: class BoundedNum a where\n221:   (+) :: a -&gt; a -&gt; a\n222:   (-) :: a -&gt; a -&gt; a\n223:   -- other operations ...\n</pre> <p>and now, we can define its <code>Int</code> instance just as wrappers around the <code>Prelude</code> operations:</p> <pre>230: instance BoundedNum Int where\n231:   Intx x1:Int -&gt; x2:{y : Int | 0 &lt; (x1 + y) + maxInt\n                        &amp;&amp; x1 + y &lt; maxInt} -&gt; {v : Int | v == x1 + x2}+ {y : Int | 0 &lt; (x + y) + maxInt\n           &amp;&amp; x + y &lt; maxInt}y = {v : Int | 0 &lt; (x + v) + maxInt\n           &amp;&amp; x + v &lt; maxInt\n           &amp;&amp; v == y}x x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}Prelude.+ y\n232:   Intx x1:Int -&gt; x2:{y : Int | 0 &lt; (x1 - y) + maxInt\n                        &amp;&amp; x1 - y &lt; maxInt} -&gt; {v : Int | v == x1 - x2}- {y : Int | 0 &lt; (x - y) + maxInt\n           &amp;&amp; x - y &lt; maxInt}y = {v : Int | 0 &lt; (x - v) + maxInt\n           &amp;&amp; x - v &lt; maxInt\n           &amp;&amp; v == y}x x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 - x2}Prelude.- y\n</pre> <p>Finally, we can tell LH that the above above instance obeys the (strict) specifications for machine arithmetic:</p> <pre>239: {-@ instance BoundedNum Int where\n240:       + :: x:Int -&gt; y:{Int | Bounded (x+y)} -&gt; {v:Int | v == x+y };\n241:       - :: x:Int -&gt; y:{Int | Bounded (x-y)} -&gt; {v:Int | v == x-y }\n242:   @-}\n</pre> <p>With the above instance in scope, we can just use the plain <code>+</code> operator and have LH flag potential overflows:</p> <pre>249: {-@ mono :: Int -&gt; {v:Bool | v &lt;=&gt; true} @-}\n250: Int -&gt; {v : Bool | v &lt;=&gt; true}mono Intx = {v : Int | v == x}x x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; Intx + 1\n</pre>","tags":["basic"]},{"location":"blogposts/2017-03-20-arithmetic-overflows.lhs/#4-an-application-binary-search","title":"4. An Application: Binary Search","text":"<p>The above seems a bit paranoid. Do overflows really matter? And if they do, is it really practical to check for them using the above?</p> <p>Joshua Bloch's famous article describes a tricky overflow bug in an implementation of binary-search that lay hidden in plain sight in classic textbooks and his own implementation in the JDK for nearly a decade. Gabriel Gonzalez wrote a lovely introduction to LH using binary-search as an example, and a careful reader pointed out that it had the same overflow bug!</p> <p>Lets see how we might spot and fix such bugs using <code>BoundedNum</code>.  (Hover over the images to animate.)</p>  **A. Off by One** Lets begin by just using the default `Num Int` which ignores overflow. As Gabriel explains, LH flags a bunch of errors if we start the search with `loop x v 0 n` as the resulting search can access `v` at any index between `0` and `n` inclusive, which may lead to an out of bounds at `n`. We can fix the off-by-one by correcting the upper bound to `n-1`, at which point LH reports the code free of errors.  <p></p>  **B. Lots of Overflows** To spot arithmetic overflows, we need only hide the default `Prelude` and instead import the `BoundedNum` instance described above. Upon doing so, LH flags a whole bunch of potential errors -- essentially *all* the arithmetic operations which seems rather dire!   **C. Vector Sizes are Bounded** Of course, things aren't _so_ bad. LH is missing the information that the size of any `Vector` must be `Bounded`. Once we inform LH about this invariant with the [`using` directive][lh-invariants], it infers that as the `lo` and `hi` indices are upper-bounded by the `Vector`'s size, all the arithmetic on them is also `Bounded` and hence, free of overflows.  <p></p>  **D. Staying In The Middle** Well, *almost* all. The one pesky pink highlight that remains is exactly the bug that Bloch made famous. Namely: the addition used to compute the new midpoint between `lo` and `hi` could overflow e.g. if the array was large and both those indices were near the end. To ensure the machine doesn't choke, we follow Bloch's suggestion and re-jigger the computation to instead compute the midpoint by splitting the difference between `hi` and `lo`! the code is now free of arithmetic overflows and truly memory safe.","tags":["basic"]},{"location":"blogposts/2017-12-15-splitting-and-splicing-intervals-I.lhs/","title":"Splitting and Splicing Intervals (Part 1)","text":"<p>Joachim Breitner wrote a cool post describing a library for representing sets of integers as sorted lists of intervals, and how they were able to formally verify the code by translating it to Coq using their nifty new tool.</p> <ul> <li> <p>First, lets just see how plain refinement types   let us specify the key \"goodness\" invariant,   and check it automatically.</p> </li> <li> <p>Next, we'll see how LH's new \"type-level computation\"   abilities let us specify and check \"correctness\",   and even better, understand why the code works.</p> </li> </ul> <p>(Click here to demo)</p> <pre>41: {-@ LIQUID \"--short-names\"    @-}\n42: {-@ LIQUID \"--exact-data-con\" @-}\n43: {-@ LIQUID \"--no-adt\"         @-}\n44: {-@ LIQUID \"--prune-unsorted\" @-}\n45: {-@ LIQUID \"--higherorder\"    @-}\n46: {-@ LIQUID \"--no-termination\" @-}\n47: \n48: module Intervals where\n49: \n50: data Interval  = I\n51:   { from :: Int\n52:   , to   :: Int\n53:   } deriving ((Show Interval)Show)\n54: \n</pre>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-15-splitting-and-splicing-intervals-I.lhs/#encoding-sets-as-intervals","title":"Encoding Sets as Intervals","text":"<p>The key idea underlying the intervals data structure, is that we can represent sets of integers like:</p> <pre><code>{ 7, 1, 10, 3, 11, 2, 9, 12, 4}\n</code></pre> <p>by first ordering them into a list</p> <pre><code>[ 1, 2, 3, 4, 7, 9, 10, 11, 12 ]\n</code></pre> <p>and then partitioning the list into compact intervals</p> <pre><code>[ (1, 5), (7, 8), (9, 13) ]\n</code></pre> <p>That is,</p> <ol> <li> <p>Each interval <code>(from, to)</code> corresponds to the set    <code>{from,from+1,...,to-1}</code>.</p> </li> <li> <p>Ordering ensures there is a canonical representation    that simplifies interval operations.</p> </li> </ol>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-15-splitting-and-splicing-intervals-I.lhs/#making-illegal-intervals-unrepresentable","title":"Making Illegal Intervals Unrepresentable","text":"<p>We require that the list of intervals be \"sorted, non-empty, disjoint and non-adjacent\". Lets follow the slogan of make-illegal-values-unrepresentable to see how we can encode the legality constraints with refinements.</p> <p>A Single Interval</p> <p>We can ensure that each interval is non-empty by refining the data type for a single interval to specify that the <code>to</code> field must be strictly bigger than the <code>from</code> field:</p> <pre>104: {-@ data Interval = I\n105:       { from :: Int\n106:       , to   :: {v: Int | from &lt; v }\n107:       }\n108:   @-}\n</pre> <p>Now, LH will ensure that we can only construct legal, non-empty <code>Interval</code>s</p> <pre>115: IntervalgoodItv = {v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I 10 20\n116: IntervalbadItv  = {v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I 20 10     -- ILLEGAL: empty interval!\n</pre> <p>Many Intervals</p> <p>We can represent arbitrary sets as a list of <code>Interval</code>s:</p> <pre>124: data Intervals = Intervals { itvs :: [Interval] }\n</pre> <p>The plain Haskell type doesn't have enough teeth to enforce legality, specifically, to ensure ordering and the absence of overlaps. Refinements to the rescue!</p> <p>First, we specify a lower-bounded <code>Interval</code> as:</p> <pre>134: {-@ type LbItv N = {v:Interval | N &lt;= from v} @-}\n</pre> <p>Intuitively, an <code>LbItv n</code> is one that starts (at or) after <code>n</code>.</p> <p>Next, we use the above to define an ordered list of lower-bounded intervals:</p> <pre>143: {-@ type OrdItvs N = [LbItv N]&lt;{\\vHd vTl -&gt; to vHd &lt;= from vTl}&gt; @-}\n</pre> <p>The signature above uses an abstract-refinement to capture the legality requirements.</p> <ol> <li> <p>An <code>OrdInterval N</code> is a list of <code>Interval</code> that are    lower-bounded by <code>N</code>, and</p> </li> <li> <p>In each sub-list, the head <code>Interval</code> <code>vHd</code> precedes    each in the tail <code>vTl</code>.</p> </li> </ol>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-15-splitting-and-splicing-intervals-I.lhs/#legal-intervals","title":"Legal Intervals","text":"<p>We can now describe legal <code>Intervals</code> simply as:</p> <pre>161: {-@ data Intervals = Intervals { itvs :: OrdItvs 0 } @-}\n</pre> <p>LH will now ensure that illegal <code>Intervals</code> are not representable.</p> <pre>167: IntervalsgoodItvs  = {v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1\n                                                                     &amp;&amp; lqdc##$select v == x1\n                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}Intervals [{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I 1 5, {v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I 7 8, {v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I 9 13]  -- LEGAL\n168: \n169: IntervalsbadItvs1  = {v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1\n                                                                     &amp;&amp; lqdc##$select v == x1\n                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}Intervals [{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I 1 7, {v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I 5 8]          -- ILLEGAL: overlap!\n170: IntervalsbadItvs2  = {v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1\n                                                                     &amp;&amp; lqdc##$select v == x1\n                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}Intervals [{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I 1 5, {v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I 9 13, {v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I 7 8]  -- ILLEGAL: disorder!\n</pre> <p>Do the types really capture the legality requirements? In the original code, Breitner described goodness as a recursively defined predicate that takes an additional lower bound <code>lb</code> and returns <code>True</code> iff the representation was legal:</p> <pre>180: goodLIs :: Int -&gt; [Interval] -&gt; Bool\n181: x1:{v : Int | v &gt;= 0} -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; {v : Bool | v}goodLIs _ []              = True\n182: goodLIs lb ((I f t) : is) = Boollb x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}&lt;= f {v : x1:Bool -&gt; x2:Bool -&gt; {v : Bool | v &lt;=&gt; x1\n                                             &amp;&amp; x2} | v == GHC.Classes.&amp;&amp;}&amp;&amp; {v : Bool | v &lt;=&gt; f &lt; t}f x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; t {v : x1:Bool -&gt; x2:Bool -&gt; {v : Bool | v &lt;=&gt; x1\n                                             &amp;&amp; x2} | v == GHC.Classes.&amp;&amp;}&amp;&amp; x1:{v : Int | v &gt;= 0} -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; {v : Bool | v}goodLIs t is\n</pre> <p>We can check that our type-based representation is indeed legit by checking that <code>goodLIs</code> returns <code>True</code> whenever it is called with a valid of <code>OrdItvs</code>:</p> <pre>190: {-@ goodLIs :: lb:Nat -&gt; is:OrdItvs lb -&gt; {v : Bool | v } @-}\n</pre>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-15-splitting-and-splicing-intervals-I.lhs/#algorithms-on-intervals","title":"Algorithms on Intervals","text":"<p>We represent legality as a type, but is that good for? After all, we could, as seen above, just as well have written a predicate <code>goodLIs</code>? The payoff comes when it comes to using the <code>Intervals</code> e.g. to implement various set operations.</p> <p>For example, here's the code for intersecting two sets, each represented as intervals. We've made exactly one change to the function implemented by Breitner: we added the extra lower-bound parameter <code>lb</code> to the recursive <code>go</code> to make clear that the function takes two <code>OrdItvs lb</code> and returns an <code>OrdItvs lb</code>.</p> <pre>210: intersect :: Intervals -&gt; Intervals -&gt; Intervals\n211: Intervals -&gt; Intervals -&gt; Intervalsintersect (Intervals is1) (Intervals is2) = {v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1\n                                                                     &amp;&amp; lqdc##$select v == x1\n                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}Intervals ({v : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] | v == go}go 0 is1 is2)\n212:   where\n213:     {-@ go :: lb:Int -&gt; OrdItvs lb -&gt; OrdItvs lb -&gt; OrdItvs lb @-}\n214:     x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go _ _ [] = []\n215:     go _ [] _ = []\n216:     go lb (i1@(I f1 t1) : is1) (i2@(I f2 t2) : is2)\n217:       -- reorder for symmetry\n218:       | {v : Bool | v &lt;=&gt; t1 &lt; t2}t1 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; t2   = x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go lb (i2:is2) (i1:is1)\n219:       -- disjoint\n220:       | {v : Bool | v &lt;=&gt; f1 &gt;= t2}f1 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}&gt;= t2  = x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go lb (i1:is1) is2\n221:       -- subset\n222:       | {v : Bool | v &lt;=&gt; t1 == t2}t1 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 == x2}== t2  = {v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I f' t2 : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go t2 is1 is2\n223:       -- overlapping\n224:       | {v : Bool | v &lt;=&gt; f2 &lt; f1}f2 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; f1   = ({v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I f' t2 : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go t2 ({v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I t2 t1 : is1) is2)\n225:       | otherwise = x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go lb ({v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I f2 t1 : is1) (i2:is2)\n226:       where {v : Int | v == (if f1 &gt; f2 then f1 else f2)}f'    = x1:Int -&gt; x2:Int -&gt; {v : Int | v == (if x1 &gt; x2 then x1 else x2)}max f1 f2\n</pre>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-15-splitting-and-splicing-intervals-I.lhs/#internal-vs-external-verification","title":"Internal vs External Verification","text":"<p>By representing legality internally as a refinement type, as opposed to externally as predicate (<code>goodLIs</code>) we have exposed enough information about the structure of the values that LH can automatically chomp through the above code to guarantee that we haven't messed up the invariants.</p> <p>To appreciate the payoff, compare to the effort needed to verify legality using the external representation used in the hs-to-coq proof.</p> <p>The same principle and simplification benefits apply to both the <code>union</code></p> <pre>245: union :: Intervals -&gt; Intervals -&gt; Intervals\n246: Intervals -&gt; Intervals -&gt; Intervalsunion (Intervals is1) (Intervals is2) = {v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1\n                                                                     &amp;&amp; lqdc##$select v == x1\n                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}Intervals ({v : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] | v == go}go 0 is1 is2)\n247:   where\n248:     {-@ go :: lb:Int -&gt; OrdItvs lb -&gt; OrdItvs lb -&gt; OrdItvs lb @-}\n249:     x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go _ [Interval]is [] = is\n250:     go _ [] is = is\n251:     go lb (i1@(I f1 t1) : is1) (i2@(I f2 t2) : is2)\n252:       -- reorder for symmetry\n253:       | {v : Bool | v &lt;=&gt; t1 &lt; t2}t1 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; t2 = x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go lb (i2:is2) (i1:is1)\n254:       -- disjoint\n255:       | {v : Bool | v &lt;=&gt; f1 &gt; t2}f1 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt; x2}&gt; t2 = i2 : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go t2 (i1:is1) is2\n256:       -- overlapping\n257:       | otherwise  = x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go lb ( ({v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I f' t1) : is1) is2\n258:       where\n259:         {v : Int | v == (if f1 &lt; f2 then f1 else f2)}f' = x1:Int -&gt; x2:Int -&gt; {v : Int | v == (if x1 &lt; x2 then x1 else x2)}min f1 f2\n</pre> <p>and the <code>subtract</code> functions too:</p> <pre>265: subtract :: Intervals -&gt; Intervals -&gt; Intervals\n266: Intervals -&gt; Intervals -&gt; Intervalssubtract (Intervals is1) (Intervals is2) = {v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1\n                                                                     &amp;&amp; lqdc##$select v == x1\n                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}Intervals ({v : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] | v == go}go 0 is1 is2)\n267:   where\n268:     {-@ go :: lb:Int -&gt; OrdItvs lb -&gt; OrdItvs lb -&gt; OrdItvs lb @-}\n269:     x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go _ [Interval]is [] = is\n270:     go _ [] _  = []\n271:     go lb (i1@(I f1 t1) : is1) (i2@(I f2 t2) : is2)\n272:       -- i2 past i1\n273:       | {v : Bool | v &lt;=&gt; t1 &lt;= f2}t1 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}&lt;= f2  = (i1 : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go t1 is1 (i2:is2))\n274:       -- i1 past i2\n275:       | {v : Bool | v &lt;=&gt; t2 &lt;= f1}t2 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}&lt;= f1  = (x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go lb (i1:is1) is2)\n276:       -- i1 contained in i2\n277:       | {v : Bool | v &lt;=&gt; f2 &lt;= f1}f2 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}&lt;= f1, {v : Bool | v &lt;=&gt; t1 &lt;= t2}t1 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}&lt;= t2 = x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go lb is1 (i2:is2)\n278:       -- i2 covers beginning of i1\n279:       | {v : Bool | v &lt;=&gt; f2 &lt;= f1}f2 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}&lt;= f1 = x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go t2 ({v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I t2 t1 : is1) is2\n280:       -- -- i2 covers end of i1\n281:       | {v : Bool | v &lt;=&gt; t1 &lt;= t2}t1 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}&lt;= t2 = (({v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I f1 f2) : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go f2 is1 (i2:is2))\n282:       -- i2 in the middle of i1\n283:       | otherwise = ({v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I f1 f2 : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]go f2 ({v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2\n                                                        &amp;&amp; Intervals.from v == x1\n                                                        &amp;&amp; lqdc##$select v == x2\n                                                        &amp;&amp; lqdc##$select v == x1\n                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}I t2 t1 : is1) is2)\n</pre> <p>both of which require non-trivial proofs in the external style. (Of course, its possible those proofs can be simplified.)</p>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-15-splitting-and-splicing-intervals-I.lhs/#summing-up-and-looking-ahead","title":"Summing Up (and Looking Ahead)","text":"<p>I hope the above example illustrates why \"making illegal states\" unrepresentable is a great principle for engineering code and proofs.</p> <p>That said, notice that with hs-to-coq, Breitner was able to go far beyond the above legality requirement: he was able to specify and verify the far more important (and difficult) property that the above is a correct implementation of a Set library.</p> <p>Is it even possible, let alone easier to do that with LH?</p>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-24-splitting-and-splicing-intervals-II.lhs/","title":"Splitting and Splicing Intervals (Part 2)","text":"<p>Previously, we saw how the principle of \"making illegal states unrepresentable\" allowed LH to easily enforce a key invariant in Joachim Breitner's library for representing sets of integers as sorted lists of intervals.</p> <p>However, Hs-to-coq let Breitner specify and verify that his code properly implemented a set library. Today, lets see how LH's new \"type-level computation\" abilities let us reason about the sets of values corresponding to intervals, while using the SMT solver to greatly simplify the overhead of proof.</p> <p>(Click here to demo)</p> <pre>42: {-@ LIQUID \"--short-names\"    @-}\n43: {-@ LIQUID \"--exact-data-con\" @-}\n44: {-@ LIQUID \"--no-adt\"         @-}\n45: {-@ LIQUID \"--higherorder\"    @-}\n46: {-@ LIQUID \"--diff\"           @-}\n47: {-@ LIQUID \"--ple\"            @-}\n48: \n49: module RangeSet where\n50: \n51: import           Prelude hiding (min, max)\n52: import           Language.Haskell.Liquid.NewProofCombinators\n</pre>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-24-splitting-and-splicing-intervals-II.lhs/#intervals","title":"Intervals","text":"<p>Recall that the key idea is to represent sets of integers like</p> <pre><code>{ 7, 1, 10, 3, 11, 2, 9, 12, 4}\n</code></pre> <p>as ordered lists of intervals</p> <pre><code>[ (1, 5), (7, 8), (9, 13) ]\n</code></pre> <p>where each pair <code>(i, j)</code> represents the set <code>{i, i+1,..., j-1}</code>.</p> <p>To verify that the implementation correctly implements a set data type, we need a way to</p> <ol> <li>Specify the set of values being described,</li> <li>Establish some key properties of these sets.</li> </ol>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-24-splitting-and-splicing-intervals-II.lhs/#range-sets-semantics-of-intervals","title":"Range-Sets: Semantics of Intervals","text":"<p>We can describe the set of values corresponding to (i.e. \"the semantics of\") an interval <code>i, j</code> by importing the <code>Data.Set</code> library</p> <pre>88: import qualified Data.Set as S\n</pre> <p>to write a function <code>rng i j</code> that defines the range-set <code>i..j</code></p> <pre>94: {-@ reflect rng @-}\n95: {-@ rng :: i:Int -&gt; j:Int -&gt; S.Set Int / [j - i] @-}\n96: Int -&gt; Int -&gt; (Set Int)rng Inti Intj\n97:   | {v : Bool | v &lt;=&gt; i &lt; j}i x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; j     = x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}S.union ({v : (Set Int) | v == Set_sng i}S.singleton i) (Int -&gt; Int -&gt; (Set Int)rng (Intix1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}+1) j)\n98:   | otherwise = S.empty\n</pre> <p>The <code>reflect rng</code> tells LH that we are going to want to work with the Haskell function <code>rng</code> at the refinement-type level.</p>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-24-splitting-and-splicing-intervals-II.lhs/#equational-reasoning","title":"Equational Reasoning","text":"<p>To build up a little intuition about the above definition and how LH reasons about Sets, lets write some simple unit proofs. For example, lets check that <code>2</code> is indeed in the range-set <code>rng 1 3</code>, by writing a type signature</p> <pre>116: {-@ test1 :: () -&gt; { S.member 2 (rng 1 3) } @-}\n</pre> <p>Any implementation of the above type is a proof that <code>2</code> is indeed in <code>rng 1 3</code>. Notice that we can reuse the operators from <code>Data.Set</code> (here, <code>S.member</code>) to talk about set operations in the refinement logic. Lets write this proof in an equational style:</p> <pre>126: () -&gt; {VV : () | Set_mem 2 (RangeSet.rng 1 3)}test1 ()\n127:   =   x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}S.member 2 ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng 1 3)\n128:       -- by unfolding `rng 1 3`\n129:   === x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}S.member 2 (x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}S.union ((Set Int)S.singleton 1) ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng 2 3))\n130:       -- by unfolding `rng 2 3`\n131:   === x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}S.member 2 (x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}S.union ((Set Int)S.singleton 1)\n132:                           (x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}S.union ((Set Int)S.singleton 2) ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng 3 3)))\n133:       -- by set-theory\n134:   === True\n135:   *** QED\n</pre> <p>the \"proof\" uses two library operators:</p> <ul> <li> <p><code>e1 === e2</code> is an implicit equality   that checks <code>e1</code> is indeed equal to <code>e2</code> after   unfolding functions at most once, and returns   a term that equals <code>e1</code> and <code>e2</code>, and</p> </li> <li> <p><code>e *** QED</code> converts any term <code>e</code>   into a proof.</p> </li> </ul> <p>The first two steps of <code>test1</code>, simply unfold <code>rng</code> and the final step uses the SMT solver's decision procedure for sets to check equalities over set operations like <code>S.union</code>, <code>S.singleton</code> and <code>S.member</code>.</p>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-24-splitting-and-splicing-intervals-II.lhs/#reusing-proofs","title":"Reusing Proofs","text":"<p>Next, lets check that:</p> <pre>160: {-@ test2 :: () -&gt; { S.member 2 (rng 0 3) } @-}\n161: () -&gt; {VV : () | Set_mem 2 (RangeSet.rng 0 3)}test2 ()\n162:   =   x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}S.member 2 ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng 0 3)\n163:       -- by unfolding and set-theory\n164:   === (Bool2 x1:Integer -&gt; x2:Integer -&gt; {v : Bool | v &lt;=&gt; x1 == x2}== 0 {v : x1:Bool -&gt; x2:Bool -&gt; {v : Bool | v &lt;=&gt; x1\n                                             || x2} | v == GHC.Classes.||}|| x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}S.member 2 ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng 1 3))\n165:       -- by re-using test1 as a lemma\n166:   ==? True ? {v : () -&gt; {v : () | Set_mem 2 (RangeSet.rng 1 3)} | v == RangeSet.test1}test1 ()\n167:   *** QED\n</pre> <p>We could do the proof by unfolding in the equational style. However, <code>test1</code> already establishes that <code>S.member 2 (rng 1 3)</code> and we can reuse this fact using:</p> <ul> <li><code>e1 ==? e2 ? pf</code> an explicit equality   which checks that <code>e1</code> equals <code>e2</code> because of the   extra facts asserted by the <code>Proof</code> named <code>pf</code>   (in addition to unfolding functions at most once)   and returns a term that equals both <code>e1</code> and <code>e2</code>.</li> </ul>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-24-splitting-and-splicing-intervals-II.lhs/#proof-by-logical-evaluation","title":"Proof by Logical Evaluation","text":"<p>Equational proofs like <code>test1</code> and <code>test2</code> often have long chains of calculations that can be tedious to spell out. Fortunately, we taught LH a new trick called Proof by Logical Evaluation (PLE) that optionally shifts the burden of performing those calculations onto the machine. For example, PLE completely automates the above proofs:</p> <pre>194: {-@ test1_ple :: () -&gt; { S.member 2 (rng 1 3) } @-}\n195: () -&gt; {VV : () | Set_mem 2 (RangeSet.rng 1 3)}test1_ple () = ()\n196: \n197: {-@ test2_ple :: () -&gt; { S.member 2 (rng 0 3) } @-}\n198: () -&gt; {VV : () | Set_mem 2 (RangeSet.rng 0 3)}test2_ple () = ()\n</pre> <p>Be Warned! While automation is cool, it can be very helpful to first write out all the steps of an equational proof, at least while building up intuition.</p>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-24-splitting-and-splicing-intervals-II.lhs/#proof-by-induction","title":"Proof by Induction","text":"<p>At this point, we have enough tools to start proving some interesting facts about range-sets. For example, if <code>x</code> is outside the range <code>i..j</code> then it does not belong in <code>rng i j</code>:</p> <pre>216: {-@ lem_mem :: i:_ -&gt; j:_ -&gt; x:{x &lt; i || j &lt;= x} -&gt;\n217:                  { not (S.member x (rng i j)) } / [j - i]\n218:   @-}\n</pre> <p>We will prove the above \"by induction\". A confession: I always had trouble understanding what exactly proof by induction really meant. Why was it it ok to \"do\" induction on one thing but not another?</p> <p>Induction is Recursion</p> <p>Fortunately, with LH, induction is just recursion. That is,</p> <ol> <li> <p>We can recursively use the same theorem we    are trying to prove, but</p> </li> <li> <p>We must make sure that the recursive function/proof    terminates.</p> </li> </ol> <p>The proof makes this clear:</p> <pre>239: x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1\n                                  || x2 &lt;= v} -&gt; {VV : () | not (Set_mem x3 (RangeSet.rng x1 x2))}lem_mem Inti Intj {v : Int | v &lt; i\n           || j &lt;= v}x\n240:   | {v : Bool | v &lt;=&gt; i &gt;= j}i x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}&gt;= j\n241:       -- BASE CASE\n242:   =   {v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}not (x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}S.member x ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng i j))\n243:       -- by unfolding\n244:   === {v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}not (x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}S.member x S.empty)\n245:       -- by set-theory\n246:   === True *** QED\n247: \n248:   | {v : Bool | v &lt;=&gt; i &lt; j}i x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; j\n249:       -- INDUCTIVE CASE\n250:   =   {v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}not (x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}S.member x ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng i j))\n251:       -- by unfolding\n252:   === {v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}not (x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}S.member x (x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}S.union ({v : (Set Int) | v == Set_sng i}S.singleton i) ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng (Intix1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}+1) j)))\n253:       -- by set-theory\n254:   === {v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}not (x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}S.member x ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng (Intix1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}+1) j))\n255:       -- by \"induction hypothesis\"\n256:   ==? True ? x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1\n                                  || x2 &lt;= v} -&gt; {VV : () | not (Set_mem x3 (RangeSet.rng x1 x2))}lem_mem (Inti x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}+ 1) j x *** QED\n</pre> <p>There are two cases.</p> <ul> <li> <p>Base Case: As <code>i &gt;= j</code>, we know <code>rng i j</code> is empty, so <code>x</code>   cannot be in it.</p> </li> <li> <p>Inductive Case As <code>i &lt; j</code> we can unfold <code>rng i j</code> and   then recursively call <code>lem_mem (i+1) j</code> to obtain the fact   that <code>x</code> cannot be in <code>i+1..j</code> to complete the proof.</p> </li> </ul> <p>LH automatically checks that the proof:</p> <ol> <li> <p>Accounts for all cases, as otherwise the    function is not total i.e. like the <code>head</code> function    which is only defined on non-empty lists.    (Try deleting a case at the demo to see what happens.)</p> </li> <li> <p>Terminates, as otherwise the induction    is bogus, or in math-speak, not well-founded.    We use the explicit termination metric <code>/ [j-i]</code> as a hint to tell LH that in each recursive call,    the size of the interval <code>j-i</code> shrinks and is    always non-negative. LH checks that is indeed the case,    ensuring that we have a legit proof by induction.</p> </li> </ol> <p>Proof by Evaluation</p> <p>Once you get the hang of the above style, you get tired of spelling out all the details. Logical evaluation lets us eliminate all the boring calculational steps, leaving the essential bits: the recursive (inductive) skeleton</p> <pre>291: {-@ lem_mem_ple :: i:_ -&gt; j:_ -&gt; x:{x &lt; i || j &lt;= x} -&gt;\n292:                      {not (S.member x (rng i j))} / [j-i]\n293:   @-}\n294: x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1\n                                  || x2 &lt;= v} -&gt; {VV : () | not (Set_mem x3 (RangeSet.rng x1 x2))}lem_mem_ple Inti Intj {v : Int | v &lt; i\n           || j &lt;= v}x\n295:   | {v : Bool | v &lt;=&gt; i &gt;= j}i x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}&gt;= j =  ()\n296:   | {v : Bool | v &lt;=&gt; i &lt; j}i x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; j  =  x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1\n                                  || x2 &lt;= v} -&gt; {VV : () | not (Set_mem x3 (RangeSet.rng x1 x2))}lem_mem_ple (Inti x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}+ 1) j x\n</pre> <p>The above is just <code>lem_mem</code> sans the (PLE-synthesized) intermediate equalities.</p>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-24-splitting-and-splicing-intervals-II.lhs/#disjointness","title":"Disjointness","text":"<p>We say that two sets are disjoint if their <code>intersection</code> is <code>empty</code>:</p> <pre>309: {-@ inline disjoint @-}\n310: disjoint :: S.Set Int -&gt; S.Set Int -&gt; Bool\n311: x1:(Set Int) -&gt; x2:(Set Int) -&gt; {VV : Bool | VV &lt;=&gt; Set_cap x1 x2 == Set_empty 0}disjoint (Set Int)a (Set Int)b = x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cap x1 x2}S.intersection a b x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; x1 == x2}== S.empty\n</pre> <p>Lets prove that two intervals are disjoint if the first ends before the second begins:</p> <pre>318: {-@ lem_disj :: i1:_ -&gt; j1:_ -&gt; i2:{j1 &lt;= i2} -&gt; j2:_ -&gt;\n319:                   {disjoint (rng i1 j1) (rng i2 j2)} / [j2-i2]\n320:   @-}\n</pre> <p>This proof goes \"by induction\" on the size of the second interval, i.e. <code>j2-i2</code>:</p> <pre>327: x1:Int -&gt; x2:Int -&gt; x3:{i2 : Int | x2 &lt;= i2} -&gt; x4:Int -&gt; {VV : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0}lem_disj Inti1 Intj1 {i2 : Int | j1 &lt;= i2}i2 Intj2\n328:   | {v : Bool | v &lt;=&gt; i2 &gt;= j2}i2 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}&gt;= j2\n329:       -- Base CASE\n330:   =   {v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}disjoint ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng i1 j1) ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng i2 j2)\n331:       -- by unfolding\n332:   === {v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}disjoint ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng i1 j1) S.empty\n333:       -- by set-theory\n334:   === True\n335:   *** QED\n336: \n337:   | {v : Bool | v &lt;=&gt; i2 &lt; j2}i2 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; j2\n338:       -- Inductive CASE\n339:   =   {v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}disjoint ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng i1 j1) ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng i2 j2)\n340:       -- by unfolding\n341:   === {v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}disjoint ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng i1 j1) (x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}S.union ({v : (Set Int) | v == Set_sng i2}S.singleton i2) ({v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2\n                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}rng (Inti2x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}+1) j2))\n342:       -- by induction and lem_mem\n343:   ==? True ? ({v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1\n                                       || x2 &lt;= v} -&gt; {v : () | not (Set_mem x3 (RangeSet.rng x1 x2))} | v == RangeSet.lem_mem}lem_mem i1 j1 i2 {v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}&amp;&amp;&amp; x1:Int -&gt; x2:Int -&gt; x3:{i2 : Int | x2 &lt;= i2} -&gt; x4:Int -&gt; {VV : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0}lem_disj i1 j1 (Inti2x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}+1) j2)\n344:   *** QED\n</pre> <p>Here, the operator <code>pf1 &amp;&amp;&amp; pf2</code> conjoins the two facts asserted by <code>pf1</code> and <code>pf2</code>.</p> <p>Again, we can get PLE to do the boring calculations:</p> <pre>353: {-@ lem_disj_ple :: i1:_ -&gt; j1:_ -&gt; i2:{j1 &lt;= i2} -&gt; j2:_ -&gt;\n354:                       {disjoint (rng i1 j1) (rng i2 j2)} / [j2-i2]\n355:   @-}\n356: x1:Int -&gt; x2:Int -&gt; x3:{i2 : Int | x2 &lt;= i2} -&gt; x4:Int -&gt; {VV : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0}lem_disj_ple Inti1 Intj1 {i2 : Int | j1 &lt;= i2}i2 Intj2\n357:   | {v : Bool | v &lt;=&gt; i2 &gt;= j2}i2 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}&gt;= j2 = ()\n358:   | {v : Bool | v &lt;=&gt; i2 &lt; j2}i2 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt;  j2 = {v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1\n                                       || x2 &lt;= v} -&gt; {v : () | not (Set_mem x3 (RangeSet.rng x1 x2))} | v == RangeSet.lem_mem}lem_mem i1 j1 i2 {v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}&amp;&amp;&amp; x1:Int -&gt; x2:Int -&gt; x3:{i2 : Int | x2 &lt;= i2} -&gt; x4:Int -&gt; {VV : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0}lem_disj_ple i1 j1 (Inti2x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}+1) j2\n</pre>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-24-splitting-and-splicing-intervals-II.lhs/#splitting-intervals","title":"Splitting Intervals","text":"<p>Finally, we can establish the splitting property of an interval <code>i..j</code>, that is, given some <code>x</code> that lies between <code>i</code> and <code>j</code> we can split <code>i..j</code> into <code>i..x</code> and <code>x..j</code>. We define a predicate that a set <code>s</code> can be split into <code>a</code> and <code>b</code> as:</p> <pre>372: {-@ inline split @-}\n373: split :: S.Set Int -&gt; S.Set Int -&gt; S.Set Int -&gt; Bool\n374: x1:(Set Int) -&gt; x2:(Set Int) -&gt; x3:(Set Int) -&gt; {VV : Bool | VV &lt;=&gt; x1 == Set_cup x2 x3\n                                                                    &amp;&amp; Set_cap x2 x3 == Set_empty 0}split (Set Int)s (Set Int)a (Set Int)b = Bools x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; x1 == x2}== x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}S.union a b {v : x1:Bool -&gt; x2:Bool -&gt; {v : Bool | v &lt;=&gt; x1\n                                             &amp;&amp; x2} | v == GHC.Classes.&amp;&amp;}&amp;&amp; {v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}disjoint a b\n</pre> <p>We can now state and prove the splitting property as:</p> <pre>380: {-@ lem_split :: i:_ -&gt; x:{i &lt;= x} -&gt; j:{x &lt;= j} -&gt;\n381:                    {split (rng i j) (rng i x) (rng x j)} / [x-i]\n382:   @-}\n383: x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{j : Int | x2 &lt;= j} -&gt; {VV : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)\n                                                                         &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0}lem_split Inti {v : Int | i &lt;= v}x {j : Int | x &lt;= j}t\n384:   | {v : Bool | v &lt;=&gt; i == x}i x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 == x2}== x = ()\n385:   | {v : Bool | v &lt;=&gt; i &lt; x}i x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt;  x = x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{j : Int | x2 &lt;= j} -&gt; {VV : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)\n                                                                         &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0}lem_split (Inti x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}+ 1) x t {v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}&amp;&amp;&amp; {v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1\n                                       || x2 &lt;= v} -&gt; {v : () | not (Set_mem x3 (RangeSet.rng x1 x2))} | v == RangeSet.lem_mem}lem_mem x t i\n</pre> <p>(We're using PLE here quite aggressively, can you work out the equational proof?)</p>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-24-splitting-and-splicing-intervals-II.lhs/#set-operations","title":"Set Operations","text":"<p>The splitting abstraction is a wonderful hammer that lets us break higher-level proofs into the bite sized pieces suitable for the SMT solver's decision procedures.</p> <p>Subset</p> <p>An interval <code>i1..j1</code> is enclosed by <code>i2..j2</code> if <code>i2 &lt;= i1 &lt; j1 &lt;= j2</code>. Lets verify that the range-set of an interval is contained in that of an enclosing one.</p> <pre>406: {-@ lem_sub :: i1:_ -&gt; j1:{i1 &lt; j1} -&gt;\n407:                i2:_ -&gt; j2:{i2 &lt; j2 &amp;&amp; i2 &lt;= i1 &amp;&amp; j1 &lt;= j2 } -&gt;\n408:                  { S.isSubsetOf (rng i1 j1) (rng i2 j2) }\n409:   @-}\n</pre> <p>Here's a \"proof-by-picture\". We can split the larger interval <code>i2..j2</code> into smaller pieces, <code>i2..i1</code>, <code>i1..j1</code> and <code>j1..j2</code> one of which is the <code>i1..j1</code>, thereby completing the proof:</p> <p></p>    ![`lem_sub` a proof by picture](../static/img/lem_sub.png \"lem_sub proof by picture\")    <p></p> <p>The intuition represented by the picture can distilled into the following proof, that invokes <code>lem_split</code> to carve <code>i2..j2</code> into the relevant sub-intervals:</p> <pre>432: x1:Int -&gt; x2:{j1 : Int | x1 &lt; j1} -&gt; x3:Int -&gt; x4:{j2 : Int | x3 &lt; j2\n                                                              &amp;&amp; x3 &lt;= x1\n                                                              &amp;&amp; x2 &lt;= j2} -&gt; {VV : () | Set_sub (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)}lem_sub Inti1 {j1 : Int | i1 &lt; j1}j1 Inti2 {j2 : Int | i2 &lt; j2\n            &amp;&amp; i2 &lt;= i1\n            &amp;&amp; j1 &lt;= j2}j2 = {v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)\n                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}lem_split i2 i1 j2 {v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}&amp;&amp;&amp; {v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)\n                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}lem_split i1 j1 j2\n</pre> <p>Union</p> <p>An interval <code>i1..j1</code> overlaps <code>i2..j2</code> if <code>i1 &lt;= j2 &lt;= i2</code>, that is, if the latter ends somewhere inside the former. The same splitting hammer lets us compute the union of two overlapping intervals simply by picking the interval defined by the endpoints.</p> <pre>446: {-@ lem_union ::\n447:       i1:_ -&gt; j1:{i1 &lt; j1} -&gt;\n448:       i2:_ -&gt; j2:{i2 &lt; j2 &amp;&amp; i1 &lt;= j2 &amp;&amp; j2 &lt;= j1 } -&gt;\n449:         { rng (min i1 i2) j1 = S.union (rng i1 j1) (rng i2 j2) }\n450:   @-}\n</pre> <p></p>    ![`lem_union` a proof by picture](../static/img/lem_union.png \"lem_union proof by picture\")    <p></p> <p>The pictorial proof illustrates the two cases:</p> <ol> <li> <p><code>i1..j1</code> encloses <code>i2..j2</code>; here the union is just <code>i1..j1</code>,</p> </li> <li> <p><code>i1..j1</code> only overlaps <code>i1..j1</code>; here the union is <code>i2..j1</code> which    can be split into <code>i2..i1</code>, <code>i1..j2</code> and <code>j2..j1</code> which are exactly    the union of the intervals <code>i1..j1</code> and <code>i2..j2</code>.</p> </li> </ol> <p>Again, we render the picture into a formal proof as:</p> <pre>474: x1:Int -&gt; x2:{j1 : Int | x1 &lt; j1} -&gt; x3:Int -&gt; x4:{j2 : Int | x3 &lt; j2\n                                                              &amp;&amp; x1 &lt;= j2\n                                                              &amp;&amp; j2 &lt;= x2} -&gt; {VV : () | RangeSet.rng (RangeSet.min x1 x3) x2 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)}lem_union Inti1 {j1 : Int | i1 &lt; j1}j1 Inti2 {j2 : Int | i2 &lt; j2\n            &amp;&amp; i1 &lt;= j2\n            &amp;&amp; j2 &lt;= j1}j2\n475:   -- i1..j1 encloses i2..j2\n476:   | {v : Bool | v &lt;=&gt; i1 &lt; i2}i1 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; i2   = {v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; x3:Int -&gt; x4:{v : Int | x3 &lt; v\n                                                                &amp;&amp; x3 &lt;= x1\n                                                                &amp;&amp; x2 &lt;= v} -&gt; {v : () | Set_sub (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)} | v == RangeSet.lem_sub}lem_sub i2 j2 i1 j1\n477:   -- i1..j1 overlaps i2..j2\n478:   | otherwise = {v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)\n                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}lem_split i2 i1 j1\n479:             {v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}&amp;&amp;&amp; {v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)\n                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}lem_split i1 j2 j1\n480:             {v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}&amp;&amp;&amp; {v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)\n                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}lem_split i2 i1 j2\n</pre> <p>Intersection</p> <p>Finally, we check that the intersection of two overlapping intervals is given by their inner-points.</p> <pre>489: {-@ lem_intersect ::\n490:       i1:_ -&gt; j1:{i1 &lt; j1} -&gt;\n491:       i2:_ -&gt; j2:{i2 &lt; j2 &amp;&amp; i1 &lt;= j2 &amp;&amp; j2 &lt;= j1 } -&gt;\n492:         {rng (max i1 i2) j2 = S.intersection (rng i1 j1) (rng i2 j2)}\n493:   @-}\n</pre> <p></p>    ![`lem_intersect` a proof by picture](../static/img/lem_intersect.png \"lem_intersect proof by picture\")    <p></p> <p>We have the same two cases as for <code>lem_union</code></p> <ol> <li> <p><code>i1..j1</code> encloses <code>i2..j2</code>; here the intersection is just <code>i2..j2</code>,</p> </li> <li> <p><code>i1..j1</code> only overlaps <code>i1..j1</code>; here the intersection is the    middle segment <code>i1..j2</code>, which we obtain by    (a) splitting <code>i1..j1</code> at <code>j2</code>,    (b) splitting <code>i2..j2</code> at <code>i1</code>,    (c) discarding the end segments which do not belong in the intersection.</p> </li> </ol> <pre>517: x1:Int -&gt; x2:{j1 : Int | x1 &lt; j1} -&gt; x3:Int -&gt; x4:{j2 : Int | x3 &lt; j2\n                                                              &amp;&amp; x1 &lt;= j2\n                                                              &amp;&amp; j2 &lt;= x2} -&gt; {VV : () | RangeSet.rng (RangeSet.max x1 x3) x4 == Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)}lem_intersect Inti1 {j1 : Int | i1 &lt; j1}j1 Inti2 {j2 : Int | i2 &lt; j2\n            &amp;&amp; i1 &lt;= j2\n            &amp;&amp; j2 &lt;= j1}j2\n518:   -- i1..j1 encloses i2..j2\n519:   | {v : Bool | v &lt;=&gt; i1 &lt; i2}i1 x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; i2   = {v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; x3:Int -&gt; x4:{v : Int | x3 &lt; v\n                                                                &amp;&amp; x3 &lt;= x1\n                                                                &amp;&amp; x2 &lt;= v} -&gt; {v : () | Set_sub (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)} | v == RangeSet.lem_sub}lem_sub i2 j2 i1 j1\n520:   -- i1..j1 overlaps i2..j2\n521:   | otherwise = {v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)\n                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}lem_split i1 j2 j1\n522:             {v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}&amp;&amp;&amp; {v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)\n                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}lem_split i2 i1 j2\n523:             {v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}&amp;&amp;&amp; {v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | x2 &lt;= v} -&gt; x4:Int -&gt; {v : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0} | v == RangeSet.lem_disj}lem_disj  i2 i1 i1 j1     -- discard i2..i1\n524:             {v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}&amp;&amp;&amp; {v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | x2 &lt;= v} -&gt; x4:Int -&gt; {v : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0} | v == RangeSet.lem_disj}lem_disj  i2 j2 j2 j1     -- discard j2..j1\n</pre>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2017-12-24-splitting-and-splicing-intervals-II.lhs/#conclusions","title":"Conclusions","text":"<p>Whew. That turned out a lot longer than I'd expected!</p> <p>On the bright side, we saw how to:</p> <ol> <li>Specify the semantics of range-sets,</li> <li>Write   equational proofs using plain Haskell code,</li> <li>Avoid   boring proof steps using PLE,</li> <li>Verify  key properties of operations on range-sets.</li> </ol> <p>Next time we'll finish the series by showing how to use the above lemmas to specify and verify the correctness of Breitner's implementation.</p> <pre>547: --------------------------------------------------------------------------------\n548: -- | Some helper definitions\n549: --------------------------------------------------------------------------------\n550: {-@ reflect min @-}\n551: min :: (Ord a) =&gt; a -&gt; a -&gt; a\n552: (Ord a) =&gt;\nx2:a -&gt; x3:a -&gt; {VV : a | VV == RangeSet.min x2 x3\n                          &amp;&amp; VV == (if x2 &lt; x3 then x2 else x3)}min ax ay = {v : Bool | v &lt;=&gt; x &lt; y}if {v : Bool | v &lt;=&gt; x &lt; y}x x1:a -&gt; x2:a -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; y then x else y\n553: \n554: {-@ reflect max @-}\n555: max :: (Ord a) =&gt; a -&gt; a -&gt; a\n556: (Ord a) =&gt;\nx2:a -&gt; x3:a -&gt; {VV : a | VV == RangeSet.max x2 x3\n                          &amp;&amp; VV == (if x2 &lt; x3 then x3 else x2)}max ax ay = {v : Bool | v &lt;=&gt; x &lt; y}if {v : Bool | v &lt;=&gt; x &lt; y}x x1:a -&gt; x2:a -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}&lt; y then y else x\n557: \n558: rng         :: Int -&gt; Int -&gt; S.Set Int\n559: test1       :: () -&gt; ()\n560: test2       :: () -&gt; ()\n561: test1_ple   :: () -&gt; ()\n562: test2_ple   :: () -&gt; ()\n563: lem_mem      :: Int -&gt; Int -&gt; Int -&gt; ()\n564: lem_mem_ple  :: Int -&gt; Int -&gt; Int -&gt; ()\n565: lem_sub      :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; ()\n566: lem_disj     :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; ()\n567: lem_disj_ple :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; ()\n568: lem_split :: Int -&gt; Int -&gt; Int -&gt; ()\n569: \n570: lem_intersect :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; ()\n571: lem_union :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; ()\n572: -- tags/induction.html\n573: \n</pre>","tags":["reflection","abstract-refinements"]},{"location":"blogposts/2018-02-23-measures-and-case-splitting.lhs/","title":"Measures and Case Splitting","text":"<p>Liquid Haskell has a flag called <code>--no-case-expand</code> which can make verification of your code much faster, especially when your code is using ADTs with many alternatives. This flag says relax precision to get fast verification, thus may lead to rejecting safe code.</p> <p>In this post, I explain how <code>--no-case-expand</code> works using a trivial example!</p> <p>(Click here to demo)</p> <pre>28: \n29: module MeasuresAndCaseSplitting where\n</pre>","tags":["measures","advanced"]},{"location":"blogposts/2018-02-23-measures-and-case-splitting.lhs/#measures","title":"Measures","text":"<p>Let's define a simple data type with three alternatives</p> <pre>40: data ABC = A | B | C\n</pre> <p>and a measure that turns <code>ABD</code> into an integer</p> <pre>46: {-@ measure toInt @-}\n47: toInt :: ABC -&gt; Int\n48: x1:MeasuresAndCaseSplitting.ABC -&gt; {VV : GHC.Types.Int | VV == MeasuresAndCaseSplitting.toInt x1}toInt A = 1\n49: toInt B = 2\n50: toInt C = 3\n</pre> <p>Though obvious to us, Liquid Haskell will fail to check that <code>toInt</code> of any <code>ABC</code> argument gives back a natural number. Or, the following call leads to a refinement type error.</p> <pre>59: {-@ unsafe :: x:ABC -&gt; {o:() | 0 &lt;= toInt x } @-}\n60: unsafe     :: ABC -&gt; ()\n61: x1:MeasuresAndCaseSplitting.ABC -&gt; {o : () | 0 &lt;= MeasuresAndCaseSplitting.toInt x1}unsafe MeasuresAndCaseSplitting.ABCx   = ()\n</pre> <p>Why? By turning <code>toInt</code> into a measure, Liquid Haskell gives precise information to each data constructor of <code>ABC</code>. Thus it knows that <code>toInt</code> or <code>A</code>, <code>B</code>, and <code>C</code> is respectively <code>1</code>, <code>2</code>, and <code>3</code>, by automatically generating the following types:</p> <pre>72: A :: {v:ABC | toInt v == 1 }\n73: B :: {v:ABC | toInt v == 2 }\n74: C :: {v:ABC | toInt v == 3 }\n</pre> <p>Thus, to get the <code>toInt</code> information one need to explicitly perform case analysis on an <code>ABC</code> argument. The following code is safe</p> <pre>82: {-@ safe :: x:ABC -&gt; {o:() | 0 &lt;= toInt x} @-}\n83: safe     :: ABC -&gt; ()\n84: x1:MeasuresAndCaseSplitting.ABC -&gt; {o : () | 0 &lt;= MeasuresAndCaseSplitting.toInt x1}safe A   = ()\n85: safe B   = ()\n86: safe C   = ()\n</pre> <p>Liquid Haskell type check the above code because in the first case the body is checked under the assumption that the argument, call it <code>x</code>, is an <code>A</code>. Under this assumption, <code>toInt x</code> is indeed non negative. Yet, this is the case for the rest two alternatives, where <code>x</code> is either <code>B</code> or <code>C</code>. So, <code>0 &lt;= toInt x</code> holds for all the alternatives, because case analysis on <code>x</code> automatically reasons about the value of the measure <code>toInt</code>.</p> <p>Now, what if I match the argument <code>x</code> only with <code>A</code> and provide a default body for the rest?</p> <pre>104: {-@ safeBut :: x:ABC -&gt; {o:() | 0 &lt;= toInt x} @-}\n105: safeBut     :: ABC -&gt; ()\n106: x1:MeasuresAndCaseSplitting.ABC -&gt; {o : () | 0 &lt;= MeasuresAndCaseSplitting.toInt x1}safeBut A   = ()\n107: safeBut _   = ()\n</pre> <p>Liquid Haskell knows that if the argument <code>x</code> is actually an <code>A</code>, then <code>toInt x</code> is not negative, but does not know the value of <code>toInt</code> for the default case.</p> <p>But, by default Liquid Haskell will do the the case expansion of the default case for you and rewrite your code to match <code>_</code> with all the possible cases. Thus, Liquid Haskell will internally rewrite <code>safeBut</code> as</p> <pre>119: {-@ safeButLH :: x:ABC -&gt; {o:() | 0 &lt;= toInt x} @-}\n120: safeButLH     :: ABC -&gt; ()\n121: x1:MeasuresAndCaseSplitting.ABC -&gt; {o : () | 0 &lt;= MeasuresAndCaseSplitting.toInt x1}safeButLH A   = ()\n122: safeButLH B   = ()\n123: safeButLH C   = ()\n</pre> <p>With this rewrite Liquid Haskell gets precision! Thus, it has all the information it needs to prove <code>safeBut</code> as safe. Yet, it repeats the code of the default case, thus verification slows down.</p> <p>In this example, we only have three case alternatives, so we only repeat the code two times with a minor slow down. In cases with many more alternatives repeating the code of the default case can kill the verification time.</p> <p>For that reason, Liquid Haskell comes with the <code>no-case-expand</code> flag that deactivates this expansion of the default cases. With the <code>no-case-expand</code> flag on, the <code>safeBut</code> code will not type check and to fix it the user needs to perform the case expansion manually.</p> <p>In short, the <code>no-case-expand</code> increases verification speed but reduces precision. Then it is up to the user to manually expand the default cases, as required, to restore all the precision required for the code to type check.</p>","tags":["measures","advanced"]},{"location":"blogposts/2018-05-17-hillel-verifier-rodeo-I-leftpad.lhs/","title":"The Hillelogram Verifier Rodeo I (LeftPad)","text":"<p>A month ago, Hillel Wayne posted a verification challenge comprising three problems that might sound frivolous, but which, in fact, hit the sweet spot of being easy to describe and yet interesting to implement and verify. I had a lot of fun hacking them up in LH, and learned some things doing so.</p> <p>Today, lets see how to implement the first of these challenges -- <code>leftPad</code> -- in Haskell, and to check Hillel's specification with LH.</p> <p>(Click here to demo)</p> <pre>35: {-@ LIQUID \"--reflection\"  @-}\n36: {-@ LIQUID \"--ple\"         @-}\n37: {-@ infixr ++              @-}\n38: {-@ infixr !!              @-}\n39: \n40: module PadLeft where\n41: \n42: import Prelude hiding (max, replicate, (++), (!!))\n43: (!!) :: [a] -&gt; Int -&gt; a\n44: size :: [a] -&gt; Int\n45: (++) :: [a] -&gt; [a] -&gt; [a]\n46: obviously         :: Int -&gt; a -&gt; [a] -&gt; ()\n47: replicate         :: Int -&gt; a -&gt; [a]\n48: thmReplicate      :: Int -&gt; a -&gt; Int -&gt; ()\n49: thmAppLeft        :: [a] -&gt; [a] -&gt; Int -&gt; ()\n50: thmAppRight       :: [a] -&gt; [a] -&gt; Int -&gt; ()\n51: thmLeftPad        :: Int -&gt; a -&gt; [a] -&gt; Int -&gt; ()\n52: \n53: {-@ reflect max @-}\n54: max :: Int -&gt; Int -&gt; Int\n55: x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {VV : GHC.Types.Int | VV == max x1 x2\n                                                              &amp;&amp; VV == (if x1 &gt; x2 then x1 else x2)}max GHC.Types.Intx GHC.Types.Inty = {v : GHC.Types.Bool | v &lt;=&gt; x &gt; y}if {v : GHC.Types.Bool | v &lt;=&gt; x &gt; y}x x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 &gt; x2}&gt; y then x else y\n56: \n57: -- A ghost function only used in the specification\n58: {-@ leftPadVal :: n:{Int | False} -&gt; _ -&gt; _ -&gt; _ -&gt; _ @-}\n</pre>","tags":["reflection"]},{"location":"blogposts/2018-05-17-hillel-verifier-rodeo-I-leftpad.lhs/#the-leftpad-challenge","title":"The LeftPad Challenge","text":"<p>The first of these problems was leftPad</p> <p>1. Leftpad. Takes a padding character, a string, and a total length, returns the string padded with that length with that character. If length is less than string, does nothing.https://t.co/X8qR8gTZdO</p>\u2014 Hillel (@Hillelogram) April 20, 2018","tags":["reflection"]},{"location":"blogposts/2018-05-17-hillel-verifier-rodeo-I-leftpad.lhs/#implementation","title":"Implementation","text":"<p>First, lets write an idiomatic implementation of <code>leftPad</code> where we will take the liberty of generalizing</p> <ul> <li>the padding character to be the input <code>c</code> that is of some (polymorphic) type <code>a</code></li> <li>the string to be the input <code>xs</code> that is a list of <code>a</code></li> </ul> <p>If the target length <code>n</code> is indeed greater than the input string <code>xs</code>, i.e. if <code>k = n - size xs</code> is positive, we <code>replicate</code> the character <code>c</code> <code>k</code> times and append the result to the left of the input <code>xs</code>. Otherwise, if <code>k</code> is negative, we do nothing, i.e. return the input.</p> <pre>87: {-@ reflect leftPad @-}\n88: leftPad :: Int -&gt; a -&gt; [a] -&gt; [a]\n89: x1:GHC.Types.Int -&gt; a -&gt; x3:[a] -&gt; {res : [a] | size res == max x1 (size x3)}leftPad GHC.Types.Intn ac [a]xs\n90:   | GHC.Types.Bool0 x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 &lt; x2}&lt; k     = {v : x1:a -&gt; {v : [a] | size v == k\n                        &amp;&amp; v == replicate k x1\n                        &amp;&amp; v == (if 0 == k then [] else : x1 (replicate (k - 1) x1))} | v == replicate k}replicate k c ++ xs\n91:   | otherwise = xs\n92:   where\n93:     GHC.Types.Intk         = GHC.Types.Intn x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}- {v : GHC.Types.Int | v &gt;= 0\n                     &amp;&amp; v == size xs}size xs\n</pre> <p>The code for <code>leftPad</code> is short because we've delegated much of the work to <code>size</code>, <code>replicate</code> and <code>++</code>. Here's how we can compute the <code>size</code> of a list:</p> <pre>101: {-@ measure size @-}\n102: {-@ size :: [a] -&gt; Nat @-}\n103: x1:[a] -&gt; {v : GHC.Types.Int | v &gt;= 0\n                               &amp;&amp; v == size x1}size []     = 0\n104: size (x:xs) = {v : GHC.Types.Int | v == (1 : int)}1 x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}+ {v : GHC.Types.Int | v &gt;= 0\n                     &amp;&amp; v == size xs}size xs\n</pre> <p>and here is the list append function <code>++</code> :</p> <pre>110: {-@ reflect ++ @-}\n111: {-@ (++) :: xs:[a] -&gt; ys:[a] -&gt;\n112:             {v:[a] | size v = size xs + size ys}\n113:   @-}\n114: []     x1:[a] -&gt; x2:[a] -&gt; {v : [a] | size v == size x1 + size x2}++ [a]ys = ys\n115: (x:xs) ++ ys = x : ({v : [a] | size v == size xs + size ys\n           &amp;&amp; v == ++ xs ys}xs ++ ys)\n</pre> <p>and finally the implementation of <code>replicate</code> :</p> <pre>121: {-@ reflect replicate @-}\n122: {-@ replicate :: n:Nat -&gt; a -&gt;\n123:                  {v:[a] | size v = n}\n124:   @-}\n125: x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; a -&gt; {v : [a] | size v == x1}replicate 0 _ = []\n126: replicate n c = c : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; a -&gt; {v : [a] | size v == x1}replicate (GHC.Types.Intn x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}- 1) c\n</pre>","tags":["reflection"]},{"location":"blogposts/2018-05-17-hillel-verifier-rodeo-I-leftpad.lhs/#what-shall-we-prove","title":"What shall we Prove?","text":"<p>My eyes roll whenever I read the phrase \"proved X (a function, a program) correct\".</p> <p>There is no such thing as \"correct\".</p> <p>There are only \"specifications\" or \"properties\", and proofs that ensures that your code matches those specifications or properties.</p> <p>What specifications shall we verify about our implementation of <code>leftPad</code>? One might argue that the above code is \"obviously correct\", i.e. the implementation more or less directly matches the informal requirements.</p> <p>One way to formalize this notion of \"obviously correct\" is to verify a specification that directly captures the informal requirements:</p> <pre>151: {-@ obviously :: n:Int -&gt; c:a -&gt; xs:[a] -&gt;\n152:       { leftPad n c xs = if (size xs &lt; n)\n                         then (replicate (n - size xs) c ++ xs)\n                         else xs }\n155:   @-}\n156: x1:GHC.Types.Int -&gt; x2:a -&gt; x3:[a] -&gt; {VV : () | leftPad x1 x2 x3 == (if size x3 &lt; x1 then ++ (replicate (x1 - size x3) x2) x3 else x3)}obviously _ _ _ = ()\n</pre> <p>In the above, the type signature is a specification that says that for all <code>n</code>, <code>c</code> and <code>xs</code>, the value returned by <code>leftPad n c xs</code> is <code>xs</code> when <code>n</code> is too small, and the suitably padded definition otherwise.</p> <p>The code, namely <code>()</code>, is the proof. LH is able to trivially check that <code>leftPad</code> meets the \"obviously correct\" specification, because, well, in this case, the implementation is the specification. (Incidentally, this is also why the Idris solution is terse.)</p> <p>So, if you are happy with the above specification, you can stop reading right here: we're done.</p>","tags":["reflection"]},{"location":"blogposts/2018-05-17-hillel-verifier-rodeo-I-leftpad.lhs/#hillels-specifications","title":"Hillel's Specifications","text":"<p>However, the verification rodeo is made more interesting by Hillel's Dafny specifications:</p> <ol> <li> <p>Size The <code>size</code> of the returned sequence is the    larger of <code>n</code> and the size of <code>xs</code>;</p> </li> <li> <p>Pad-Value Let <code>K = n - size xs</code>. We require    that the <code>i</code>-th element of the padded-sequence    is <code>c</code> if <code>0 &lt;= i &lt; K</code>, and is the <code>i - K</code>-th    element of <code>xs</code> otherwise.</p> </li> </ol>","tags":["reflection"]},{"location":"blogposts/2018-05-17-hillel-verifier-rodeo-I-leftpad.lhs/#digression-the-importance-of-being-decidable","title":"Digression: The Importance of being Decidable","text":"<p>LH, like many of the other rodeo entries, uses SMT solvers to automate verification. For example, the <code>leftPad</code> solutions in Dafny and SPARK and F* make heavy use quantified axioms to encode properties of sequences.</p> <p>However, unlike its many SMT-based brethren, LH takes a somewhat fanatical stance: it never uses quantifiers or axioms. We take this rigid position because SMT solvers are only predictable on queries from (certain) decidable logics. Axioms, or more generally, quantified formulas rapidly take SMT solvers out of this \"comfort zone\", causing them to reject valid formulas, run slowly, or even, to run forever.</p> <p>Thus, we have chosen to deliberately avoid the siren song of quantifiers by lashing LH firmly to the steady mast of decidable logics.</p>","tags":["reflection"]},{"location":"blogposts/2018-05-17-hillel-verifier-rodeo-I-leftpad.lhs/#reasoning-about-sequences","title":"Reasoning about Sequences","text":"<p>Unfortunately, this design choice leaves us with some work: we must develop i.e. state and prove relevant properties about sequences from scratch.</p> <p>Indexing into a Sequence</p> <p>To start, lets define the notion of the <code>i</code>-th element of a sequence (this is pretty much Haskell's list-index operator)</p> <pre>247: {-@ reflect !! @-}\n248: {-@ (!!) :: xs:[a] -&gt; {n:Nat | n &lt; size xs} -&gt; a @-}\n249: (x:_)  x1:[a] -&gt; {v : GHC.Types.Int | v &gt;= 0\n                               &amp;&amp; v &lt; size x1} -&gt; a!! 0 = x\n250: (_:xs) !! n = x1:[a] -&gt; {v : GHC.Types.Int | v &gt;= 0\n                               &amp;&amp; v &lt; size x1} -&gt; axs !! (GHC.Types.Intn x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}- 1)\n</pre> <p>Replicated Sequences</p> <p>Next, we verify that every element in a <code>replicate</code>-d sequence is the element being cloned:</p> <pre>259: {-@ thmReplicate :: n:Nat -&gt; c:a -&gt; i:{Nat | i &lt; n} -&gt;\n260:                     { replicate n c !! i  == c }\n261:   @-}\n262: x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:a -&gt; x3:{v : GHC.Types.Int | v &gt;= 0\n                                                                   &amp;&amp; v &lt; x1} -&gt; {VV : () | !! (replicate x1 x2) x3 == x2}thmReplicate {v : GHC.Types.Int | v &gt;= 0}n ac {v : GHC.Types.Int | v &gt;= 0\n                     &amp;&amp; v &lt; n}i\n263:   | GHC.Types.Booli x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 == x2}== 0    = ()\n264:   | otherwise = x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:a -&gt; x3:{v : GHC.Types.Int | v &gt;= 0\n                                                                   &amp;&amp; v &lt; x1} -&gt; {VV : () | !! (replicate x1 x2) x3 == x2}thmReplicate (GHC.Types.Intn x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}- 1) c (GHC.Types.Inti x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}- 1)\n</pre> <p>LH verifies the above \"proof by induction\":</p> <ul> <li> <p>In the base case <code>i == 0</code> and the value returned is <code>c</code>   by the definition of <code>replicate</code> and <code>!!</code>.</p> </li> <li> <p>In the inductive case, <code>replicate n c !! i</code> is equal to   <code>replicate (n-1) c !! (i-1)</code> which, by the \"induction hypothesis\"   (i.e. by recursively calling the theorem) is <code>c</code>.</p> </li> </ul> <p>Concatenating Sequences</p> <p>Finally, we need two properties that relate concatenation and appending, namely, the <code>i</code>-th element of <code>xs ++ ys</code> is:</p> <ul> <li>Left the <code>i</code>-th element of <code>xs</code> if <code>0 &lt;= i &lt; size xs</code>, and</li> <li>Right the <code>i - size xs</code> element of <code>ys</code> otherwise.</li> </ul> <pre>286: {-@ thmAppLeft :: xs:[a] -&gt; ys:[a] -&gt; {i:Nat | i &lt; size xs} -&gt;\n287:                   { (xs ++ ys) !! i == xs !! i }\n288:   @-}\n289: x1:[a] -&gt; x2:[a] -&gt; x3:{v : GHC.Types.Int | v &gt;= 0\n                                            &amp;&amp; v &lt; size x1} -&gt; {VV : () | !! (++ x1 x2) x3 == !! x1 x3}thmAppLeft (x:xs) [a]ys 0 = ()\n290: thmAppLeft (x:xs) ys i = x1:[a] -&gt; x2:[a] -&gt; x3:{v : GHC.Types.Int | v &gt;= 0\n                                            &amp;&amp; v &lt; size x1} -&gt; {VV : () | !! (++ x1 x2) x3 == !! x1 x3}thmAppLeft xs ys (GHC.Types.Intix1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}-1)\n291: \n292: {-@ thmAppRight :: xs:[a] -&gt; ys:[a] -&gt; {i:Nat | size xs &lt;= i} -&gt;\n293:                    { (xs ++ ys) !! i == ys !! (i - size xs) }\n294:   @-}\n295: x1:[a] -&gt; x2:[a] -&gt; x3:{v : GHC.Types.Int | v &gt;= 0\n                                            &amp;&amp; size x1 &lt;= v} -&gt; {VV : () | !! (++ x1 x2) x3 == !! x2 (x3 - size x1)}thmAppRight []     [a]ys {v : GHC.Types.Int | v &gt;= 0}i = ()\n296: thmAppRight (x:xs) ys i = x1:[a] -&gt; x2:[a] -&gt; x3:{v : GHC.Types.Int | v &gt;= 0\n                                            &amp;&amp; size x1 &lt;= v} -&gt; {VV : () | !! (++ x1 x2) x3 == !! x2 (x3 - size x1)}thmAppRight xs ys (GHC.Types.Intix1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}-1)\n</pre> <p>Both of the above properties are proved by induction on <code>i</code>.</p>","tags":["reflection"]},{"location":"blogposts/2018-05-17-hillel-verifier-rodeo-I-leftpad.lhs/#proving-hillels-specifications","title":"Proving Hillel's Specifications","text":"<p>Finally, we're ready to state and prove Hillel's specifications.</p> <p>Size Specification</p> <p>The size specification is straightforward, in that LH proves it automatically, when type-checking <code>leftPad</code> against the signature:</p> <pre>313: {-@ leftPad :: n:Int -&gt; c:a -&gt; xs:[a] -&gt;\n314:                 {res:[a] | size res = max n (size xs)}\n315:   @-}\n</pre> <p>Pad-Value Specification</p> <p>We specify the pad-value property -- i.e. the <code>i</code>-th element equals <code>c</code> or the corresponding element of <code>xs</code> -- by a type signature:</p> <pre>325: {-@ thmLeftPad\n326:       :: n:_ -&gt; c:_ -&gt; xs:{size xs &lt; n} -&gt; i:{Nat | i &lt; n} -&gt;\n327:          { leftPad n c xs !! i ==  leftPadVal n c xs i }\n328:   @-}\n329: \n330: {-@ reflect leftPadVal @-}\n331: {n : GHC.Types.Int | False} -&gt; a -&gt; [a] -&gt; GHC.Types.Int -&gt; aleftPadVal {n : GHC.Types.Int | False}n ac [a]xs GHC.Types.Inti\n332:   | {v : GHC.Types.Bool | v &lt;=&gt; i &lt; k}i x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 &lt; x2}&lt; k     = c\n333:   | otherwise = {v : [a] | size v &gt;= 0\n           &amp;&amp; len v &gt;= 0\n           &amp;&amp; v == xs}xs !! ({v : GHC.Types.Int | v == i - k}i x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}- k)\n334:   where GHC.Types.Intk     = {v : GHC.Types.Int | v &gt;= 0\n                     &amp;&amp; v == size xs}n x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}- size xs\n</pre> <p>Pad-Value Verification</p> <p>We verify the above property by filling in the implementation of <code>thmLeftPad</code> as:</p> <pre>343: x1:GHC.Types.Int -&gt; x2:a -&gt; x3:{v : [a] | size v &lt; x1} -&gt; x4:{v : GHC.Types.Int | v &gt;= 0\n                                                                                  &amp;&amp; v &lt; x1} -&gt; {VV : () | !! (leftPad x1 x2 x3) x4 == leftPadVal x1 x2 x3 x4}thmLeftPad GHC.Types.Intn ac {v : [a] | size v &lt; n}xs {v : GHC.Types.Int | v &gt;= 0\n                     &amp;&amp; v &lt; n}i\n344:   | {v : GHC.Types.Bool | v &lt;=&gt; i &lt; k}i x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 &lt; x2}&lt; k     = x1:[a] -&gt; x2:{v : GHC.Types.Int | v &gt;= 0\n                                  &amp;&amp; v &lt; size cs} -&gt; {v : () | !! (++ cs x1) x2 == !! cs x2}thmAppLeft  cs xs i `seq` x1:a -&gt; x2:{v : GHC.Types.Int | v &gt;= 0\n                                &amp;&amp; v &lt; k} -&gt; {v : () | !! (replicate k x1) x2 == x1}thmReplicate k c i\n345:   | otherwise = x1:[a] -&gt; x2:{v : GHC.Types.Int | v &gt;= 0\n                                  &amp;&amp; size cs &lt;= v} -&gt; {v : () | !! (++ cs x1) x2 == !! x1 (x2 - size cs)}thmAppRight cs xs i\n346:   where\n347:     GHC.Types.Intk         = GHC.Types.Intn x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}- {v : GHC.Types.Int | v &gt;= 0\n                     &amp;&amp; v == size xs}size xs\n348:     {v : [a] | size v == k\n           &amp;&amp; v == replicate k c\n           &amp;&amp; v == (if 0 == k then [] else : c (replicate (k - 1) c))}cs        = {v : x1:a -&gt; {v : [a] | size v == k\n                        &amp;&amp; v == replicate k x1\n                        &amp;&amp; v == (if 0 == k then [] else : x1 (replicate (k - 1) x1))} | v == replicate k}replicate k c\n</pre> <p>The \"proof\"  -- in quotes because its just a Haskell function -- simply combines the replicate- and concatenate-left theorems if <code>i</code> is in the \"pad\", and the concatenate-right theorem, otherwise.</p>","tags":["reflection"]},{"location":"blogposts/2018-05-17-hillel-verifier-rodeo-I-leftpad.lhs/#conclusions","title":"Conclusions","text":"<p>That concludes part I of the rodeo. What did I learn from this exercise?</p> <ol> <li> <p>Even apparently simple functions like <code>leftPad</code> can    have many different specifications; there is no    necessarily \"best\" specification as different specs    make different assumptions about what is \"trusted\",    and more importantly, though we didn't see it here,    ultimately a spec is a particular view into how a    piece of code behaves and    we may want different views depending on the context where we want    to use the given piece of code.</p> </li> <li> <p>The <code>leftPad</code> exercise illustrates a fundamental    problem with Floyd-Hoare style \"modular\" verification,    where pre- and post-conditions (or contracts or refinement    types or ...) are used to modularly \"abstract\" functions    i.e. are used to describe the behavior of a function    at a call-site. As the above exercise shows, we often    need properties connecting the behavior of different    functions, e.g. append (<code>++</code>), indexing (<code>!!</code>).    In these cases, the only meaningful specification    for the underlying function is its implementation.</p> </li> <li> <p>Finally, the above proofs are all over user-defined    recursive functions which this was not even possible    before refinement reflection, i.e    till about a year ago. I'm also quite pleased by how    logical evaluation makes these proofs    quite short, letting LH verify expressive specifications    while steering clear of the siren song of quantifiers.</p> </li> </ol>","tags":["reflection"]},{"location":"blogposts/2019-10-20-why-types.lhs/","title":"Liquid Types vs. Floyd-Hoare Logic","text":"<p>Several folks who are experts in the program verification  literature have asked me some variant of the following question: </p> <p>How are Liquid/Refinement types different from Floyd-Hoare logics?</p> <p>This question always reminds me of Yannis Smaragdakis' clever limerick:</p> <p>No idea is too obvious or dreary, </p> <p>If appropriately expressed in type theory, </p> <p>It's a research advance, </p> <p>That no one understands, </p> <p>But they are all too impressed to be leery.</p> <p>That is, the above question can be rephrased as: why bother with  the hassle of encoding properties in types when good old-fashioned  assertions, pre- and post-conditions would do? Is it just a  marketing gimmick to make readers too impressed to be leery?</p>","tags":["basic"]},{"location":"blogposts/2019-10-20-why-types.lhs/#the-problem-quantifiers","title":"The Problem: Quantifiers","text":"<p>The main algorithmic problem with classical Floyd-Hoare logic  is that to do useful things, you need to use universally quantified  logical formulas inside invariants, pre- and post-conditions. </p> <p>Verification then proceeds by asking SMT solvers to check  verification conditions (VCs) over these quantified formulas.  While SMT solvers are marvelous technological artifacts, and I bow  to no one in my admiration of them, in reality, they work best on  formulas from a narrowly defined set of decidable theories. </p> <p>In particular, they are notoriously (and justifiably!) fickle  when quizzed on VCs with quantifiers. Briefly, this is because  even if the solver \"knows\" the universally quantified fact: </p> <pre><code>forall x. P(x)\n</code></pre> <p>the solver doesn't know which particular terms <code>e1</code>, <code>e2</code> or <code>e3</code>  to instantiate the fact at. That is, the solver doesn't know which <code>P(e1)</code> or <code>P(e2)</code> or <code>P(e3)</code> it should work with to prove  some given goal. At best, it can make some educated guesses, or  use hints from the user, but these heuristics can turn out to be  quite brittle as the underlying logics  are undecidable in general. To make verification predictable,  we really want to ensure that the VCs remain decidable, and  to do so, we must steer clear of the precipice of quantification. </p>","tags":["basic"]},{"location":"blogposts/2019-10-20-why-types.lhs/#the-solution-types","title":"The Solution: Types","text":"<p>The great thing about types, as any devotee will tell you, is that the compose. Regrettably, that statement is only  comprehensible to believers. I prefer to think of it  differently: types decompose. To be precise:</p> <p>Types decompose quantified assertions into quantifier-free refinements.</p> <p>Let me make my point with some examples that show what verification  looks like when using Refinement Types (as implemented in LiquidHaskell) vs  Floyd-Hoare style contracts (as implemented in Dafny). </p> <p>The goal of this exercise is to illustrate how types help  with verification, not to compare the tools LH and Dafny.  In particular, Dafny could profit from refinement types,  and LH could benefit from the many clever ideas embodied  within Dafny.</p>","tags":["basic"]},{"location":"blogposts/2019-10-20-why-types.lhs/#example-1-properties-of-data","title":"Example 1: Properties of Data","text":"<p>Consider the following standard definition of a <code>List</code> datatype  in Dafny (left) and LH (right). </p>      A list data type in Dafny (L) and LiquidHaskell (R)       <p>(You can see the full definitions for Dafny and LiquidHaskell.)</p>","tags":["basic"]},{"location":"blogposts/2019-10-20-why-types.lhs/#accessing-a-list","title":"Accessing a list","text":"<p>The two descriptions are more or less the same except for some  minor issues of concrete syntax. However, next consider the  respective implementations of a function to access the <code>ith</code>  element of a <code>List</code>. We also pass in a <code>def</code>ault value returned when the index <code>i</code> is invalid. </p>    Accessing the i-th element of a list in Dafny(L) and LiquidHaskell(R)    <p>It is (usually) silly to access lists in this fashion.  I use this example merely to illustrate the common case of defining a container structure (here, <code>List</code>) and  then accessing its contents (here, <code>ith</code>).  As such, we'd like to specify that the value returned  by the <code>ith</code> element is indeed in the container or is  the <code>def</code>ault.</p> <p>Floyd-Hoare Logic</p> <p>With classical Floyd-Hoare logic, as shown in the Dafny listing  on the left, we must spell out the specification quite explicitly.  The programmer must write an <code>elements</code> function that describes  the set of values in the container, and then the post-condition of <code>ith</code> states that the <code>res</code> is either in that set or the default.</p> <p>While this specification seems simple enough, we are already on  dicey terrain: how are we to encode the semantics of the  user-defined function <code>elements</code> to the SMT solver?  In the classical Floyd-Hoare approach, we must use a  quantified invariant of the form:</p> <pre><code>   elements(Nil) = empty \n&amp;&amp; forall h t :: elements(Cons(h, t)) = {h} + elements(t)\n</code></pre> <p>Thanks to the ingenuity of Greg Nelson who invented the notion  of triggers and of Rustan Leino and many others, who devised  ingenious heuristics for using them, Dafny handles the quantifier calmly to verify the above specification for <code>ith</code>.  However, we are not always so fortunate: it frightfully easy  to run into quantifier-related problems with user-defined  functions, as we will see in due course.</p> <p>Liquid/Refinement Types</p> <p>In contrast, the liquid/refinement version is quite spare:  there is no extra specification beyond the code. Surely  there must be some mistake? Look again: the type signature says everything we need:</p> <p>If you call <code>ith</code> with a list of <code>a</code> values and a default <code>a</code> value then you get an <code>a</code> value\".</p> <p>That is parametricity removes the overhead of using an  explicit <code>elements</code> function.</p>","tags":["basic"]},{"location":"blogposts/2019-10-20-why-types.lhs/#building-a-list","title":"Building a list","text":"<p>Next, lets extend our example to illustrate the common  situation where we want some invariant to be true for  all the values in a container. To this end, let us  write a function <code>mkList</code> that builds a container  with values <code>k+1</code>,...,<code>k+n</code> and then test that when  <code>k</code> is non-negative, any arbitrarily chosen value from  the container is indeed strictly positive. </p>      Building and accessing a list in Dafny (L) and LiquidHaskell(R)    <p>The code in Dafny and LH is more or less the same, except  for one crucial difference.</p> <p>Floyd-Hoare Logic</p> <p>Recall that the specification for <code>ith(pos, i, 1)</code> states  that the returned value is some element of the container  (or <code>1</code>). Thus, to verify the <code>assert</code> in <code>testPosN</code> using  classical Floyd-Hoare logic, we need a way to specify that  every element in <code>pos</code> is indeed strictly positive.  With classical program logics, the only way to do so is to  use a universally quantified post-condition, highlighted  in blue: </p> <p>\"for all <code>v</code> if <code>v</code> is in the elements of the <code>res</code>ult, then <code>v</code> is greater than <code>k</code>\" </p> <p>Liquid/Refinement Types</p> <p>Regardless of my personal feelings about quantifiers,  we can agree that the version on the right is simpler  as types make it unnecessary to mention <code>elements</code> or  <code>forall</code>. Instead, LH infers </p> <pre><code>mkList\u00a0::\u00a0Int\u00a0-&gt;\u00a0k:Int\u00a0-&gt;\u00a0List\u00a0{v:Int | k &lt; v}\n</code></pre> <p>That is, that the output type of <code>mkList</code> is a  list of values <code>v</code> that are all greater than <code>k</code>.  The scary forall has been replaced by the friendly  type constructor <code>List</code>. In other words, types  allow us to decompose the monolithic universally  quantified invariant into: </p> <ol> <li>a quantifier-free refinement <code>k &lt; v</code>, and </li> <li>a type constructor that implicitly \"quantifies\" over the container's elements.</li> </ol>","tags":["basic"]},{"location":"blogposts/2019-10-20-why-types.lhs/#lesson-decomposition-enables-inference","title":"Lesson: Decomposition Enables Inference","text":"<p>Am I cheating? After all, what prevents Dafny from  inferring the same post-condition as LH? </p> <p>Once again, quantifiers are the villain.</p> <p>There have been many decades worth of papers on the  topic of inferring quantified invariants, but save  some nicely circumscribed use-cases these methods  turn out to be rather difficult to get working  efficiently and predictably enough to be practical.  In contrast, once the quantifiers are decomposed  away, even an extremely basic approach called  Monomial Predicate Abstraction,  or more snappily, Houdini, suffices  to infer the above liquid type.</p>","tags":["basic"]},{"location":"blogposts/2019-10-20-why-types.lhs/#example-2-properties-of-structures","title":"Example 2: Properties of Structures","text":"<p>Recall that when discussing the user-defined <code>elements</code> function above, I had issued some dark warnings about quantifier-related problems that  arise from user-defined functions. Allow me to explain with another  simple example, that continues with the <code>List</code> datatype defined above.</p> <p>(You can see the full definitions for Dafny and LiquidHaskell.)</p>","tags":["basic"]},{"location":"blogposts/2019-10-20-why-types.lhs/#specifying-a-size-function","title":"Specifying a <code>size</code> Function","text":"<p>Lets write the usual recursive function that computes the <code>size</code>  of a list. The definitions are mostly identical, except for the green  <code>measure</code> highlight that we will discuss below.</p>      A function defining the size of a list in Dafny (L) and LiquidHaskell (R)    <p>Floyd-Hoare Logic</p> <p>SMT solvers are restricted to a set of ground theories and hence, do not \"natively\" understand user-defined functions. Instead, the  verifer must teach the SMT solver how to reason about formulas (VCs)  containing uses of user-defined functions like <code>size</code>.  In the classical Floyd-Hoare approach, this is done by converting  the definition of <code>size</code> into a universally quantified axiom like:</p> <pre><code>size Nil == 0  &amp;&amp; forall h, t :: size (Cons h t) = 1 + size t\n</code></pre> <p>A quantifier! By the pricking of my thumbs, something wicked this way comes...</p> <p>Liquid/Refinement Types</p> <p>With a more type-centric view, we can think of the recursive  function <code>size</code> as a way to decorate or refine the types of  the data constructors. So, when you write the definition in  the green box above, specifically when you add the <code>measure</code>  annotation, the function is converted to strengthened  versions for the types of the constructors <code>Nil</code> and <code>Cons</code>,  so its as if we had defined the list type as two constructor  functions</p> <pre><code>data List a where\n  Cons :: h:a -&gt; t:List a -&gt; {v:List a | size v == 1 + size t}\n  Nil  :: {v:List a | size v == 0} \n</code></pre> <p>That is, the bodies of the measures get translated to refinements on the output types of the corresponding constructors. After this, the SMT solver \"knows nothing\" about the semantics of <code>size</code>, except  that it is a function. In logic-speak, <code>size</code> is uninterpreted  in the refinement, and there are no quantified axioms. That is, we  choose to keep SMT solver blissfully ignorant about the semantics  of <code>size</code>. How could this possibly be a good thing?</p>","tags":["basic"]},{"location":"blogposts/2019-10-20-why-types.lhs/#verifying-the-size-of-a-list","title":"Verifying the <code>size</code> of a List","text":"<p>Next, lets see what happens when we write a simple test that builds  a small list with two elements and <code>assert</code>s that the lists <code>size</code>  is indeed <code>2</code>:</p>    Verifying the size of a list in Dafny (L) and LiquidHaskell (R)    <p>Floyd-Hoare Logic</p> <p>To get Dafny to verifier to sign off on the <code>assert (size(pos) == 2)</code>  we have to add a mysterious extra assertion that checks the size of  the intermediate value <code>Cons (1, Nil)</code>. (Without it, verification fails.)</p> <p>Huh? Pesky quantifiers. </p> <p>The SMT solver doesn't know where to instantiate the <code>size</code> axom.  In this carefully chosen, but nevertheless simple situation, Dafny's  instantiation heuristics come up short. I had to help them along by  guessing this intermediate assertion, which effectively \"adds\" the  fact that the size of the intermediate list is 1, thereby letting  the SMT solver prove the second assertion.</p> <p>Liquid/Refinement Types</p> <p>In contrast, with types, the solver is able to verify the code without  batting an eyelid. But how could it possibly do so even though we kept  it ignorant of the semantics of <code>size</code>?</p> <p>Because types decompose reasoning. In particular, here, the measure  and constructor trick lets us factor reasoning about <code>size</code> into the type system.</p> <p>In particular, LH internally views the code for <code>test</code> in A-Normal Form  which is a fancy way of saying, by introducing temporary variables  for all sub-expressions: </p> <pre><code>test\u00a0x1\u00a0=\u00a0\n   let tmp0 = Nil                \n       tmp1 = Cons x1 tmp0 \n       pos\u00a0 =\u00a0Cons\u00a0 0\u00a0tmp1\n   in \n      assert\u00a0(size\u00a0pos\u00a0==\u00a02)\n</code></pre> <p>And now, just by the rules of type checking, and applying the types  of the constructors, it deduces that:</p> <pre><code>   tmp0 :: {size tmp0 == 0}\n   tmp1 :: {size tmp1 == 1 + size tmp0}\n   pos  :: {size pos  == 1 + size tmp1}\n</code></pre> <p>which lets the SMT solver prove that <code>size pos == 2</code> without  requiring any axiomatic description of <code>size</code>. This simple  <code>measure</code> method goes a very long way in specifying and  verifying lots of properties.</p>","tags":["basic"]},{"location":"blogposts/2019-10-20-why-types.lhs/#lesson-decomposition-enables-type-directed-instantiation","title":"Lesson: Decomposition Enables Type-Directed Instantiation","text":"<p>I'd like to emphasize again that this trick was enabled  by the type-centric view: encode the function semantics  in data constructors, and let the type checking (or VC  generation) do the instantiation. </p> <p>It could easily by incorporated inside and work together  with axioms in Floyd-Hoare based systems like Dafny.  Of course, this approach is limited to a restricted class  of functions -- roughly, case-splits over a single data type's  constructors --  but we can generalize the method quite  a bit using the idea of logical evaluation.</p>","tags":["basic"]},{"location":"blogposts/2019-10-20-why-types.lhs/#summary","title":"Summary","text":"<p>To sum up, we saw two examples where taking a type-centric view  made verification more ergonomic, essentially by factoring  reasoning about quantifiers into the type system.</p> <ul> <li> <p>In the first case, when reasoning about data in containers,    the polymorphic type constructor <code>List</code> provided an natural    way to reason about the fact that all elements in a container    satisfied some property.</p> </li> <li> <p>In the second case, when reasoning about the structure    of the container via a recursive function, the types of    the data constructors allowed us to factor the instantiation    of properties of <code>size</code> at places where the list was constructed    (and dually, not shown, destructed) without burdening the SMT    solver with any axioms and the pressure of figuring out where    to instantiate them. </p> </li> </ul> <p>To conclude I'd like to reiterate that the point is not  that types and program logics are at odds with each other.  Instead, the lesson is that while classical  Floyd-Hoare logic associates invariants with program  positions, Liquid/Refinement types are a generalization  that additionally let you associate invariants with  type positions, which lets us exploit</p> <ul> <li>types as a program logic, and</li> <li>syntax-directed typing rules as a decision procedure,</li> </ul> <p>that, in many common situations, simplify verification by  decomposing proof obligations (VCs) into simple, quantifier-free,  SMT-friendly formulas. As you might imagine, the benefits  are magnified when working with higher-order functions,  e.g. <code>map</code>-ing or <code>fold</code>-ing over containers...</p>","tags":["basic"]},{"location":"blogposts/2019-10-20-why-types.lhs/#acknowledgments","title":"Acknowledgments","text":"<p>Huge thanks to Rustan Leino, Nadia Polikarpova, Daniel Ricketts, Hillel Wayne, and Zizz Vonnegut  for patiently answering my many questions about Dafny! </p>","tags":["basic"]},{"location":"blogposts/2020-04-12-polymorphic-perplexion.lhs/","title":"Polymorphic Perplexion","text":"<p>Polymorphism plays a vital role in automating verification in LH. However, thanks to its ubiquity, we often take it for granted, and  it can be quite baffling to figure out why verification fails with  monomorphic signatures. Let me explain why, using a simple example  that has puzzled me and other users several times.</p> <pre>22: \n23: module PolymorphicPerplexion where\n</pre>","tags":["basic"]},{"location":"blogposts/2020-04-12-polymorphic-perplexion.lhs/#a-type-for-ordered-lists","title":"A Type for Ordered Lists","text":"<p>Previously we have seen how you can use LH to define a type of lists whose values are in increasing (ok, non-decreasing!) order.</p> <p>First, we define an <code>IncList a</code> type, with <code>Emp</code> (\"empty\")  and <code>:&lt;</code> (\"cons\") constructors.</p> <pre>38: data IncList a = Emp\n39:                | (:&lt;) { hd :: a, tl :: IncList a }\n40: \n41: infixr 9 :&lt;\n</pre> <p>Next, we refine the type to specify that each \"cons\" <code>:&lt;</code> constructor takes as input a <code>hd</code> and a <code>tl</code> which must  be an <code>IncList a</code> of values <code>v</code> each of which is greater  than <code>hd</code>. </p> <pre>50: {-@ data IncList a = Emp \n51:                    | (:&lt;) { hd :: a, tl :: IncList {v:a | hd &lt;= v}}  \n52:   @-}\n</pre> <p>We can confirm that the above definition ensures that the only  legal values are increasingly ordered lists, as LH accepts the first list below, but rejects the second where the elements are out of order.</p> <pre>61: legalList :: IncList Int\n62: (PolymorphicPerplexion.IncList GHC.Types.Int)legalList = GHC.Types.Int0 :&lt; GHC.Types.Int1 :&lt; GHC.Types.Int2 :&lt; GHC.Types.Int3 :&lt; {VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}Emp\n63: \n64: illegalList :: IncList Int \n65: (PolymorphicPerplexion.IncList GHC.Types.Int)illegalList = GHC.Types.Int0 :&lt; GHC.Types.Int1 :&lt; GHC.Types.Int3 :&lt; GHC.Types.Int2 :&lt; {VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}Emp\n</pre>","tags":["basic"]},{"location":"blogposts/2020-04-12-polymorphic-perplexion.lhs/#a-polymorphic-insertion-sort","title":"A Polymorphic Insertion Sort","text":"<p>Next, lets write a simple insertion-sort function that  takes a plain unordered list of <code>[a]</code> and returns the elements  in increasing order:</p> <pre>76: insertSortP :: (Ord a) =&gt; [a] -&gt; IncList a\n77: forall a .\n(GHC.Classes.Ord&lt;[]&gt; a) =&gt;\n[a] -&gt; (PolymorphicPerplexion.IncList a)insertSortP [a]xs = foldr a -&gt; (PolymorphicPerplexion.IncList a) -&gt; (PolymorphicPerplexion.IncList a)insertP {VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}Emp {v : [a] | len v &gt;= 0\n           &amp;&amp; v == xs}xs\n78: \n79: insertP             :: (Ord a) =&gt; a -&gt; IncList a -&gt; IncList a\n80: forall a .\n(GHC.Classes.Ord&lt;[]&gt; a) =&gt;\na -&gt; (PolymorphicPerplexion.IncList a) -&gt; (PolymorphicPerplexion.IncList a)insertP ay Emp       = {VV : a | VV == y}y :&lt; {VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}Emp\n81: insertP y (x :&lt; xs)\n82:   | {VV : a | VV == y}y &lt;= {VV : a | VV == x}x         = {VV : a | VV == y}y :&lt; {VV : a | VV == x}x :&lt; {v : (PolymorphicPerplexion.IncList {VV : a | x &lt;= VV}) | v == xs}xs\n83:   | otherwise      = {VV : a | VV == x}x :&lt; (PolymorphicPerplexion.IncList a)insertP {VV : a | VV == y}y {v : (PolymorphicPerplexion.IncList {VV : a | x &lt;= VV}) | v == xs}xs\n</pre> <p>Happily, LH is able to verify the above code without any trouble! (If that seemed too easy, don't worry: if you mess up the comparison,  e.g. change the guard to <code>x &lt;= y</code> LH will complain about it.)</p>","tags":["basic"]},{"location":"blogposts/2020-04-12-polymorphic-perplexion.lhs/#a-monomorphic-insertion-sort","title":"A Monomorphic Insertion Sort","text":"<p>However, lets take the exact same code as above but change  the type signatures to make the functions monomorphic, here,  specialized to <code>Int</code> lists.</p> <pre>99: insertSortM :: [Int] -&gt; IncList Int \n100: [GHC.Types.Int] -&gt; (PolymorphicPerplexion.IncList GHC.Types.Int)insertSortM [GHC.Types.Int]xs = foldr GHC.Types.Int -&gt; (PolymorphicPerplexion.IncList GHC.Types.Int) -&gt; (PolymorphicPerplexion.IncList GHC.Types.Int)insertM {VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}Emp {v : [GHC.Types.Int] | len v &gt;= 0\n                       &amp;&amp; v == xs}xs\n101: \n102: insertM            :: Int -&gt; IncList Int -&gt; IncList Int \n103: GHC.Types.Int -&gt; (PolymorphicPerplexion.IncList GHC.Types.Int) -&gt; (PolymorphicPerplexion.IncList GHC.Types.Int)insertM GHC.Types.Inty Emp      = {v : GHC.Types.Int | v == y}y :&lt; {VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}Emp\n104: insertM y (x :&lt; xs)\n105:   | {v : GHC.Types.Int | v == y}y &lt;= {v : GHC.Types.Int | v == x}x         = {v : GHC.Types.Int | v == y}y :&lt; {v : GHC.Types.Int | v == x}x :&lt; {v : (PolymorphicPerplexion.IncList {v : GHC.Types.Int | x &lt;= v}) | v == xs}xs\n106:   | otherwise      = {v : GHC.Types.Int | v == x}x :&lt; (PolymorphicPerplexion.IncList GHC.Types.Int)insertM {v : GHC.Types.Int | v == y}y {v : (PolymorphicPerplexion.IncList {v : GHC.Types.Int | x &lt;= v}) | v == xs}xs\n</pre> <p>Huh? Now LH appears to be unhappy with the code! How is this possible?</p> <p>Lets look at the type error:</p> <pre>114:  /Users/rjhala/PerplexingPolymorphicProperties.lhs:80:27-38: Error: Liquid Type Mismatch\n115:   \n116:  80 |   | otherwise      = x :&lt; insertM y xs\n117:                                 ^^^^^^^^^^^^\n118:    Inferred type\n119:      VV : Int\n120:   \n121:    not a subtype of Required type\n122:      VV : {VV : Int | x &lt;= VV}\n123:   \n124:    In Context\n125:      x : Int\n</pre> <p>LH expects that since we're using the \"cons\" operator <code>:&lt;</code> the \"tail\" value <code>insertM y xs</code> must contain values <code>VV</code> that are greater than the  \"head\" <code>x</code>. The error says that, LH cannot prove this requirement of  actual list <code>insertM y xs</code>.</p> <p>Hmm, well thats a puzzler. Two questions that should come to mind.</p> <ol> <li> <p>Why does the above fact hold in the first place? </p> </li> <li> <p>How is LH able to deduce this fact with the polymorphic signature but not the monomorphic one?</p> </li> </ol> <p>Lets ponder the first question: why is every element  of <code>insert y xs</code> in fact larger than <code>x</code>? For three reasons:</p> <p>(a) every element in <code>xs</code> is larger than <code>x</code>, as the      list <code>x :&lt; xs</code> was ordered, </p> <p>(b) <code>y</code> is larger than <code>x</code> as established by the <code>otherwise</code> and crucially</p> <p>(c) the elements returned by <code>insert y xs</code> are either <code>y</code> or from <code>xs</code>!</p> <p>Now onto the second question: how does LH verify the polymorphic code, but not the monomorphic one? The reason is the fact (c)! LH is a modular verifier, meaning that the only information that it has about the behavior of <code>insert</code> at a call-site is the information captured in the (refinement)  type specification for <code>insert</code>. The polymorphic signature:</p> <pre>156: insertP :: (Ord a) =&gt; a -&gt; IncList a -&gt; IncList a\n</pre> <p>via parametricity, implicitly states fact (c). That is, if at a call-site  <code>insertP y xs</code> we pass in a value that is greater an <code>x</code> and a list of values  greater than <code>x</code> then via polymorphic instantiation at the call-site, LH  infers that the returned value must also be a list of elements greater than <code>x</code>!</p> <p>However, the monomorphic signature </p> <pre>167: insertM :: Int -&gt; IncList Int -&gt; IncList Int \n</pre> <p>offers no such insight. It simply says the function takes in an <code>Int</code> and another  ordered list of <code>Int</code> and returns another ordered list, whose actual elements could  be arbitrary <code>Int</code>. Specifically, at the call-site <code>insertP y xs</code> LH has no way to  conclude the the returned elements are indeed greater than <code>x</code> and hence rejects  the monomorphic code.</p>","tags":["basic"]},{"location":"blogposts/2020-04-12-polymorphic-perplexion.lhs/#perplexity","title":"Perplexity","text":"<p>While parametricity is all very nice, and LH's polymorphic instanatiation is very  clever and useful, it can also be quite mysterious. For example, q curious user  Ois\u00edn pointed out  that while the code below is rejected that if you uncomment the type signature  for <code>go</code> then it is accepted by LH!</p> <pre>187: insertSortP' :: (Ord a) =&gt; [a] -&gt; IncList a \n188: forall a .\n(GHC.Classes.Ord&lt;[]&gt; a) =&gt;\n[a] -&gt; (PolymorphicPerplexion.IncList a)insertSortP' = (PolymorphicPerplexion.IncList a)foldr a -&gt; (PolymorphicPerplexion.IncList a) -&gt; (PolymorphicPerplexion.IncList a)go {VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}Emp \n189:   where\n190:     -- go :: (Ord a) =&gt; a -&gt; IncList a -&gt; IncList a\n191:     a -&gt; (PolymorphicPerplexion.IncList a) -&gt; (PolymorphicPerplexion.IncList a)go ay Emp       = {VV : a | VV == y}y :&lt; {VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}Emp\n192:     go y (x :&lt; xs)\n193:       | {VV : a | VV == y}y &lt;= {VV : a | VV == x}x     = {VV : a | VV == y}y :&lt; {VV : a | VV == x}x :&lt; {v : (PolymorphicPerplexion.IncList {VV : a | x &lt;= VV}) | v == xs}xs\n194:       | otherwise  = {VV : a | VV == x}x :&lt; (PolymorphicPerplexion.IncList a)go {VV : a | VV == y}y {v : (PolymorphicPerplexion.IncList {VV : a | x &lt;= VV}) | v == xs}xs\n</pre> <p>This is thoroughly perplexing, but again, is explained by the absence of  parametricity. When we remove the type signature, GHC defaults to giving  <code>go</code> a monomorphic signature where the <code>a</code> is not universally quantified,  and which roughly captures the same specification as the monomorphic <code>insertM</code>  above causing verification to fail! </p> <p>Restoring the signature provides LH with the polymorphic specification,  which can be instantiated at the call-site to recover the fact <code>(c)</code>  that is crucial for verification.</p>","tags":["basic"]},{"location":"blogposts/2020-04-12-polymorphic-perplexion.lhs/#moral","title":"Moral","text":"<p>I hope that example illustrates two points.</p> <p>First, parametric polymorphism lets type specifications  say a lot more than they immediately let on: so do write  polymorphic signatures whenever possible.</p> <p>Second, on a less happy note, explaining why fancy type  checkers fail remains a vexing problem, whose difficulty  is compounded by increasing the cleverness of the type  system. </p> <p>We'd love to hear any ideas you might have to solve the  explanation problem!</p>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/","title":"LiquidHaskell is a GHC Plugin","text":"\\begin{code} module Plugin where  incr :: Int -&gt; Int incr x = x + 1 \\end{code}  <p>I enjoy working with LH. However, I'd be the very first to confess  that it has been incredibly tedious to get to work on existing code  bases, for various reasons.</p> <ol> <li> <p>LH ran one file at a time; it was a hassle to systematically analyze     all the modules in a single package.</p> </li> <li> <p>LH had no notion of packages; it was impossible to import specifications     across packages.</p> </li> <li> <p>LH had no integration with the standard compilation cycle; it was difficult     to get robust, development-time feedback using <code>ghci</code> based tools.</p> </li> </ol> <p>I'm delighted to announce the release of LH version 0.8.10.2.</p> <p>Thanks to the ingenuity and tireless efforts of our friends Alfredo Di Napoli  and Andres Loh at Well-Typed this new version  solves all three of the above problems in a single stroke, making it vastly simpler  (dare I say, quite straightforward!) to run LH on your Haskell code.</p> <p>Alfredo and Andres' key insight was that all the above problems could be solved if  LH could be re-engineered as a GHC Compiler Plugin  using hooks that GHC exposes to integrate external checkers during compilation. I strongly encourage you to check out Alfredo's talk at the Haskell Implementor's Workshop  if you want to learn more about the rather non-trivial mechanics of how this plugin was engineered. However, in this post, lets look at how and why to use the plugin,  in particular, how the plugin lets us</p> <ol> <li> <p>Use GHC's dependency resolution to analyze entire packages with minimal recompilation;</p> </li> <li> <p>Ship refined type specifications for old or new packages, and have them be verified at client code;</p> </li> <li> <p>Use tools like <code>ghci</code> based IDE tooling (e.g. <code>ghcid</code> or <code>ghcide</code> to get interactive feedback),</p> </li> </ol> <p>all of which ultimately, I hope, make Liquid Haskell easier to use.</p>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/#1-analyzing-packages","title":"1. Analyzing Packages","text":"<p>First, lets see a small \"demo\" of how to use the plugin to compile  a small <code>lh-plugin-demo</code>  package with two modules</p> <pre><code>module Demo.Lib where\n\n{-@ type Pos = {v:Int | 0 &lt; v} @-}\n\n{-@ incr :: Pos -&gt; Pos @-}\nincr :: Int -&gt; Int\nincr x = x - 1\n</code></pre> <p>which defines a function <code>incr</code> that consumes and returns positive integers, and </p> <pre><code>module Demo.Client where\n\nimport Demo.Lib\n\nbump :: Int -&gt; Int\nbump n = incr n\n</code></pre> <p>which imports <code>Demo.Lib</code> and uses <code>incr</code>.</p>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/#updating-cabal-to-compile-with-the-lh-plugin","title":"Updating <code>.cabal</code> to compile with the LH plugin","text":"<p>To \"check\" this code with LH we need only tell GHC to use it as a plugin, in two steps.</p> <ol> <li>First, adding a dependency to LH in the <code>.cabal</code> file (or <code>package.yaml</code>) </li> </ol> <pre><code>  build-depends:\n      liquid-base,\n      liquidhaskell &gt;= 0.8.10\n</code></pre> <ol> <li>Second, tell GHC to use the plugin </li> </ol> <pre><code>  ghc-options: -fplugin=LiquidHaskell\n</code></pre> <p>That's it. Now, everytime you (re-)build the code, GHC will automatically  run LH on the changed modules! If you use <code>stack</code> you may have to specify  a few more dependencies, as the various packages are not (yet) on stackage,  as shown in the demo <code>stack.yaml</code>. No extra dependencies are needede if you use <code>cabal-v2</code>. In both cases, you can use the respective files <code>stack.yaml</code> and <code>cabal.project</code> point to specific git snapshots if you want to use the most recent versions. If you clone the repo and run, e.g. <code>cabal v2-build</code> or <code>stack build</code> you'll get the following result, after the relevant dependencies  are downloaded and built of course...</p> <pre><code>rjhala@khao-soi ~/r/lh-demo (main)&gt; stack build\nlh-plugin-demo&gt; configure (lib)\nConfiguring lh-plugin-demo-0.1.0.0...\nlh-plugin-demo&gt; build (lib)\nPreprocessing library for lh-plugin-demo-0.1.0.0..\nBuilding library for lh-plugin-demo-0.1.0.0..\n[1 of 2] Compiling Demo.Lib\n\n**** LIQUID: UNSAFE ************************************************************\n\n/Users/rjhala/research/lh-demo/src/Demo/Lib.hs:7:1: error:\n    Liquid Type Mismatch\n    .\n    The inferred type\n      VV : {v : GHC.Types.Int | v == x - 1}\n    .\n    is not a subtype of the required type\n      VV : {VV : GHC.Types.Int | 0 &lt; VV}\n    .\n    in the context\n      x : {v : GHC.Types.Int | 0 &lt; v}\n  |\n7 | incr x = x - 1\n  | ^^^^^^^^^^^^^^\n</code></pre> <p>oops, of course that <code>(-)</code> should be a <code>(+)</code> if we want the output to also be positive so  lets edit the code to</p> <pre><code>incr x = x + 1\n</code></pre> <p>and now we get</p> <pre><code>rjhala@khao-soi ~/r/lh-plugin-demo (main)&gt; stack build\nlh-plugin-demo&gt; configure (lib)\nConfiguring lh-plugin-demo-0.1.0.0...\n\nlh-plugin-demo&gt; build (lib)\nPreprocessing library for lh-plugin-demo-0.1.0.0..\nBuilding library for lh-plugin-demo-0.1.0.0..\n[1 of 2] Compiling Demo.Lib\n\n**** LIQUID: SAFE (2 constraints checked) *****************************\n[2 of 2] Compiling Demo.Client\n\n**** LIQUID: UNSAFE ***************************************************\n\n/Users/rjhala/lh-plugin-demo/src/Demo/Client.hs:6:15: error:\n    Liquid Type Mismatch\n    .\n    The inferred type\n      VV : {v : GHC.Types.Int | v == n}\n    .\n    is not a subtype of the required type\n      VV : {VV : GHC.Types.Int | 0 &lt; VV}\n    .\n    in the context\n      n : GHC.Types.Int\n  |\n6 | bump n = incr n\n  |               ^\n</code></pre> <p>That is, during the build, LH complains that <code>incr</code> is being called with a value <code>n</code>  that is not strictly positive as required by <code>incr</code>. To fix the code, we can edit it  in various ways, e.g. to only call <code>incr</code> if <code>n &gt; 0</code></p> <pre><code>bump n \n  | n &gt; 0     = incr n\n  | otherwise = 0\n</code></pre> <p>and now the code builds successfully</p> <pre><code>rjhala@khao-soi ~/r/lh-plugin-demo (main)&gt; stack build\nlh-plugin-demo&gt; configure (lib)\nConfiguring lh-plugin-demo-0.1.0.0...\nlh-plugin-demo&gt; build (lib)\nPreprocessing library for lh-plugin-demo-0.1.0.0..\nBuilding library for lh-plugin-demo-0.1.0.0..\n[2 of 2] Compiling Demo.Client\n\n**** LIQUID: SAFE (2 constraints checked) ****************************\nlh-plugin-demo&gt; copy/register\nInstalling library in ... \nRegistering library for lh-plugin-demo-0.1.0.0..\n</code></pre>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/#benefits","title":"Benefits","text":"<p>There are a couple of benefits to note immediately</p> <ul> <li> <p>A plain <code>stack build</code> or <code>cabal v2-build</code> takes care of all the installing and checking!</p> </li> <li> <p>No need to separately install LH; its part of the regular build.</p> </li> <li> <p>GHC's recompilation machinery ensures that only the relevant    modules are checked, e.g. the second time round, LH did not need    to analyze <code>Lib.hs</code> only <code>Client.hs</code></p> </li> </ul>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/#2-shipping-specifications-with-packages","title":"2. Shipping Specifications with Packages","text":"<p>While the above is nice, in principle it could have been done  with some clever <code>makefile</code> trickery (perhaps?). What I'm much  more excited about is that now, for the first time, you can  ship refinement type specifications within plain Haskell packages.</p> <p>For example, consider a different lh-plugin-demo-client  package that uses <code>incr</code> from <code>lh-plugin-demo</code>:</p> <pre><code>bump :: Int -&gt; Int\nbump n\n  | n &gt; 0     = incr n\n  | otherwise = incr (0 - n)\n</code></pre> <p>Again, the <code>lh-plugin-demo-client.cabal</code> file need only specify the various  dependencies:</p> <pre><code>  build-depends:\n      liquid-base,\n      liquidhaskell,\n      lh-plugin-demo\n````\n\nand that GHC should use the plugin\n\n</code></pre> <p>ghc-options: -fplugin=LiquidHaskell</p> <pre><code>\nand lo! a plain `stack build` or `cabal v2-build` takes care of all the rest.\n\n</code></pre> <p>rjhala@khao-soi ~/r/lh-plugin-demo-client (main)&gt; stack build lh-plugin-demo-client&gt; configure (lib) Configuring lh-plugin-demo-client-0.1.0.0...</p> <p>lh-plugin-demo-client&gt; build (lib) Preprocessing library for lh-plugin-demo-client-0.1.0.0.. Building library for lh-plugin-demo-client-0.1.0.0.. [1 of 1] Compiling Demo.ExternalClient</p> <p>* LIQUID: UNSAFE *******</p> <p>/Users/rjhala/lh-plugin-demo-client/src/Demo/ExternalClient.hs:8:22: error:     Liquid Type Mismatch     .     The inferred type       VV : {v : GHC.Types.Int | v == 0 - n}     .     is not a subtype of the required type       VV : {VV : GHC.Types.Int | VV &gt; 0}     .     in the context       n : GHC.Types.Int   | 8 |   | otherwise = incr (0 - n)   |                      ^^^^^^^</p> <pre><code>\n(Whoops another off by one error, lets fix it!)\n\n```haskell\nbump :: Int -&gt; Int\nbump n\n  | n &gt; 0     = incr n\n  | otherwise = incr (1 - n)\n</code></pre> <p>and now all is well</p> <pre><code>rjhala@khao-soi ~/r/lh-plugin-demo-client (main)&gt; stack build --fast\nlh-plugin-demo-client&gt; configure (lib)\nConfiguring lh-plugin-demo-client-0.1.0.0...\nlh-plugin-demo-client&gt; build (lib)\nPreprocessing library for lh-plugin-demo-client-0.1.0.0..\nBuilding library for lh-plugin-demo-client-0.1.0.0..\n[1 of 1] Compiling Demo.ExternalClient\n\n**** LIQUID: SAFE (3 constraints checked) *****************************\n\nlh-plugin-demo-client&gt; copy/register\nInstalling library in ... \nRegistering library for lh-plugin-demo-client-0.1.0.0..\n</code></pre>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/#prelude-specifications","title":"Prelude Specifications","text":"<p>Did you notice the strange <code>liquid-base</code> dependency in the cabal files? </p> <p>Previously, LH came installed with a \"built-in\" set of specifications for  various <code>prelude</code> modules. This was hacked inside LH in a rather unfortunate  manner, which made these specifications very difficult to extend. </p> <p>Moving forward, all the refinement specifications e.g. for <code>GHC.List</code> or <code>Data.Vector</code>  or <code>Data.Set</code> or <code>Data.Bytestring</code> simply live in packages that mirror the original  versions, e.g. <code>liquid-base</code>,  <code>liquid-vector</code>, <code>liquid-containers</code>, <code>liquid-bytestring</code>. Each <code>liquid-X</code> package directly re-exports all the contents of the corresponding <code>X</code>  package, but with any additional refinement type specifications (Note: After writing this post the mechanism to handle specifications evolved again. See this other post for the details).</p> <p>Thus, all the refined types for various prelude operations like <code>(+)</code> or <code>(-)</code> or <code>head</code>  and so on, now ship with <code>liquid-base</code> and we add that dependency instead of base. Similarly, if you want to verify that your code has no <code>vector</code>-index overflow errors, you simply build with <code>liquid-vector</code> instead of <code>vector</code>! Of course, in an ideal,  and hopefully not too distant future, we'd directly include the refinement types inside  <code>vector</code>, <code>containers</code> or <code>bytestring</code> respectively.</p>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/#benefits_1","title":"Benefits","text":"<p>So to recap, the plugin offers several nice benefits with respect to shipping specifications</p> <ul> <li> <p>Refined signatures are bundled together with packages,</p> </li> <li> <p>Importing packages with refined signatures automatically ensures those signatures are    checked on client code,</p> </li> <li> <p>You can (optionally) use refined versions of <code>prelude</code> signatures, and hence, even    write refined versions of your favorite custom preludes.</p> </li> </ul>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/#3-editor-tooling","title":"3. Editor Tooling","text":"<p>I saved my favorite part for the end.</p> <p>What I have enjoyed the most about the plugin is that now (almost) all the GHC-based  tools that I use in my regular Haskell development workflow, automatically incorporate  LH too! For example, reloading a module in <code>ghci</code> automatically re-runs LH on that file.</p>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/#ghcid","title":"<code>ghcid</code>","text":"<p>This means, that the mega robust, editor-independent <code>ghcid</code> now automatically  produces LH type errors when you save a file. Here's <code>ghcid</code> running in a terminal.</p> <p></p>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/#vscode","title":"<code>vscode</code>","text":"<p>Editor plugins now produce little red squiggles for LH errors too. Here's <code>code</code> with the <code>Simple GHC (Haskell) Integration</code> plugin</p> <p></p>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/#emacs","title":"<code>emacs</code>","text":"<p>Here's <code>doom-emacs</code> with the <code>dante</code> plugin </p> <p></p>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/#vim","title":"<code>vim</code>","text":"<p>And here is <code>neovim</code> with <code>ALE</code> and the <code>stack-build</code> linter</p> <p></p>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/#benefits_2","title":"Benefits","text":"<ul> <li>Some of this was possible before: we had to write special LH modes for different    editors -- special thanks to Alan Zimmerman's fantastic    haskell-ide-engine!. However, now we can simply work with the increasingly more robust    GHCi and Language-Server based tools already available for major editors and IDEs.</li> </ul>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/#4-caveats","title":"4. Caveats","text":"<p>Of course, all the above is quite new, and so there are a few things to watch out for.</p> <ul> <li> <p>First, for certain kinds of code, LH can take much longer than GHC to check a file.   This means, it may actually be too slow to run on every save, and you may want to    tweak your <code>.cabal</code> file to only run the plugin during particular builds, not on    every file update.</p> </li> <li> <p>Second, the <code>liquid-X</code> machinery is designed to allow drop in replacements for various    base packages; it appears to work well in our testing, but if you try it, do let us know    if you hit some odd problems that we may not have anticipated.</p> </li> </ul>","tags":["basic"]},{"location":"blogposts/2020-08-20-lh-as-a-ghc-plugin.lhs/#summary","title":"Summary","text":"<p>Hopefully the above provides an overview of the new plugin mode: how it can be used, and what things it enables. In particular, by virtue of being a GHC plugin, LH can now</p> <ol> <li> <p>Run on entire Haskell packages;</p> </li> <li> <p>Export and import specifications across packages;</p> </li> <li> <p>Provide errors via existing GHC/i based editor tooling. </p> </li> </ol> <p>All of which, I hope, makes it a lot easier to run LH on your code.</p> <p>Our most profound thanks to the National Science Foundation:  this work was made possible by the support provided by grant 1917854:  \"FMitF: Track II: Refinement Types in the Haskell Ecosystem\".</p>","tags":["basic"]}]}